---
description: Unified v2 API endpoint coding rules and structure for all endpoints going forward
globs: inbound-app/app/api/**/*.ts
---

# v2 API Endpoint Coding Rules

This rule establishes consistent structure, typing, auth, logging, error handling, and pagination patterns for all API endpoints. It is based on existing implementations under `inbound-app/app/api/v2/` and complements the more concise spec in [v2-api-spec.mdc](mdc:inbound-app/app/api/v2/.cursor/v2-api-spec.mdc).

## Core Principles
- **Auth first**: Validate every request at the top of each handler using `validateRequest(request)` from [helper/main.ts](mdc:inbound-app/app/api/v2/helper/main.ts). Return 401 with `{ error }` on failure.
- **Typed handlers**: Define request/response TypeScript interfaces immediately above each handler function (GET/POST/PUT/DELETE). Avoid duplicate DB types; infer database shapes via Drizzle in feature layers. Only define API request/response shapes here.
- **No any**: Never use `any`. Prefer explicit interfaces and discriminated unions where needed.
- **Params discipline**: For dynamic routes, type `params` as `Promise<{ id: string }>` and destructure with `const { id } = await params` before use.
- **Simple, shallow routes**: Keep depth to 2: `/api/v2/{resource}` and `/api/v2/{resource}/[id]` or `/api/v2/{resource}/[id]/{subresource}` when necessary (e.g., `dns-records`, `test`).
- **Descriptive logging with emojis**: Log key steps, inputs (sanitized), branching, and outcomes. Use the existing style from v2 endpoints.
- **User scoping**: Always constrain DB queries by `userId` from auth for multi-tenant safety.
- **Consistent pagination**: List endpoints return `data` + `pagination` (+ optional `meta`).
- **Explicit status codes**: 200/201 for success, 400 for validation, 401 for auth, 403 for access, 404 for not found, 409 for conflict, 500 for unhandled.
- **Docs + tests**: When creating/updating endpoints, also add/update tests alongside `inbound-app/app/api/v2/api.test.ts` and update Mintlify docs in `inbound-docs/` following the docs rules.
- **Email data source**: Use `structuredEmails` tables; do not reintroduce deprecated `receivedEmails` or `parsedEmails`.

## Route Structure
- Directory pattern:
  - Collection: `inbound-app/app/api/v2/{resource}/route.ts`
  - Item: `inbound-app/app/api/v2/{resource}/[id]/route.ts`
  - Limited subresource: `inbound-app/app/api/v2/{resource}/[id]/{subresource}/route.ts` (e.g., `dns-records`, `test`)
- Keep resource depth ‚â§ 2.

## Handler Template
Use this skeleton as a starting point, adapting names and shapes per endpoint. See examples in
[domains/route.ts](mdc:inbound-app/app/api/v2/domains/route.ts),
[domains/[id]/route.ts](mdc:inbound-app/app/api/v2/domains/[id]/route.ts),
[email-addresses/route.ts](mdc:inbound-app/app/api/v2/email-addresses/route.ts),
[emails/route.ts](mdc:inbound-app/app/api/v2/emails/route.ts), and
[emails/[id]/reply/route.ts](mdc:inbound-app/app/api/v2/emails/[id]/reply/route.ts).

```ts
import { NextRequest, NextResponse } from 'next/server'
import { validateRequest } from '../helper/main'
import { db } from '@/lib/db'
import { eq, and, desc, count } from 'drizzle-orm'
// import needed schema tables from '@/lib/db/schema'

// TYPES FOR GET
export interface GetThingsRequest {
  limit?: number
  offset?: number
}

export interface ThingItem {
  id: string
  // ...fields exposed by the API (not necessarily 1:1 with DB)
}

export interface GetThingsResponse {
  data: ThingItem[]
  pagination: { limit: number; offset: number; total: number; hasMore: boolean }
}

export async function GET(request: NextRequest) {
  console.log('üåê GET /api/v2/things - Starting request')
  try {
    console.log('üîê Validating request authentication')
    const { userId, error } = await validateRequest(request)
    if (!userId) {
      console.log('‚ùå Authentication failed:', error)
      return NextResponse.json({ error }, { status: 401 })
    }
    console.log('‚úÖ Authentication successful for userId:', userId)

    const { searchParams } = new URL(request.url)
    const limit = Math.min(parseInt(searchParams.get('limit') || '50'), 100)
    const offset = parseInt(searchParams.get('offset') || '0')
    if (limit < 1 || limit > 100) return NextResponse.json({ error: 'Limit must be between 1 and 100' }, { status: 400 })
    if (offset < 0) return NextResponse.json({ error: 'Offset must be non-negative' }, { status: 400 })

    // Query DB with user scoping and return results...
    // const rows = await db.select(...).from(things).where(eq(things.userId, userId)).orderBy(desc(things.createdAt)).limit(limit).offset(offset)
    // const total = (await db.select({ count: count() }).from(things).where(eq(things.userId, userId)))[0]?.count || 0

    const response: GetThingsResponse = {
      data: [],
      pagination: { limit, offset, total: 0, hasMore: false }
    }
    console.log('‚úÖ Successfully retrieved things')
    return NextResponse.json(response)
  } catch (err) {
    console.error('‚ùå GET /api/v2/things - Error:', err)
    return NextResponse.json({ error: 'Failed to fetch things', details: err instanceof Error ? err.message : 'Unknown error' }, { status: 500 })
  }
}

// TYPES FOR POST
export interface PostThingsRequest { /* ... */ }
export interface PostThingsResponse { id: string }

export async function POST(request: NextRequest) {
  console.log('‚ûï POST /api/v2/things - Starting')
  try {
    const { userId, error } = await validateRequest(request)
    if (!userId) return NextResponse.json({ error }, { status: 401 })

    const data: PostThingsRequest = await request.json()
    // Validate inputs and create resource

    const response: PostThingsResponse = { id: '...' }
    return NextResponse.json(response, { status: 201 })
  } catch (err) {
    console.error('‚ùå POST /api/v2/things - Error:', err)
    return NextResponse.json({ error: 'Failed to create', details: err instanceof Error ? err.message : 'Unknown error' }, { status: 500 })
  }
}
```

## Authentication
- Always call `validateRequest(request)` first. Example usage in
  - [domains/route.ts](mdc:inbound-app/app/api/v2/domains/route.ts)
  - [email-addresses/[id]/route.ts](mdc:inbound-app/app/api/v2/email-addresses/[id]/route.ts)
- All queries must be scoped by the returned `userId`.

## Parameters and Query Handling
- Dynamic route params: `export async function GET(request: NextRequest, { params }: { params: Promise<{ id: string }> }) { const { id } = await params }`
- Query params: `const { searchParams } = new URL(request.url)`; coerce, bound-check, and validate values. See
  - [domains/route.ts (GET)](mdc:inbound-app/app/api/v2/domains/route.ts)

## Logging Guidelines
- Use clear, stepwise logs with emojis for start, auth, validation, DB ops, external calls, and completion. Examples:
  - Start: `üåê GET /api/v2/domains - Starting request`
  - Auth OK/Fail: `‚úÖ Authentication successful‚Ä¶` / `‚ùå Authentication failed: ‚Ä¶`
  - DB ops: `üîç Querying ‚Ä¶` / `üìä Found N ‚Ä¶`
  - External service ops (AWS, DNS): `üîß`, `üîç`, `‚úÖ`, `‚ö†Ô∏è`
  - Completion: `‚úÖ Successfully ‚Ä¶`
  - Errors: `‚ùå <METHOD> <path> - Error:` with structured details

## Response Shapes
- Lists return `{ data, pagination: { limit, offset, total, hasMore }, meta? }`.
  - Examples: [endpoints/route.ts](mdc:inbound-app/app/api/v2/endpoints/route.ts), [domains/route.ts](mdc:inbound-app/app/api/v2/domains/route.ts), [email-addresses/route.ts](mdc:inbound-app/app/api/v2/email-addresses/route.ts)
- Single resource returns a flat, typed object (include nested objects where helpful). Example: [domains/[id]/route.ts](mdc:inbound-app/app/api/v2/domains/[id]/route.ts)
- Error responses: `{ error: string, details?: string }` with appropriate status code.

## Database and Types
- Import `db` from `@/lib/db` and schema tables from `@/lib/db/schema`.
- Use Drizzle operators (`eq`, `and`, `desc`, `count`) and `.limit`, `.offset` for pagination.
- Scope queries by `userId` for tenant safety.
- Follow the project-wide types rule: infer DB types via Drizzle in feature layers and avoid duplicating schema shapes in endpoint code. API request/response types are defined per-handler.

## Idempotency (when creating/sending)
- For create/send actions (e.g., emails), support the `Idempotency-Key` header and return the previously created resource when the same key is reused. See tests in [api.test.ts](mdc:inbound-app/app/api/v2/api.test.ts) and implementation in [emails/route.ts](mdc:inbound-app/app/api/v2/emails/route.ts).

## AWS/DNS Operations
- Wrap AWS SES and DNS verification calls in try/catch with clear logs. Update DB flags accordingly. See
  - [domains/route.ts](mdc:inbound-app/app/api/v2/domains/route.ts)
  - [domains/[id]/route.ts](mdc:inbound-app/app/api/v2/domains/[id]/route.ts)

## Reply and Threading Conventions
- For email replies, construct proper `In-Reply-To`/`References` headers, default `to` to the original sender when omitted, and default subject to `Re: {original}` when omitted. See [emails/[id]/reply/route.ts](mdc:inbound-app/app/api/v2/emails/[id]/reply/route.ts).
- For threads, normalize `Message-Id` and `References` consistently. See [mail/[id]/thread/route.ts](mdc:inbound-app/app/api/v2/mail/[id]/thread/route.ts).

## Testing and Documentation
- Add/extend endpoint coverage in [api.test.ts](mdc:inbound-app/app/api/v2/api.test.ts).
- Update Mintlify docs in `inbound-docs/` using the clean documentation standard (see workspace rule), reflecting new endpoints, params, and response shapes.

## Do/Don‚Äôt Summary
- Do: auth first, typed inputs/outputs, await `params`, validate queries, user-scope DB, consistent logging, correct status codes, structured pagination, idempotency where applicable, and update docs/tests.
- Don‚Äôt: use `any`, duplicate DB types, exceed route depth 2, leak tenant data, or reference deprecated email tables.


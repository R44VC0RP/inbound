{"version":3,"sources":["turbopack:///[project]/node_modules/src/entity.ts","turbopack:///[project]/node_modules/src/column.ts","turbopack:///[project]/node_modules/src/column-builder.ts","turbopack:///[project]/node_modules/src/table.utils.ts","turbopack:///[project]/node_modules/src/pg-core/foreign-keys.ts","turbopack:///[project]/node_modules/src/tracing-utils.ts","turbopack:///[project]/node_modules/src/pg-core/unique-constraint.ts","turbopack:///[project]/node_modules/src/pg-core/utils/array.ts","turbopack:///[project]/node_modules/src/pg-core/columns/common.ts","turbopack:///[project]/node_modules/src/pg-core/columns/enum.ts","turbopack:///[project]/node_modules/src/subquery.ts","turbopack:///[project]/node_modules/drizzle-orm/version.js","turbopack:///[project]/node_modules/src/tracing.ts","turbopack:///[project]/node_modules/src/view-common.ts","turbopack:///[project]/node_modules/src/table.ts","turbopack:///[project]/node_modules/src/sql/sql.ts","turbopack:///[project]/node_modules/src/utils.ts","turbopack:///[project]/node_modules/src/pg-core/columns/date.common.ts","turbopack:///[project]/node_modules/src/pg-core/columns/date.ts","turbopack:///[project]/node_modules/src/pg-core/columns/json.ts","turbopack:///[project]/node_modules/src/pg-core/columns/jsonb.ts","turbopack:///[project]/node_modules/src/pg-core/columns/numeric.ts","turbopack:///[project]/node_modules/src/pg-core/columns/time.ts","turbopack:///[project]/node_modules/src/pg-core/columns/timestamp.ts","turbopack:///[project]/node_modules/src/pg-core/columns/uuid.ts","turbopack:///[project]/node_modules/src/pg-core/columns/int.common.ts","turbopack:///[project]/node_modules/src/pg-core/columns/bigint.ts","turbopack:///[project]/node_modules/src/pg-core/columns/bigserial.ts","turbopack:///[project]/node_modules/src/pg-core/columns/boolean.ts","turbopack:///[project]/node_modules/src/pg-core/columns/char.ts","turbopack:///[project]/node_modules/src/pg-core/columns/cidr.ts","turbopack:///[project]/node_modules/src/pg-core/columns/custom.ts","turbopack:///[project]/node_modules/src/pg-core/columns/double-precision.ts","turbopack:///[project]/node_modules/src/pg-core/columns/inet.ts","turbopack:///[project]/node_modules/src/pg-core/columns/integer.ts","turbopack:///[project]/node_modules/src/pg-core/columns/interval.ts","turbopack:///[project]/node_modules/src/pg-core/columns/line.ts","turbopack:///[project]/node_modules/src/pg-core/columns/macaddr.ts","turbopack:///[project]/node_modules/src/pg-core/columns/macaddr8.ts","turbopack:///[project]/node_modules/src/pg-core/columns/point.ts","turbopack:///[project]/node_modules/src/pg-core/columns/postgis_extension/utils.ts","turbopack:///[project]/node_modules/src/pg-core/columns/postgis_extension/geometry.ts","turbopack:///[project]/node_modules/src/pg-core/columns/real.ts","turbopack:///[project]/node_modules/src/pg-core/columns/serial.ts","turbopack:///[project]/node_modules/src/pg-core/columns/smallint.ts","turbopack:///[project]/node_modules/src/pg-core/columns/smallserial.ts","turbopack:///[project]/node_modules/src/pg-core/columns/text.ts","turbopack:///[project]/node_modules/src/pg-core/columns/varchar.ts","turbopack:///[project]/node_modules/src/pg-core/columns/vector_extension/bit.ts","turbopack:///[project]/node_modules/src/pg-core/columns/vector_extension/halfvec.ts","turbopack:///[project]/node_modules/src/pg-core/columns/vector_extension/sparsevec.ts","turbopack:///[project]/node_modules/src/pg-core/columns/vector_extension/vector.ts","turbopack:///[project]/node_modules/src/pg-core/columns/all.ts","turbopack:///[project]/node_modules/src/pg-core/table.ts","turbopack:///[project]/lib/db/auth-schema.ts"],"sourcesContent":["export const entityKind = Symbol.for('drizzle:entityKind');\nexport const hasOwnEntityKind = Symbol.for('drizzle:hasOwnEntityKind');\n\nexport interface DrizzleEntity {\n\t[entityKind]: string;\n}\n\nexport type DrizzleEntityClass<T> =\n\t& ((abstract new(...args: any[]) => T) | (new(...args: any[]) => T))\n\t& DrizzleEntity;\n\nexport function is<T extends DrizzleEntityClass<any>>(value: any, type: T): value is InstanceType<T> {\n\tif (!value || typeof value !== 'object') {\n\t\treturn false;\n\t}\n\n\tif (value instanceof type) { // eslint-disable-line no-instanceof/no-instanceof\n\t\treturn true;\n\t}\n\n\tif (!Object.prototype.hasOwnProperty.call(type, entityKind)) {\n\t\tthrow new Error(\n\t\t\t`Class \"${\n\t\t\t\ttype.name ?? '<unknown>'\n\t\t\t}\" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`,\n\t\t);\n\t}\n\n\tlet cls = Object.getPrototypeOf(value).constructor;\n\tif (cls) {\n\t\t// Traverse the prototype chain to find the entityKind\n\t\twhile (cls) {\n\t\t\tif (entityKind in cls && cls[entityKind] === type[entityKind]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tcls = Object.getPrototypeOf(cls);\n\t\t}\n\t}\n\n\treturn false;\n}\n","import type {\n\tColumnBuilderBaseConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tGeneratedColumnConfig,\n\tGeneratedIdentityConfig,\n} from './column-builder.ts';\nimport { entityKind } from './entity.ts';\nimport type { DriverValueMapper, SQL, SQLWrapper } from './sql/sql.ts';\nimport type { Table } from './table.ts';\nimport type { Update } from './utils.ts';\n\nexport interface ColumnBaseConfig<\n\tTDataType extends ColumnDataType,\n\tTColumnType extends string,\n> extends ColumnBuilderBaseConfig<TDataType, TColumnType> {\n\ttableName: string;\n\tnotNull: boolean;\n\thasDefault: boolean;\n\tisPrimaryKey: boolean;\n\tisAutoincrement: boolean;\n\thasRuntimeDefault: boolean;\n}\n\nexport type ColumnTypeConfig<T extends ColumnBaseConfig<ColumnDataType, string>, TTypeConfig extends object> = T & {\n\tbrand: 'Column';\n\ttableName: T['tableName'];\n\tname: T['name'];\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: T['data'];\n\tdriverParam: T['driverParam'];\n\tnotNull: T['notNull'];\n\thasDefault: T['hasDefault'];\n\tisPrimaryKey: T['isPrimaryKey'];\n\tisAutoincrement: T['isAutoincrement'];\n\thasRuntimeDefault: T['hasRuntimeDefault'];\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseColumn: infer U } ? U : unknown;\n\tgenerated: GeneratedColumnConfig<T['data']> | undefined;\n\tidentity: undefined | 'always' | 'byDefault';\n} & TTypeConfig;\n\nexport type ColumnRuntimeConfig<TData, TRuntimeConfig extends object> = ColumnBuilderRuntimeConfig<\n\tTData,\n\tTRuntimeConfig\n>;\n\nexport interface Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTRuntimeConfig extends object = object,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTTypeConfig extends object = object,\n> extends DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n/*\n\t`Column` only accepts a full `ColumnConfig` as its generic.\n\tTo infer parts of the config, use `AnyColumn` that accepts a partial config.\n\tSee `GetColumnData` for example usage of inferring.\n*/\nexport abstract class Column<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n> implements DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Column';\n\n\tdeclare readonly _: ColumnTypeConfig<T, TTypeConfig>;\n\n\treadonly name: string;\n\treadonly keyAsName: boolean;\n\treadonly primary: boolean;\n\treadonly notNull: boolean;\n\treadonly default: T['data'] | SQL | undefined;\n\treadonly defaultFn: (() => T['data'] | SQL) | undefined;\n\treadonly onUpdateFn: (() => T['data'] | SQL) | undefined;\n\treadonly hasDefault: boolean;\n\treadonly isUnique: boolean;\n\treadonly uniqueName: string | undefined;\n\treadonly uniqueType: string | undefined;\n\treadonly dataType: T['dataType'];\n\treadonly columnType: T['columnType'];\n\treadonly enumValues: T['enumValues'] = undefined;\n\treadonly generated: GeneratedColumnConfig<T['data']> | undefined = undefined;\n\treadonly generatedIdentity: GeneratedIdentityConfig | undefined = undefined;\n\n\tprotected config: ColumnRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(\n\t\treadonly table: Table,\n\t\tconfig: ColumnRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tthis.config = config;\n\t\tthis.name = config.name;\n\t\tthis.keyAsName = config.keyAsName;\n\t\tthis.notNull = config.notNull;\n\t\tthis.default = config.default;\n\t\tthis.defaultFn = config.defaultFn;\n\t\tthis.onUpdateFn = config.onUpdateFn;\n\t\tthis.hasDefault = config.hasDefault;\n\t\tthis.primary = config.primaryKey;\n\t\tthis.isUnique = config.isUnique;\n\t\tthis.uniqueName = config.uniqueName;\n\t\tthis.uniqueType = config.uniqueType;\n\t\tthis.dataType = config.dataType as T['dataType'];\n\t\tthis.columnType = config.columnType;\n\t\tthis.generated = config.generated;\n\t\tthis.generatedIdentity = config.generatedIdentity;\n\t}\n\n\tabstract getSQLType(): string;\n\n\tmapFromDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n\n\tmapToDriverValue(value: unknown): unknown {\n\t\treturn value;\n\t}\n\n\t// ** @internal */\n\tshouldDisableInsert(): boolean {\n\t\treturn this.config.generated !== undefined && this.config.generated.type !== 'byDefault';\n\t}\n}\n\nexport type UpdateColConfig<\n\tT extends ColumnBaseConfig<ColumnDataType, string>,\n\tTUpdate extends Partial<ColumnBaseConfig<ColumnDataType, string>>,\n> = Update<T, TUpdate>;\n\nexport type AnyColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = Column<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport type GetColumnData<TColumn extends Column, TInferMode extends 'query' | 'raw' = 'query'> =\n\t// dprint-ignore\n\tTInferMode extends 'raw' // Raw mode\n\t\t? TColumn['_']['data'] // Just return the underlying type\n\t\t: TColumn['_']['notNull'] extends true // Query mode\n\t\t? TColumn['_']['data'] // Query mode, not null\n\t\t: TColumn['_']['data'] | null; // Query mode, nullable\n\nexport type InferColumnsDataTypes<TColumns extends Record<string, Column>> = {\n\t[Key in keyof TColumns]: GetColumnData<TColumns[Key], 'query'>;\n};\n","import { entityKind } from '~/entity.ts';\nimport type { Column } from './column.ts';\nimport type { GelColumn, GelExtraConfigColumn } from './gel-core/index.ts';\nimport type { MySqlColumn } from './mysql-core/index.ts';\nimport type { ExtraConfigColumn, PgColumn, PgSequenceOptions } from './pg-core/index.ts';\nimport type { SingleStoreColumn } from './singlestore-core/index.ts';\nimport type { SQL } from './sql/sql.ts';\nimport type { SQLiteColumn } from './sqlite-core/index.ts';\nimport type { Assume, Simplify } from './utils.ts';\n\nexport type ColumnDataType =\n\t| 'string'\n\t| 'number'\n\t| 'boolean'\n\t| 'array'\n\t| 'json'\n\t| 'date'\n\t| 'bigint'\n\t| 'custom'\n\t| 'buffer'\n\t| 'dateDuration'\n\t| 'duration'\n\t| 'relDuration'\n\t| 'localTime'\n\t| 'localDate'\n\t| 'localDateTime';\n\nexport type Dialect = 'pg' | 'mysql' | 'sqlite' | 'singlestore' | 'common' | 'gel';\n\nexport type GeneratedStorageMode = 'virtual' | 'stored';\n\nexport type GeneratedType = 'always' | 'byDefault';\n\nexport type GeneratedColumnConfig<TDataType> = {\n\tas: TDataType | SQL | (() => SQL);\n\ttype?: GeneratedType;\n\tmode?: GeneratedStorageMode;\n};\n\nexport type GeneratedIdentityConfig = {\n\tsequenceName?: string;\n\tsequenceOptions?: PgSequenceOptions;\n\ttype: 'always' | 'byDefault';\n};\n\nexport interface ColumnBuilderBaseConfig<TDataType extends ColumnDataType, TColumnType extends string> {\n\tname: string;\n\tdataType: TDataType;\n\tcolumnType: TColumnType;\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: string[] | undefined;\n}\n\nexport type MakeColumnConfig<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTableName extends string,\n\tTData = T extends { $type: infer U } ? U : T['data'],\n> = {\n\tname: T['name'];\n\ttableName: TTableName;\n\tdataType: T['dataType'];\n\tcolumnType: T['columnType'];\n\tdata: TData;\n\tdriverParam: T['driverParam'];\n\tnotNull: T extends { notNull: true } ? true : false;\n\thasDefault: T extends { hasDefault: true } ? true : false;\n\tisPrimaryKey: T extends { isPrimaryKey: true } ? true : false;\n\tisAutoincrement: T extends { isAutoincrement: true } ? true : false;\n\thasRuntimeDefault: T extends { hasRuntimeDefault: true } ? true : false;\n\tenumValues: T['enumValues'];\n\tbaseColumn: T extends { baseBuilder: infer U extends ColumnBuilderBase } ? BuildColumn<TTableName, U, 'common'>\n\t\t: never;\n\tidentity: T extends { identity: 'always' } ? 'always' : T extends { identity: 'byDefault' } ? 'byDefault' : undefined;\n\tgenerated: T extends { generated: infer G } ? unknown extends G ? undefined\n\t\t: G extends undefined ? undefined\n\t\t: G\n\t\t: undefined;\n} & {};\n\nexport type ColumnBuilderTypeConfig<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> = Simplify<\n\t& {\n\t\tbrand: 'ColumnBuilder';\n\t\tname: T['name'];\n\t\tdataType: T['dataType'];\n\t\tcolumnType: T['columnType'];\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverParam'];\n\t\tnotNull: T extends { notNull: infer U } ? U : boolean;\n\t\thasDefault: T extends { hasDefault: infer U } ? U : boolean;\n\t\tenumValues: T['enumValues'];\n\t\tidentity: T extends { identity: infer U } ? U : unknown;\n\t\tgenerated: T extends { generated: infer G } ? G extends undefined ? unknown : G : unknown;\n\t}\n\t& TTypeConfig\n>;\n\nexport type ColumnBuilderRuntimeConfig<TData, TRuntimeConfig extends object = object> = {\n\tname: string;\n\tkeyAsName: boolean;\n\tnotNull: boolean;\n\tdefault: TData | SQL | undefined;\n\tdefaultFn: (() => TData | SQL) | undefined;\n\tonUpdateFn: (() => TData | SQL) | undefined;\n\thasDefault: boolean;\n\tprimaryKey: boolean;\n\tisUnique: boolean;\n\tuniqueName: string | undefined;\n\tuniqueType: string | undefined;\n\tdataType: string;\n\tcolumnType: string;\n\tgenerated: GeneratedColumnConfig<TData> | undefined;\n\tgeneratedIdentity: GeneratedIdentityConfig | undefined;\n} & TRuntimeConfig;\n\nexport interface ColumnBuilderExtraConfig {\n\tprimaryKeyHasDefault?: boolean;\n}\n\nexport type NotNull<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tnotNull: true;\n\t};\n};\n\nexport type HasDefault<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\thasDefault: true;\n\t};\n};\n\nexport type IsPrimaryKey<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tisPrimaryKey: true;\n\t};\n};\n\nexport type IsAutoincrement<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\tisAutoincrement: true;\n\t};\n};\n\nexport type HasRuntimeDefault<T extends ColumnBuilderBase> = T & {\n\t_: {\n\t\thasRuntimeDefault: true;\n\t};\n};\n\nexport type $Type<T extends ColumnBuilderBase, TType> = T & {\n\t_: {\n\t\t$type: TType;\n\t};\n};\n\nexport type HasGenerated<T extends ColumnBuilderBase, TGenerated extends {} = {}> = T & {\n\t_: {\n\t\thasDefault: true;\n\t\tgenerated: TGenerated;\n\t};\n};\n\nexport type IsIdentity<\n\tT extends ColumnBuilderBase,\n\tTType extends 'always' | 'byDefault',\n> = T & {\n\t_: {\n\t\tnotNull: true;\n\t\thasDefault: true;\n\t\tidentity: TType;\n\t};\n};\nexport interface ColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> {\n\t_: ColumnBuilderTypeConfig<T, TTypeConfig>;\n}\n\n// To understand how to use `ColumnBuilder` and `AnyColumnBuilder`, see `Column` and `AnyColumn` documentation.\nexport abstract class ColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> implements ColumnBuilderBase<T, TTypeConfig> {\n\tstatic readonly [entityKind]: string = 'ColumnBuilder';\n\n\tdeclare _: ColumnBuilderTypeConfig<T, TTypeConfig>;\n\n\tprotected config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\n\tconstructor(name: T['name'], dataType: T['dataType'], columnType: T['columnType']) {\n\t\tthis.config = {\n\t\t\tname,\n\t\t\tkeyAsName: name === '',\n\t\t\tnotNull: false,\n\t\t\tdefault: undefined,\n\t\t\thasDefault: false,\n\t\t\tprimaryKey: false,\n\t\t\tisUnique: false,\n\t\t\tuniqueName: undefined,\n\t\t\tuniqueType: undefined,\n\t\t\tdataType,\n\t\t\tcolumnType,\n\t\t\tgenerated: undefined,\n\t\t} as ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;\n\t}\n\n\t/**\n\t * Changes the data type of the column. Commonly used with `json` columns. Also, useful for branded types.\n\t *\n\t * @example\n\t * ```ts\n\t * const users = pgTable('users', {\n\t * \tid: integer('id').$type<UserId>().primaryKey(),\n\t * \tdetails: json('details').$type<UserDetails>().notNull(),\n\t * });\n\t * ```\n\t */\n\t$type<TType>(): $Type<this, TType> {\n\t\treturn this as $Type<this, TType>;\n\t}\n\n\t/**\n\t * Adds a `not null` clause to the column definition.\n\t *\n\t * Affects the `select` model of the table - columns *without* `not null` will be nullable on select.\n\t */\n\tnotNull(): NotNull<this> {\n\t\tthis.config.notNull = true;\n\t\treturn this as NotNull<this>;\n\t}\n\n\t/**\n\t * Adds a `default <value>` clause to the column definition.\n\t *\n\t * Affects the `insert` model of the table - columns *with* `default` are optional on insert.\n\t *\n\t * If you need to set a dynamic default value, use {@link $defaultFn} instead.\n\t */\n\tdefault(value: (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL): HasDefault<this> {\n\t\tthis.config.default = value;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Adds a dynamic default value to the column.\n\t * The function will be called when the row is inserted, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$defaultFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasRuntimeDefault<HasDefault<this>> {\n\t\tthis.config.defaultFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasRuntimeDefault<HasDefault<this>>;\n\t}\n\n\t/**\n\t * Alias for {@link $defaultFn}.\n\t */\n\t$default = this.$defaultFn;\n\n\t/**\n\t * Adds a dynamic update value to the column.\n\t * The function will be called when the row is updated, and the returned value will be used as the column value if none is provided.\n\t * If no `default` (or `$defaultFn`) value is provided, the function will be called when the row is inserted as well, and the returned value will be used as the column value.\n\t *\n\t * **Note:** This value does not affect the `drizzle-kit` behavior, it is only used at runtime in `drizzle-orm`.\n\t */\n\t$onUpdateFn(\n\t\tfn: () => (this['_'] extends { $type: infer U } ? U : this['_']['data']) | SQL,\n\t): HasDefault<this> {\n\t\tthis.config.onUpdateFn = fn;\n\t\tthis.config.hasDefault = true;\n\t\treturn this as HasDefault<this>;\n\t}\n\n\t/**\n\t * Alias for {@link $onUpdateFn}.\n\t */\n\t$onUpdate = this.$onUpdateFn;\n\n\t/**\n\t * Adds a `primary key` clause to the column definition. This implicitly makes the column `not null`.\n\t *\n\t * In SQLite, `integer primary key` implicitly makes the column auto-incrementing.\n\t */\n\tprimaryKey(): TExtraConfig['primaryKeyHasDefault'] extends true ? IsPrimaryKey<HasDefault<NotNull<this>>>\n\t\t: IsPrimaryKey<NotNull<this>>\n\t{\n\t\tthis.config.primaryKey = true;\n\t\tthis.config.notNull = true;\n\t\treturn this as TExtraConfig['primaryKeyHasDefault'] extends true ? IsPrimaryKey<HasDefault<NotNull<this>>>\n\t\t\t: IsPrimaryKey<NotNull<this>>;\n\t}\n\n\tabstract generatedAlwaysAs(\n\t\tas: SQL | T['data'] | (() => SQL),\n\t\tconfig?: Partial<GeneratedColumnConfig<unknown>>,\n\t): HasGenerated<this, {\n\t\ttype: 'always';\n\t}>;\n\n\t/** @internal Sets the name of the column to the key within the table definition if a name was not given. */\n\tsetName(name: string) {\n\t\tif (this.config.name !== '') return;\n\t\tthis.config.name = name;\n\t}\n}\n\nexport type BuildColumn<\n\tTTableName extends string,\n\tTBuilder extends ColumnBuilderBase,\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? PgColumn<\n\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t{},\n\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t>\n\t: TDialect extends 'mysql' ? MySqlColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<\n\t\t\t\tOmit<\n\t\t\t\t\tTBuilder['_'],\n\t\t\t\t\t| keyof MakeColumnConfig<TBuilder['_'], TTableName>\n\t\t\t\t\t| 'brand'\n\t\t\t\t\t| 'dialect'\n\t\t\t\t\t| 'primaryKeyHasDefault'\n\t\t\t\t\t| 'mysqlColumnBuilderBrand'\n\t\t\t\t>\n\t\t\t>\n\t\t>\n\t: TDialect extends 'sqlite' ? SQLiteColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t\t>\n\t: TDialect extends 'common' ? Column<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t\t>\n\t: TDialect extends 'singlestore' ? SingleStoreColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<\n\t\t\t\tOmit<\n\t\t\t\t\tTBuilder['_'],\n\t\t\t\t\t| keyof MakeColumnConfig<TBuilder['_'], TTableName>\n\t\t\t\t\t| 'brand'\n\t\t\t\t\t| 'dialect'\n\t\t\t\t\t| 'primaryKeyHasDefault'\n\t\t\t\t\t| 'singlestoreColumnBuilderBrand'\n\t\t\t\t>\n\t\t\t>\n\t\t>\n\t: TDialect extends 'gel' ? GelColumn<\n\t\t\tMakeColumnConfig<TBuilder['_'], TTableName>,\n\t\t\t{},\n\t\t\tSimplify<Omit<TBuilder['_'], keyof MakeColumnConfig<TBuilder['_'], TTableName> | 'brand' | 'dialect'>>\n\t\t>\n\t: never;\n\nexport type BuildIndexColumn<\n\tTDialect extends Dialect,\n> = TDialect extends 'pg' ? ExtraConfigColumn\n\t: TDialect extends 'gel' ? GelExtraConfigColumn\n\t: never;\n\n// TODO\n// try to make sql as well + indexRaw\n\n// optional after everything will be working as expected\n// also try to leave only needed methods for extraConfig\n// make an error if I pass .asc() to fk and so on\n\nexport type BuildColumns<\n\tTTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildColumn<TTableName, {\n\t\t\t_:\n\t\t\t\t& Omit<TConfigMap[Key]['_'], 'name'>\n\t\t\t\t& { name: TConfigMap[Key]['_']['name'] extends '' ? Assume<Key, string> : TConfigMap[Key]['_']['name'] };\n\t\t}, TDialect>;\n\t}\n\t& {};\n\nexport type BuildExtraConfigColumns<\n\t_TTableName extends string,\n\tTConfigMap extends Record<string, ColumnBuilderBase>,\n\tTDialect extends Dialect,\n> =\n\t& {\n\t\t[Key in keyof TConfigMap]: BuildIndexColumn<TDialect>;\n\t}\n\t& {};\n\nexport type ChangeColumnTableName<TColumn extends Column, TAlias extends string, TDialect extends Dialect> =\n\tTDialect extends 'pg' ? PgColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'singlestore' ? SingleStoreColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: TDialect extends 'gel' ? GelColumn<MakeColumnConfig<TColumn['_'], TAlias>>\n\t\t: never;\n","/** @internal */\nexport const TableName = Symbol.for('drizzle:Name');\n","import { entityKind } from '~/entity.ts';\nimport { TableName } from '~/table.utils.ts';\nimport type { AnyPgColumn, PgColumn } from './columns/index.ts';\nimport type { PgTable } from './table.ts';\n\nexport type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';\n\nexport type Reference = () => {\n\treadonly name?: string;\n\treadonly columns: PgColumn[];\n\treadonly foreignTable: PgTable;\n\treadonly foreignColumns: PgColumn[];\n};\n\nexport class ForeignKeyBuilder {\n\tstatic readonly [entityKind]: string = 'PgForeignKeyBuilder';\n\n\t/** @internal */\n\treference: Reference;\n\n\t/** @internal */\n\t_onUpdate: UpdateDeleteAction | undefined = 'no action';\n\n\t/** @internal */\n\t_onDelete: UpdateDeleteAction | undefined = 'no action';\n\n\tconstructor(\n\t\tconfig: () => {\n\t\t\tname?: string;\n\t\t\tcolumns: PgColumn[];\n\t\t\tforeignColumns: PgColumn[];\n\t\t},\n\t\tactions?: {\n\t\t\tonUpdate?: UpdateDeleteAction;\n\t\t\tonDelete?: UpdateDeleteAction;\n\t\t} | undefined,\n\t) {\n\t\tthis.reference = () => {\n\t\t\tconst { name, columns, foreignColumns } = config();\n\t\t\treturn { name, columns, foreignTable: foreignColumns[0]!.table as PgTable, foreignColumns };\n\t\t};\n\t\tif (actions) {\n\t\t\tthis._onUpdate = actions.onUpdate;\n\t\t\tthis._onDelete = actions.onDelete;\n\t\t}\n\t}\n\n\tonUpdate(action: UpdateDeleteAction): this {\n\t\tthis._onUpdate = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\tonDelete(action: UpdateDeleteAction): this {\n\t\tthis._onDelete = action === undefined ? 'no action' : action;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): ForeignKey {\n\t\treturn new ForeignKey(table, this);\n\t}\n}\n\nexport type AnyForeignKeyBuilder = ForeignKeyBuilder;\n\nexport class ForeignKey {\n\tstatic readonly [entityKind]: string = 'PgForeignKey';\n\n\treadonly reference: Reference;\n\treadonly onUpdate: UpdateDeleteAction | undefined;\n\treadonly onDelete: UpdateDeleteAction | undefined;\n\n\tconstructor(readonly table: PgTable, builder: ForeignKeyBuilder) {\n\t\tthis.reference = builder.reference;\n\t\tthis.onUpdate = builder._onUpdate;\n\t\tthis.onDelete = builder._onDelete;\n\t}\n\n\tgetName(): string {\n\t\tconst { name, columns, foreignColumns } = this.reference();\n\t\tconst columnNames = columns.map((column) => column.name);\n\t\tconst foreignColumnNames = foreignColumns.map((column) => column.name);\n\t\tconst chunks = [\n\t\t\tthis.table[TableName],\n\t\t\t...columnNames,\n\t\t\tforeignColumns[0]!.table[TableName],\n\t\t\t...foreignColumnNames,\n\t\t];\n\t\treturn name ?? `${chunks.join('_')}_fk`;\n\t}\n}\n\ntype ColumnsWithTable<\n\tTTableName extends string,\n\tTColumns extends PgColumn[],\n> = { [Key in keyof TColumns]: AnyPgColumn<{ tableName: TTableName }> };\n\nexport function foreignKey<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends [AnyPgColumn<{ tableName: TTableName }>, ...AnyPgColumn<{ tableName: TTableName }>[]],\n>(\n\tconfig: {\n\t\tname?: string;\n\t\tcolumns: TColumns;\n\t\tforeignColumns: ColumnsWithTable<TForeignTableName, TColumns>;\n\t},\n): ForeignKeyBuilder {\n\tfunction mappedConfig() {\n\t\tconst { name, columns, foreignColumns } = config;\n\t\treturn {\n\t\t\tname,\n\t\t\tcolumns,\n\t\t\tforeignColumns,\n\t\t};\n\t}\n\n\treturn new ForeignKeyBuilder(mappedConfig);\n}\n","export function iife<T extends unknown[], U>(fn: (...args: T) => U, ...args: T): U {\n\treturn fn(...args);\n}\n","import { entityKind } from '~/entity.ts';\nimport { TableName } from '~/table.utils.ts';\nimport type { PgColumn } from './columns/index.ts';\nimport type { PgTable } from './table.ts';\n\nexport function unique(name?: string): UniqueOnConstraintBuilder {\n\treturn new UniqueOnConstraintBuilder(name);\n}\n\nexport function uniqueKeyName(table: PgTable, columns: string[]) {\n\treturn `${table[TableName]}_${columns.join('_')}_unique`;\n}\n\nexport class UniqueConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraintBuilder';\n\n\t/** @internal */\n\tcolumns: PgColumn[];\n\t/** @internal */\n\tnullsNotDistinctConfig = false;\n\n\tconstructor(\n\t\tcolumns: PgColumn[],\n\t\tprivate name?: string,\n\t) {\n\t\tthis.columns = columns;\n\t}\n\n\tnullsNotDistinct() {\n\t\tthis.nullsNotDistinctConfig = true;\n\t\treturn this;\n\t}\n\n\t/** @internal */\n\tbuild(table: PgTable): UniqueConstraint {\n\t\treturn new UniqueConstraint(table, this.columns, this.nullsNotDistinctConfig, this.name);\n\t}\n}\n\nexport class UniqueOnConstraintBuilder {\n\tstatic readonly [entityKind]: string = 'PgUniqueOnConstraintBuilder';\n\n\t/** @internal */\n\tname?: string;\n\n\tconstructor(\n\t\tname?: string,\n\t) {\n\t\tthis.name = name;\n\t}\n\n\ton(...columns: [PgColumn, ...PgColumn[]]) {\n\t\treturn new UniqueConstraintBuilder(columns, this.name);\n\t}\n}\n\nexport class UniqueConstraint {\n\tstatic readonly [entityKind]: string = 'PgUniqueConstraint';\n\n\treadonly columns: PgColumn[];\n\treadonly name?: string;\n\treadonly nullsNotDistinct: boolean = false;\n\n\tconstructor(readonly table: PgTable, columns: PgColumn[], nullsNotDistinct: boolean, name?: string) {\n\t\tthis.columns = columns;\n\t\tthis.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));\n\t\tthis.nullsNotDistinct = nullsNotDistinct;\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n}\n","function parsePgArrayValue(arrayString: string, startFrom: number, inQuotes: boolean): [string, number] {\n\tfor (let i = startFrom; i < arrayString.length; i++) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === '\\\\') {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i + 1];\n\t\t}\n\n\t\tif (inQuotes) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === ',' || char === '}') {\n\t\t\treturn [arrayString.slice(startFrom, i).replace(/\\\\/g, ''), i];\n\t\t}\n\t}\n\n\treturn [arrayString.slice(startFrom).replace(/\\\\/g, ''), arrayString.length];\n}\n\nexport function parsePgNestedArray(arrayString: string, startFrom = 0): [any[], number] {\n\tconst result: any[] = [];\n\tlet i = startFrom;\n\tlet lastCharIsComma = false;\n\n\twhile (i < arrayString.length) {\n\t\tconst char = arrayString[i];\n\n\t\tif (char === ',') {\n\t\t\tif (lastCharIsComma || i === startFrom) {\n\t\t\t\tresult.push('');\n\t\t\t}\n\t\t\tlastCharIsComma = true;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlastCharIsComma = false;\n\n\t\tif (char === '\\\\') {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '\"') {\n\t\t\tconst [value, startFrom] = parsePgArrayValue(arrayString, i + 1, true);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (char === '}') {\n\t\t\treturn [result, i + 1];\n\t\t}\n\n\t\tif (char === '{') {\n\t\t\tconst [value, startFrom] = parsePgNestedArray(arrayString, i + 1);\n\t\t\tresult.push(value);\n\t\t\ti = startFrom;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst [value, newStartFrom] = parsePgArrayValue(arrayString, i, false);\n\t\tresult.push(value);\n\t\ti = newStartFrom;\n\t}\n\n\treturn [result, i];\n}\n\nexport function parsePgArray(arrayString: string): any[] {\n\tconst [result] = parsePgNestedArray(arrayString, 1);\n\treturn result;\n}\n\nexport function makePgArray(array: any[]): string {\n\treturn `{${\n\t\tarray.map((item) => {\n\t\t\tif (Array.isArray(item)) {\n\t\t\t\treturn makePgArray(item);\n\t\t\t}\n\n\t\t\tif (typeof item === 'string') {\n\t\t\t\treturn `\"${item.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"')}\"`;\n\t\t\t}\n\n\t\t\treturn `${item}`;\n\t\t}).join(',')\n\t}}`;\n}\n","import type {\n\tColumnBuilderBase,\n\tColumnBuilderBaseConfig,\n\tColumnBuilderExtraConfig,\n\tColumnBuilderRuntimeConfig,\n\tColumnDataType,\n\tHasGenerated,\n\tMakeColumnConfig,\n} from '~/column-builder.ts';\nimport { ColumnBuilder } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { Column } from '~/column.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport type { Simplify, Update } from '~/utils.ts';\n\nimport type { ForeignKey, UpdateDeleteAction } from '~/pg-core/foreign-keys.ts';\nimport { ForeignKeyBuilder } from '~/pg-core/foreign-keys.ts';\nimport type { AnyPgTable, PgTable } from '~/pg-core/table.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport { iife } from '~/tracing-utils.ts';\nimport type { PgIndexOpClass } from '../indexes.ts';\nimport { uniqueKeyName } from '../unique-constraint.ts';\nimport { makePgArray, parsePgArray } from '../utils/array.ts';\n\nexport interface ReferenceConfig {\n\tref: () => PgColumn;\n\tactions: {\n\t\tonUpdate?: UpdateDeleteAction;\n\t\tonDelete?: UpdateDeleteAction;\n\t};\n}\n\nexport interface PgColumnBuilderBase<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTTypeConfig extends object = object,\n> extends ColumnBuilderBase<T, TTypeConfig & { dialect: 'pg' }> {}\n\nexport abstract class PgColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n\tTTypeConfig extends object = object,\n\tTExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig,\n> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }, TExtraConfig>\n\timplements PgColumnBuilderBase<T, TTypeConfig>\n{\n\tprivate foreignKeyConfigs: ReferenceConfig[] = [];\n\n\tstatic override readonly [entityKind]: string = 'PgColumnBuilder';\n\n\tarray<TSize extends number | undefined = undefined>(size?: TSize): PgArrayBuilder<\n\t\t& {\n\t\t\tname: T['name'];\n\t\t\tdataType: 'array';\n\t\t\tcolumnType: 'PgArray';\n\t\t\tdata: T['data'][];\n\t\t\tdriverParam: T['driverParam'][] | string;\n\t\t\tenumValues: T['enumValues'];\n\t\t\tsize: TSize;\n\t\t\tbaseBuilder: T;\n\t\t}\n\t\t& (T extends { notNull: true } ? { notNull: true } : {})\n\t\t& (T extends { hasDefault: true } ? { hasDefault: true } : {}),\n\t\tT\n\t> {\n\t\treturn new PgArrayBuilder(this.config.name, this as PgColumnBuilder<any, any>, size as any);\n\t}\n\n\treferences(\n\t\tref: ReferenceConfig['ref'],\n\t\tactions: ReferenceConfig['actions'] = {},\n\t): this {\n\t\tthis.foreignKeyConfigs.push({ ref, actions });\n\t\treturn this;\n\t}\n\n\tunique(\n\t\tname?: string,\n\t\tconfig?: { nulls: 'distinct' | 'not distinct' },\n\t): this {\n\t\tthis.config.isUnique = true;\n\t\tthis.config.uniqueName = name;\n\t\tthis.config.uniqueType = config?.nulls;\n\t\treturn this;\n\t}\n\n\tgeneratedAlwaysAs(as: SQL | T['data'] | (() => SQL)): HasGenerated<this, {\n\t\ttype: 'always';\n\t}> {\n\t\tthis.config.generated = {\n\t\t\tas,\n\t\t\ttype: 'always',\n\t\t\tmode: 'stored',\n\t\t};\n\t\treturn this as HasGenerated<this, {\n\t\t\ttype: 'always';\n\t\t}>;\n\t}\n\n\t/** @internal */\n\tbuildForeignKeys(column: PgColumn, table: PgTable): ForeignKey[] {\n\t\treturn this.foreignKeyConfigs.map(({ ref, actions }) => {\n\t\t\treturn iife(\n\t\t\t\t(ref, actions) => {\n\t\t\t\t\tconst builder = new ForeignKeyBuilder(() => {\n\t\t\t\t\t\tconst foreignColumn = ref();\n\t\t\t\t\t\treturn { columns: [column], foreignColumns: [foreignColumn] };\n\t\t\t\t\t});\n\t\t\t\t\tif (actions.onUpdate) {\n\t\t\t\t\t\tbuilder.onUpdate(actions.onUpdate);\n\t\t\t\t\t}\n\t\t\t\t\tif (actions.onDelete) {\n\t\t\t\t\t\tbuilder.onDelete(actions.onDelete);\n\t\t\t\t\t}\n\t\t\t\t\treturn builder.build(table);\n\t\t\t\t},\n\t\t\t\tref,\n\t\t\t\tactions,\n\t\t\t);\n\t\t});\n\t}\n\n\t/** @internal */\n\tabstract build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgColumn<MakeColumnConfig<T, TTableName>>;\n\n\t/** @internal */\n\tbuildExtraConfigColumn<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): ExtraConfigColumn {\n\t\treturn new ExtraConfigColumn(table, this.config);\n\t}\n}\n\n// To understand how to use `PgColumn` and `PgColumn`, see `Column` and `AnyColumn` documentation.\nexport abstract class PgColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = {},\n\tTTypeConfig extends object = {},\n> extends Column<T, TRuntimeConfig, TTypeConfig & { dialect: 'pg' }> {\n\tstatic override readonly [entityKind]: string = 'PgColumn';\n\n\tconstructor(\n\t\toverride readonly table: PgTable,\n\t\tconfig: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>,\n\t) {\n\t\tif (!config.uniqueName) {\n\t\t\tconfig.uniqueName = uniqueKeyName(table, [config.name]);\n\t\t}\n\t\tsuper(table, config);\n\t}\n}\n\nexport type IndexedExtraConfigType = { order?: 'asc' | 'desc'; nulls?: 'first' | 'last'; opClass?: string };\n\nexport class ExtraConfigColumn<\n\tT extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T, IndexedExtraConfigType> {\n\tstatic override readonly [entityKind]: string = 'ExtraConfigColumn';\n\n\toverride getSQLType(): string {\n\t\treturn this.getSQLType();\n\t}\n\n\tindexConfig: IndexedExtraConfigType = {\n\t\torder: this.config.order ?? 'asc',\n\t\tnulls: this.config.nulls ?? 'last',\n\t\topClass: this.config.opClass,\n\t};\n\tdefaultConfig: IndexedExtraConfigType = {\n\t\torder: 'asc',\n\t\tnulls: 'last',\n\t\topClass: undefined,\n\t};\n\n\tasc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'asc';\n\t\treturn this;\n\t}\n\n\tdesc(): Omit<this, 'asc' | 'desc'> {\n\t\tthis.indexConfig.order = 'desc';\n\t\treturn this;\n\t}\n\n\tnullsFirst(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'first';\n\t\treturn this;\n\t}\n\n\tnullsLast(): Omit<this, 'nullsFirst' | 'nullsLast'> {\n\t\tthis.indexConfig.nulls = 'last';\n\t\treturn this;\n\t}\n\n\t/**\n\t * ### PostgreSQL documentation quote\n\t *\n\t * > An operator class with optional parameters can be specified for each column of an index.\n\t * The operator class identifies the operators to be used by the index for that column.\n\t * For example, a B-tree index on four-byte integers would use the int4_ops class;\n\t * this operator class includes comparison functions for four-byte integers.\n\t * In practice the default operator class for the column's data type is usually sufficient.\n\t * The main point of having operator classes is that for some data types, there could be more than one meaningful ordering.\n\t * For example, we might want to sort a complex-number data type either by absolute value or by real part.\n\t * We could do this by defining two operator classes for the data type and then selecting the proper class when creating an index.\n\t * More information about operator classes check:\n\t *\n\t * ### Useful links\n\t * https://www.postgresql.org/docs/current/sql-createindex.html\n\t *\n\t * https://www.postgresql.org/docs/current/indexes-opclass.html\n\t *\n\t * https://www.postgresql.org/docs/current/xindex.html\n\t *\n\t * ### Additional types\n\t * If you have the `pg_vector` extension installed in your database, you can use the\n\t * `vector_l2_ops`, `vector_ip_ops`, `vector_cosine_ops`, `vector_l1_ops`, `bit_hamming_ops`, `bit_jaccard_ops`, `halfvec_l2_ops`, `sparsevec_l2_ops` options, which are predefined types.\n\t *\n\t * **You can always specify any string you want in the operator class, in case Drizzle doesn't have it natively in its types**\n\t *\n\t * @param opClass\n\t * @returns\n\t */\n\top(opClass: PgIndexOpClass): Omit<this, 'op'> {\n\t\tthis.indexConfig.opClass = opClass;\n\t\treturn this;\n\t}\n}\n\nexport class IndexedColumn {\n\tstatic readonly [entityKind]: string = 'IndexedColumn';\n\tconstructor(\n\t\tname: string | undefined,\n\t\tkeyAsName: boolean,\n\t\ttype: string,\n\t\tindexConfig: IndexedExtraConfigType,\n\t) {\n\t\tthis.name = name;\n\t\tthis.keyAsName = keyAsName;\n\t\tthis.type = type;\n\t\tthis.indexConfig = indexConfig;\n\t}\n\n\tname: string | undefined;\n\tkeyAsName: boolean;\n\ttype: string;\n\tindexConfig: IndexedExtraConfigType;\n}\n\nexport type AnyPgColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = PgColumn<\n\tRequired<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>\n>;\n\nexport type PgArrayColumnBuilderBaseConfig = ColumnBuilderBaseConfig<'array', 'PgArray'> & {\n\tsize: number | undefined;\n\tbaseBuilder: ColumnBuilderBaseConfig<ColumnDataType, string>;\n};\n\nexport class PgArrayBuilder<\n\tT extends PgArrayColumnBuilderBaseConfig,\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string> | PgArrayColumnBuilderBaseConfig,\n> extends PgColumnBuilder<\n\tT,\n\t{\n\t\tbaseBuilder: TBase extends PgArrayColumnBuilderBaseConfig ? PgArrayBuilder<\n\t\t\t\tTBase,\n\t\t\t\tTBase extends { baseBuilder: infer TBaseBuilder extends ColumnBuilderBaseConfig<any, any> } ? TBaseBuilder\n\t\t\t\t\t: never\n\t\t\t>\n\t\t\t: PgColumnBuilder<TBase, {}, Simplify<Omit<TBase, keyof ColumnBuilderBaseConfig<any, any>>>>;\n\t\tsize: T['size'];\n\t},\n\t{\n\t\tbaseBuilder: TBase extends PgArrayColumnBuilderBaseConfig ? PgArrayBuilder<\n\t\t\t\tTBase,\n\t\t\t\tTBase extends { baseBuilder: infer TBaseBuilder extends ColumnBuilderBaseConfig<any, any> } ? TBaseBuilder\n\t\t\t\t\t: never\n\t\t\t>\n\t\t\t: PgColumnBuilder<TBase, {}, Simplify<Omit<TBase, keyof ColumnBuilderBaseConfig<any, any>>>>;\n\t\tsize: T['size'];\n\t}\n> {\n\tstatic override readonly [entityKind] = 'PgArrayBuilder';\n\n\tconstructor(\n\t\tname: string,\n\t\tbaseBuilder: PgArrayBuilder<T, TBase>['config']['baseBuilder'],\n\t\tsize: T['size'],\n\t) {\n\t\tsuper(name, 'array', 'PgArray');\n\t\tthis.config.baseBuilder = baseBuilder;\n\t\tthis.config.size = size;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgArray<MakeColumnConfig<T, TTableName> & { size: T['size']; baseBuilder: T['baseBuilder'] }, TBase> {\n\t\tconst baseColumn = this.config.baseBuilder.build(table);\n\t\treturn new PgArray<MakeColumnConfig<T, TTableName> & { size: T['size']; baseBuilder: T['baseBuilder'] }, TBase>(\n\t\t\ttable as AnyPgTable<{ name: MakeColumnConfig<T, TTableName>['tableName'] }>,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t\tbaseColumn,\n\t\t);\n\t}\n}\n\nexport class PgArray<\n\tT extends ColumnBaseConfig<'array', 'PgArray'> & {\n\t\tsize: number | undefined;\n\t\tbaseBuilder: ColumnBuilderBaseConfig<ColumnDataType, string>;\n\t},\n\tTBase extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumn<T, {}, { size: T['size']; baseBuilder: T['baseBuilder'] }> {\n\treadonly size: T['size'];\n\n\tstatic override readonly [entityKind]: string = 'PgArray';\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgArrayBuilder<T, TBase>['config'],\n\t\treadonly baseColumn: PgColumn,\n\t\treadonly range?: [number | undefined, number | undefined],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.size = config.size;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn `${this.baseColumn.getSQLType()}[${typeof this.size === 'number' ? this.size : ''}]`;\n\t}\n\n\toverride mapFromDriverValue(value: unknown[] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\t// Thank you node-postgres for not parsing enum arrays\n\t\t\tvalue = parsePgArray(value);\n\t\t}\n\t\treturn value.map((v) => this.baseColumn.mapFromDriverValue(v));\n\t}\n\n\toverride mapToDriverValue(value: unknown[], isNestedArray = false): unknown[] | string {\n\t\tconst a = value.map((v) =>\n\t\t\tv === null\n\t\t\t\t? null\n\t\t\t\t: is(this.baseColumn, PgArray)\n\t\t\t\t? this.baseColumn.mapToDriverValue(v as unknown[], true)\n\t\t\t\t: this.baseColumn.mapToDriverValue(v)\n\t\t);\n\t\tif (isNestedArray) return a;\n\t\treturn makePgArray(a);\n\t}\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { NonArray, Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\n// Enum as ts enum\n\nexport type PgEnumObjectColumnBuilderInitial<TName extends string, TValues extends object> = PgEnumObjectColumnBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgEnumObjectColumn';\n\tdata: TValues[keyof TValues];\n\tenumValues: string[];\n\tdriverParam: string;\n}>;\n\nexport interface PgEnumObject<TValues extends object> {\n\t(): PgEnumObjectColumnBuilderInitial<'', TValues>;\n\t<TName extends string>(name: TName): PgEnumObjectColumnBuilderInitial<TName, TValues>;\n\t<TName extends string>(name?: TName): PgEnumObjectColumnBuilderInitial<TName, TValues>;\n\n\treadonly enumName: string;\n\treadonly enumValues: string[];\n\treadonly schema: string | undefined;\n\t/** @internal */\n\t[isPgEnumSym]: true;\n}\n\nexport class PgEnumObjectColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgEnumObjectColumn'> & { enumValues: string[] },\n> extends PgColumnBuilder<T, { enum: PgEnumObject<any> }> {\n\tstatic override readonly [entityKind]: string = 'PgEnumObjectColumnBuilder';\n\n\tconstructor(name: T['name'], enumInstance: PgEnumObject<any>) {\n\t\tsuper(name, 'string', 'PgEnumObjectColumn');\n\t\tthis.config.enum = enumInstance;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgEnumObjectColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgEnumObjectColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgEnumObjectColumn<T extends ColumnBaseConfig<'string', 'PgEnumObjectColumn'> & { enumValues: object }>\n\textends PgColumn<T, { enum: PgEnumObject<object> }>\n{\n\tstatic override readonly [entityKind]: string = 'PgEnumObjectColumn';\n\n\treadonly enum;\n\toverride readonly enumValues = this.config.enum.enumValues;\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgEnumObjectColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.enum = config.enum;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.enum.enumName;\n\t}\n}\n\n// Enum as string union\n\nexport type PgEnumColumnBuilderInitial<TName extends string, TValues extends [string, ...string[]]> =\n\tPgEnumColumnBuilder<{\n\t\tname: TName;\n\t\tdataType: 'string';\n\t\tcolumnType: 'PgEnumColumn';\n\t\tdata: TValues[number];\n\t\tenumValues: TValues;\n\t\tdriverParam: string;\n\t}>;\n\nconst isPgEnumSym = Symbol.for('drizzle:isPgEnum');\nexport interface PgEnum<TValues extends [string, ...string[]]> {\n\t(): PgEnumColumnBuilderInitial<'', TValues>;\n\t<TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, TValues>;\n\t<TName extends string>(name?: TName): PgEnumColumnBuilderInitial<TName, TValues>;\n\n\treadonly enumName: string;\n\treadonly enumValues: TValues;\n\treadonly schema: string | undefined;\n\t/** @internal */\n\t[isPgEnumSym]: true;\n}\n\nexport function isPgEnum(obj: unknown): obj is PgEnum<[string, ...string[]]> {\n\treturn !!obj && typeof obj === 'function' && isPgEnumSym in obj && obj[isPgEnumSym] === true;\n}\n\nexport class PgEnumColumnBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] },\n> extends PgColumnBuilder<T, { enum: PgEnum<T['enumValues']> }> {\n\tstatic override readonly [entityKind]: string = 'PgEnumColumnBuilder';\n\n\tconstructor(name: T['name'], enumInstance: PgEnum<T['enumValues']>) {\n\t\tsuper(name, 'string', 'PgEnumColumn');\n\t\tthis.config.enum = enumInstance;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgEnumColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgEnumColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgEnumColumn<T extends ColumnBaseConfig<'string', 'PgEnumColumn'> & { enumValues: [string, ...string[]] }>\n\textends PgColumn<T, { enum: PgEnum<T['enumValues']> }>\n{\n\tstatic override readonly [entityKind]: string = 'PgEnumColumn';\n\n\treadonly enum = this.config.enum;\n\toverride readonly enumValues = this.config.enum.enumValues;\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgEnumColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.enum = config.enum;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.enum.enumName;\n\t}\n}\n\nexport function pgEnum<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n): PgEnum<Writable<T>>;\n\nexport function pgEnum<E extends Record<string, string>>(\n\tenumName: string,\n\tenumObj: NonArray<E>,\n): PgEnumObject<E>;\n\nexport function pgEnum(\n\tenumName: any,\n\tinput: any,\n): any {\n\treturn Array.isArray(input)\n\t\t? pgEnumWithSchema(enumName, [...input] as [string, ...string[]], undefined)\n\t\t: pgEnumObjectWithSchema(enumName, input, undefined);\n}\n\n/** @internal */\nexport function pgEnumWithSchema<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tenumName: string,\n\tvalues: T | Writable<T>,\n\tschema?: string,\n): PgEnum<Writable<T>> {\n\tconst enumInstance: PgEnum<Writable<T>> = Object.assign(\n\t\t<TName extends string>(name?: TName): PgEnumColumnBuilderInitial<TName, Writable<T>> =>\n\t\t\tnew PgEnumColumnBuilder(name ?? '' as TName, enumInstance),\n\t\t{\n\t\t\tenumName,\n\t\t\tenumValues: values,\n\t\t\tschema,\n\t\t\t[isPgEnumSym]: true,\n\t\t} as const,\n\t);\n\n\treturn enumInstance;\n}\n\n/** @internal */\nexport function pgEnumObjectWithSchema<T extends object>(\n\tenumName: string,\n\tvalues: T,\n\tschema?: string,\n): PgEnumObject<T> {\n\tconst enumInstance: PgEnumObject<T> = Object.assign(\n\t\t<TName extends string>(name?: TName): PgEnumObjectColumnBuilderInitial<TName, T> =>\n\t\t\tnew PgEnumObjectColumnBuilder(name ?? '' as TName, enumInstance),\n\t\t{\n\t\t\tenumName,\n\t\t\tenumValues: Object.values(values),\n\t\t\tschema,\n\t\t\t[isPgEnumSym]: true,\n\t\t} as const,\n\t);\n\n\treturn enumInstance;\n}\n","import { entityKind } from './entity.ts';\nimport type { SQL, SQLWrapper } from './sql/sql.ts';\n\nexport interface Subquery<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTAlias extends string = string,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\nexport class Subquery<\n\tTAlias extends string = string,\n\tTSelectedFields extends Record<string, unknown> = Record<string, unknown>,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Subquery';\n\n\tdeclare _: {\n\t\tbrand: 'Subquery';\n\t\tsql: SQL;\n\t\tselectedFields: TSelectedFields;\n\t\talias: TAlias;\n\t\tisWith: boolean;\n\t};\n\n\tconstructor(sql: SQL, selection: Record<string, unknown>, alias: string, isWith = false) {\n\t\tthis._ = {\n\t\t\tbrand: 'Subquery',\n\t\t\tsql,\n\t\t\tselectedFields: selection as TSelectedFields,\n\t\t\talias: alias as TAlias,\n\t\t\tisWith,\n\t\t};\n\t}\n\n\t// getSQL(): SQL<unknown> {\n\t// \treturn new SQL([this]);\n\t// }\n}\n\nexport class WithSubquery<\n\tTAlias extends string = string,\n\tTSelection extends Record<string, unknown> = Record<string, unknown>,\n> extends Subquery<TAlias, TSelection> {\n\tstatic override readonly [entityKind]: string = 'WithSubquery';\n}\n\nexport type WithSubqueryWithoutSelection<TAlias extends string> = WithSubquery<TAlias, {}>;\n","// package.json\nvar version = \"0.43.1\";\n\n// src/version.ts\nvar compatibilityVersion = 10;\nexport {\n  compatibilityVersion,\n  version as npmVersion\n};\n","import type { Span, Tracer } from '@opentelemetry/api';\nimport { iife } from '~/tracing-utils.ts';\nimport { npmVersion } from '~/version.ts';\n\nlet otel: typeof import('@opentelemetry/api') | undefined;\nlet rawTracer: Tracer | undefined;\n// try {\n// \totel = await import('@opentelemetry/api');\n// } catch (err: any) {\n// \tif (err.code !== 'MODULE_NOT_FOUND' && err.code !== 'ERR_MODULE_NOT_FOUND') {\n// \t\tthrow err;\n// \t}\n// }\n\ntype SpanName =\n\t| 'drizzle.operation'\n\t| 'drizzle.prepareQuery'\n\t| 'drizzle.buildSQL'\n\t| 'drizzle.execute'\n\t| 'drizzle.driver.execute'\n\t| 'drizzle.mapResponse';\n\n/** @internal */\nexport const tracer = {\n\tstartActiveSpan<F extends (span?: Span) => unknown>(name: SpanName, fn: F): ReturnType<F> {\n\t\tif (!otel) {\n\t\t\treturn fn() as ReturnType<F>;\n\t\t}\n\n\t\tif (!rawTracer) {\n\t\t\trawTracer = otel.trace.getTracer('drizzle-orm', npmVersion);\n\t\t}\n\n\t\treturn iife(\n\t\t\t(otel, rawTracer) =>\n\t\t\t\trawTracer.startActiveSpan(\n\t\t\t\t\tname,\n\t\t\t\t\t((span: Span) => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn fn(span);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tspan.setStatus({\n\t\t\t\t\t\t\t\tcode: otel.SpanStatusCode.ERROR,\n\t\t\t\t\t\t\t\tmessage: e instanceof Error ? e.message : 'Unknown error', // eslint-disable-line no-instanceof/no-instanceof\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tspan.end();\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as F,\n\t\t\t\t),\n\t\t\totel,\n\t\t\trawTracer,\n\t\t);\n\t},\n};\n","export const ViewBaseConfig = Symbol.for('drizzle:ViewBaseConfig');\n","import type { Column, GetColumnData } from './column.ts';\nimport { entityKind } from './entity.ts';\nimport type { OptionalKeyOnly, RequiredKeyOnly } from './operations.ts';\nimport type { SQLWrapper } from './sql/sql.ts';\nimport { TableName } from './table.utils.ts';\nimport type { Simplify, Update } from './utils.ts';\n\nexport interface TableConfig<TColumn extends Column = Column<any>> {\n\tname: string;\n\tschema: string | undefined;\n\tcolumns: Record<string, TColumn>;\n\tdialect: string;\n}\n\nexport type UpdateTableConfig<T extends TableConfig, TUpdate extends Partial<TableConfig>> = Required<\n\tUpdate<T, TUpdate>\n>;\n\n/** @internal */\nexport const Schema = Symbol.for('drizzle:Schema');\n\n/** @internal */\nexport const Columns = Symbol.for('drizzle:Columns');\n\n/** @internal */\nexport const ExtraConfigColumns = Symbol.for('drizzle:ExtraConfigColumns');\n\n/** @internal */\nexport const OriginalName = Symbol.for('drizzle:OriginalName');\n\n/** @internal */\nexport const BaseName = Symbol.for('drizzle:BaseName');\n\n/** @internal */\nexport const IsAlias = Symbol.for('drizzle:IsAlias');\n\n/** @internal */\nexport const ExtraConfigBuilder = Symbol.for('drizzle:ExtraConfigBuilder');\n\nconst IsDrizzleTable = Symbol.for('drizzle:IsDrizzleTable');\n\nexport interface Table<\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tT extends TableConfig = TableConfig,\n> extends SQLWrapper {\n\t// SQLWrapper runtime implementation is defined in 'sql/sql.ts'\n}\n\nexport class Table<T extends TableConfig = TableConfig> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Table';\n\n\tdeclare readonly _: {\n\t\treadonly brand: 'Table';\n\t\treadonly config: T;\n\t\treadonly name: T['name'];\n\t\treadonly schema: T['schema'];\n\t\treadonly columns: T['columns'];\n\t\treadonly inferSelect: InferSelectModel<Table<T>>;\n\t\treadonly inferInsert: InferInsertModel<Table<T>>;\n\t};\n\n\tdeclare readonly $inferSelect: InferSelectModel<Table<T>>;\n\tdeclare readonly $inferInsert: InferInsertModel<Table<T>>;\n\n\t/** @internal */\n\tstatic readonly Symbol = {\n\t\tName: TableName as typeof TableName,\n\t\tSchema: Schema as typeof Schema,\n\t\tOriginalName: OriginalName as typeof OriginalName,\n\t\tColumns: Columns as typeof Columns,\n\t\tExtraConfigColumns: ExtraConfigColumns as typeof ExtraConfigColumns,\n\t\tBaseName: BaseName as typeof BaseName,\n\t\tIsAlias: IsAlias as typeof IsAlias,\n\t\tExtraConfigBuilder: ExtraConfigBuilder as typeof ExtraConfigBuilder,\n\t};\n\n\t/**\n\t * @internal\n\t * Can be changed if the table is aliased.\n\t */\n\t[TableName]: string;\n\n\t/**\n\t * @internal\n\t * Used to store the original name of the table, before any aliasing.\n\t */\n\t[OriginalName]: string;\n\n\t/** @internal */\n\t[Schema]: string | undefined;\n\n\t/** @internal */\n\t[Columns]!: T['columns'];\n\n\t/** @internal */\n\t[ExtraConfigColumns]!: Record<string, unknown>;\n\n\t/**\n\t *  @internal\n\t * Used to store the table name before the transformation via the `tableCreator` functions.\n\t */\n\t[BaseName]: string;\n\n\t/** @internal */\n\t[IsAlias] = false;\n\n\t/** @internal */\n\t[IsDrizzleTable] = true;\n\n\t/** @internal */\n\t[ExtraConfigBuilder]: ((self: any) => Record<string, unknown> | unknown[]) | undefined = undefined;\n\n\tconstructor(name: string, schema: string | undefined, baseName: string) {\n\t\tthis[TableName] = this[OriginalName] = name;\n\t\tthis[Schema] = schema;\n\t\tthis[BaseName] = baseName;\n\t}\n}\n\nexport function isTable(table: unknown): table is Table {\n\treturn typeof table === 'object' && table !== null && IsDrizzleTable in table;\n}\n\n/**\n * Any table with a specified boundary.\n *\n * @example\n\t```ts\n\t// Any table with a specific name\n\ttype AnyUsersTable = AnyTable<{ name: 'users' }>;\n\t```\n *\n * To describe any table with any config, simply use `Table` without any type arguments, like this:\n *\n\t```ts\n\tfunction needsTable(table: Table) {\n\t\t...\n\t}\n\t```\n */\nexport type AnyTable<TPartial extends Partial<TableConfig>> = Table<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport function getTableName<T extends Table>(table: T): T['_']['name'] {\n\treturn table[TableName];\n}\n\nexport function getTableUniqueName<T extends Table>(table: T): `${T['_']['schema']}.${T['_']['name']}` {\n\treturn `${table[Schema] ?? 'public'}.${table[TableName]}`;\n}\n\nexport type MapColumnName<TName extends string, TColumn extends Column, TDBColumNames extends boolean> =\n\tTDBColumNames extends true ? TColumn['_']['name']\n\t\t: TName;\n\nexport type InferModelFromColumns<\n\tTColumns extends Record<string, Column>,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean; override?: boolean } = { dbColumnNames: false; override: false },\n> = Simplify<\n\tTInferMode extends 'insert' ?\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as RequiredKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key]\n\t\t\t\t\t>\n\t\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t\t}\n\t\t\t& {\n\t\t\t\t[\n\t\t\t\t\tKey in keyof TColumns & string as OptionalKeyOnly<\n\t\t\t\t\t\tMapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>,\n\t\t\t\t\t\tTColumns[Key],\n\t\t\t\t\t\tTConfig['override']\n\t\t\t\t\t>\n\t\t\t\t]?: GetColumnData<TColumns[Key], 'query'> | undefined;\n\t\t\t}\n\t\t: {\n\t\t\t[\n\t\t\t\tKey in keyof TColumns & string as MapColumnName<\n\t\t\t\t\tKey,\n\t\t\t\t\tTColumns[Key],\n\t\t\t\t\tTConfig['dbColumnNames']\n\t\t\t\t>\n\t\t\t]: GetColumnData<TColumns[Key], 'query'>;\n\t\t}\n>;\n\n/** @deprecated Use one of the alternatives: {@link InferSelectModel} / {@link InferInsertModel}, or `table.$inferSelect` / `table.$inferInsert`\n */\nexport type InferModel<\n\tTTable extends Table,\n\tTInferMode extends 'select' | 'insert' = 'select',\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], TInferMode, TConfig>;\n\nexport type InferSelectModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean } = { dbColumnNames: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'select', TConfig>;\n\nexport type InferInsertModel<\n\tTTable extends Table,\n\tTConfig extends { dbColumnNames: boolean; override?: boolean } = { dbColumnNames: false; override: false },\n> = InferModelFromColumns<TTable['_']['columns'], 'insert', TConfig>;\n\nexport type InferEnum<T> = T extends { enumValues: readonly (infer U)[] } ? U\n\t: never;\n","import type { CasingCache } from '~/casing.ts';\nimport { entityKind, is } from '~/entity.ts';\nimport { isPgEnum } from '~/pg-core/columns/enum.ts';\nimport type { SelectResult } from '~/query-builders/select.types.ts';\nimport { Subquery } from '~/subquery.ts';\nimport { tracer } from '~/tracing.ts';\nimport type { Assume, Equal } from '~/utils.ts';\nimport { ViewBaseConfig } from '~/view-common.ts';\nimport type { AnyColumn } from '../column.ts';\nimport { Column } from '../column.ts';\nimport { IsAlias, Table } from '../table.ts';\n\n/**\n * This class is used to indicate a primitive param value that is used in `sql` tag.\n * It is only used on type level and is never instantiated at runtime.\n * If you see a value of this type in the code, its runtime value is actually the primitive param value.\n */\nexport class FakePrimitiveParam {\n\tstatic readonly [entityKind]: string = 'FakePrimitiveParam';\n}\n\nexport type Chunk =\n\t| string\n\t| Table\n\t| View\n\t| AnyColumn\n\t| Name\n\t| Param\n\t| Placeholder\n\t| SQL;\n\nexport interface BuildQueryConfig {\n\tcasing: CasingCache;\n\tescapeName(name: string): string;\n\tescapeParam(num: number, value: unknown): string;\n\tescapeString(str: string): string;\n\tprepareTyping?: (encoder: DriverValueEncoder<unknown, unknown>) => QueryTypingsValue;\n\tparamStartIndex?: { value: number };\n\tinlineParams?: boolean;\n\tinvokeSource?: 'indexes' | undefined;\n}\n\nexport type QueryTypingsValue = 'json' | 'decimal' | 'time' | 'timestamp' | 'uuid' | 'date' | 'none';\n\nexport interface Query {\n\tsql: string;\n\tparams: unknown[];\n}\n\nexport interface QueryWithTypings extends Query {\n\ttypings?: QueryTypingsValue[];\n}\n\n/**\n * Any value that implements the `getSQL` method. The implementations include:\n * - `Table`\n * - `Column`\n * - `View`\n * - `Subquery`\n * - `SQL`\n * - `SQL.Aliased`\n * - `Placeholder`\n * - `Param`\n */\nexport interface SQLWrapper {\n\tgetSQL(): SQL;\n\tshouldOmitSQLParens?(): boolean;\n}\n\nexport function isSQLWrapper(value: unknown): value is SQLWrapper {\n\treturn value !== null && value !== undefined && typeof (value as any).getSQL === 'function';\n}\n\nfunction mergeQueries(queries: QueryWithTypings[]): QueryWithTypings {\n\tconst result: QueryWithTypings = { sql: '', params: [] };\n\tfor (const query of queries) {\n\t\tresult.sql += query.sql;\n\t\tresult.params.push(...query.params);\n\t\tif (query.typings?.length) {\n\t\t\tif (!result.typings) {\n\t\t\t\tresult.typings = [];\n\t\t\t}\n\t\t\tresult.typings.push(...query.typings);\n\t\t}\n\t}\n\treturn result;\n}\n\nexport class StringChunk implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'StringChunk';\n\n\treadonly value: string[];\n\n\tconstructor(value: string | string[]) {\n\t\tthis.value = Array.isArray(value) ? value : [value];\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport class SQL<T = unknown> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'SQL';\n\n\tdeclare _: {\n\t\tbrand: 'SQL';\n\t\ttype: T;\n\t};\n\n\t/** @internal */\n\tdecoder: DriverValueDecoder<T, any> = noopDecoder;\n\tprivate shouldInlineParams = false;\n\n\tconstructor(readonly queryChunks: SQLChunk[]) {}\n\n\tappend(query: SQL): this {\n\t\tthis.queryChunks.push(...query.queryChunks);\n\t\treturn this;\n\t}\n\n\ttoQuery(config: BuildQueryConfig): QueryWithTypings {\n\t\treturn tracer.startActiveSpan('drizzle.buildSQL', (span) => {\n\t\t\tconst query = this.buildQueryFromSourceParams(this.queryChunks, config);\n\t\t\tspan?.setAttributes({\n\t\t\t\t'drizzle.query.text': query.sql,\n\t\t\t\t'drizzle.query.params': JSON.stringify(query.params),\n\t\t\t});\n\t\t\treturn query;\n\t\t});\n\t}\n\n\tbuildQueryFromSourceParams(chunks: SQLChunk[], _config: BuildQueryConfig): Query {\n\t\tconst config = Object.assign({}, _config, {\n\t\t\tinlineParams: _config.inlineParams || this.shouldInlineParams,\n\t\t\tparamStartIndex: _config.paramStartIndex || { value: 0 },\n\t\t});\n\n\t\tconst {\n\t\t\tcasing,\n\t\t\tescapeName,\n\t\t\tescapeParam,\n\t\t\tprepareTyping,\n\t\t\tinlineParams,\n\t\t\tparamStartIndex,\n\t\t} = config;\n\n\t\treturn mergeQueries(chunks.map((chunk): QueryWithTypings => {\n\t\t\tif (is(chunk, StringChunk)) {\n\t\t\t\treturn { sql: chunk.value.join(''), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Name)) {\n\t\t\t\treturn { sql: escapeName(chunk.value), params: [] };\n\t\t\t}\n\n\t\t\tif (chunk === undefined) {\n\t\t\t\treturn { sql: '', params: [] };\n\t\t\t}\n\n\t\t\tif (Array.isArray(chunk)) {\n\t\t\t\tconst result: SQLChunk[] = [new StringChunk('(')];\n\t\t\t\tfor (const [i, p] of chunk.entries()) {\n\t\t\t\t\tresult.push(p);\n\t\t\t\t\tif (i < chunk.length - 1) {\n\t\t\t\t\t\tresult.push(new StringChunk(', '));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult.push(new StringChunk(')'));\n\t\t\t\treturn this.buildQueryFromSourceParams(result, config);\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL)) {\n\t\t\t\treturn this.buildQueryFromSourceParams(chunk.queryChunks, {\n\t\t\t\t\t...config,\n\t\t\t\t\tinlineParams: inlineParams || chunk.shouldInlineParams,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (is(chunk, Table)) {\n\t\t\t\tconst schemaName = chunk[Table.Symbol.Schema];\n\t\t\t\tconst tableName = chunk[Table.Symbol.Name];\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined || chunk[IsAlias]\n\t\t\t\t\t\t? escapeName(tableName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(tableName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Column)) {\n\t\t\t\tconst columnName = casing.getColumnCasing(chunk);\n\t\t\t\tif (_config.invokeSource === 'indexes') {\n\t\t\t\t\treturn { sql: escapeName(columnName), params: [] };\n\t\t\t\t}\n\n\t\t\t\tconst schemaName = chunk.table[Table.Symbol.Schema];\n\t\t\t\treturn {\n\t\t\t\t\tsql: chunk.table[IsAlias] || schemaName === undefined\n\t\t\t\t\t\t? escapeName(chunk.table[Table.Symbol.Name]) + '.' + escapeName(columnName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(chunk.table[Table.Symbol.Name]) + '.'\n\t\t\t\t\t\t\t+ escapeName(columnName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, View)) {\n\t\t\t\tconst schemaName = chunk[ViewBaseConfig].schema;\n\t\t\t\tconst viewName = chunk[ViewBaseConfig].name;\n\t\t\t\treturn {\n\t\t\t\t\tsql: schemaName === undefined || chunk[ViewBaseConfig].isAlias\n\t\t\t\t\t\t? escapeName(viewName)\n\t\t\t\t\t\t: escapeName(schemaName) + '.' + escapeName(viewName),\n\t\t\t\t\tparams: [],\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (is(chunk, Param)) {\n\t\t\t\tif (is(chunk.value, Placeholder)) {\n\t\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t\t\t}\n\n\t\t\t\tconst mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);\n\n\t\t\t\tif (is(mappedValue, SQL)) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([mappedValue], config);\n\t\t\t\t}\n\n\t\t\t\tif (inlineParams) {\n\t\t\t\t\treturn { sql: this.mapInlineParam(mappedValue, config), params: [] };\n\t\t\t\t}\n\n\t\t\t\tlet typings: QueryTypingsValue[] = ['none'];\n\t\t\t\tif (prepareTyping) {\n\t\t\t\t\ttypings = [prepareTyping(chunk.encoder)];\n\t\t\t\t}\n\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };\n\t\t\t}\n\n\t\t\tif (is(chunk, Placeholder)) {\n\t\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t\t}\n\n\t\t\tif (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {\n\t\t\t\treturn { sql: escapeName(chunk.fieldAlias), params: [] };\n\t\t\t}\n\n\t\t\tif (is(chunk, Subquery)) {\n\t\t\t\tif (chunk._.isWith) {\n\t\t\t\t\treturn { sql: escapeName(chunk._.alias), params: [] };\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk._.sql,\n\t\t\t\t\tnew StringChunk(') '),\n\t\t\t\t\tnew Name(chunk._.alias),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (isPgEnum(chunk)) {\n\t\t\t\tif (chunk.schema) {\n\t\t\t\t\treturn { sql: escapeName(chunk.schema) + '.' + escapeName(chunk.enumName), params: [] };\n\t\t\t\t}\n\t\t\t\treturn { sql: escapeName(chunk.enumName), params: [] };\n\t\t\t}\n\n\t\t\tif (isSQLWrapper(chunk)) {\n\t\t\t\tif (chunk.shouldOmitSQLParens?.()) {\n\t\t\t\t\treturn this.buildQueryFromSourceParams([chunk.getSQL()], config);\n\t\t\t\t}\n\t\t\t\treturn this.buildQueryFromSourceParams([\n\t\t\t\t\tnew StringChunk('('),\n\t\t\t\t\tchunk.getSQL(),\n\t\t\t\t\tnew StringChunk(')'),\n\t\t\t\t], config);\n\t\t\t}\n\n\t\t\tif (inlineParams) {\n\t\t\t\treturn { sql: this.mapInlineParam(chunk, config), params: [] };\n\t\t\t}\n\n\t\t\treturn { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk], typings: ['none'] };\n\t\t}));\n\t}\n\n\tprivate mapInlineParam(\n\t\tchunk: unknown,\n\t\t{ escapeString }: BuildQueryConfig,\n\t): string {\n\t\tif (chunk === null) {\n\t\t\treturn 'null';\n\t\t}\n\t\tif (typeof chunk === 'number' || typeof chunk === 'boolean') {\n\t\t\treturn chunk.toString();\n\t\t}\n\t\tif (typeof chunk === 'string') {\n\t\t\treturn escapeString(chunk);\n\t\t}\n\t\tif (typeof chunk === 'object') {\n\t\t\tconst mappedValueAsString = chunk.toString();\n\t\t\tif (mappedValueAsString === '[object Object]') {\n\t\t\t\treturn escapeString(JSON.stringify(chunk));\n\t\t\t}\n\t\t\treturn escapeString(mappedValueAsString);\n\t\t}\n\t\tthrow new Error('Unexpected param value: ' + chunk);\n\t}\n\n\tgetSQL(): SQL {\n\t\treturn this;\n\t}\n\n\tas(alias: string): SQL.Aliased<T>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(): SQL<TData>;\n\t/**\n\t * @deprecated\n\t * Use ``sql<DataType>`query`.as(alias)`` instead.\n\t */\n\tas<TData>(alias: string): SQL.Aliased<TData>;\n\tas(alias?: string): SQL<T> | SQL.Aliased<T> {\n\t\t// TODO: remove with deprecated overloads\n\t\tif (alias === undefined) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new SQL.Aliased(this, alias);\n\t}\n\n\tmapWith<\n\t\tTDecoder extends\n\t\t\t| DriverValueDecoder<any, any>\n\t\t\t| DriverValueDecoder<any, any>['mapFromDriverValue'],\n\t>(decoder: TDecoder): SQL<GetDecoderResult<TDecoder>> {\n\t\tthis.decoder = typeof decoder === 'function' ? { mapFromDriverValue: decoder } : decoder;\n\t\treturn this as SQL<GetDecoderResult<TDecoder>>;\n\t}\n\n\tinlineParams(): this {\n\t\tthis.shouldInlineParams = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * This method is used to conditionally include a part of the query.\n\t *\n\t * @param condition - Condition to check\n\t * @returns itself if the condition is `true`, otherwise `undefined`\n\t */\n\tif(condition: any | undefined): this | undefined {\n\t\treturn condition ? this : undefined;\n\t}\n}\n\nexport type GetDecoderResult<T> = T extends Column ? T['_']['data'] : T extends\n\t| DriverValueDecoder<infer TData, any>\n\t| DriverValueDecoder<infer TData, any>['mapFromDriverValue'] ? TData\n: never;\n\n/**\n * Any DB name (table, column, index etc.)\n */\nexport class Name implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Name';\n\n\tprotected brand!: 'Name';\n\n\tconstructor(readonly value: string) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/**\n * Any DB name (table, column, index etc.)\n * @deprecated Use `sql.identifier` instead.\n */\nexport function name(value: string): Name {\n\treturn new Name(value);\n}\n\nexport interface DriverValueDecoder<TData, TDriverParam> {\n\tmapFromDriverValue(value: TDriverParam): TData;\n}\n\nexport interface DriverValueEncoder<TData, TDriverParam> {\n\tmapToDriverValue(value: TData): TDriverParam | SQL;\n}\n\nexport function isDriverValueEncoder(value: unknown): value is DriverValueEncoder<any, any> {\n\treturn typeof value === 'object' && value !== null && 'mapToDriverValue' in value\n\t\t&& typeof (value as any).mapToDriverValue === 'function';\n}\n\nexport const noopDecoder: DriverValueDecoder<any, any> = {\n\tmapFromDriverValue: (value) => value,\n};\n\nexport const noopEncoder: DriverValueEncoder<any, any> = {\n\tmapToDriverValue: (value) => value,\n};\n\nexport interface DriverValueMapper<TData, TDriverParam>\n\textends DriverValueDecoder<TData, TDriverParam>, DriverValueEncoder<TData, TDriverParam>\n{}\n\nexport const noopMapper: DriverValueMapper<any, any> = {\n\t...noopDecoder,\n\t...noopEncoder,\n};\n\n/** Parameter value that is optionally bound to an encoder (for example, a column). */\nexport class Param<TDataType = unknown, TDriverParamType = TDataType> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Param';\n\n\tprotected brand!: 'BoundParamValue';\n\n\t/**\n\t * @param value - Parameter value\n\t * @param encoder - Encoder to convert the value to a driver parameter\n\t */\n\tconstructor(\n\t\treadonly value: TDataType,\n\t\treadonly encoder: DriverValueEncoder<TDataType, TDriverParamType> = noopEncoder,\n\t) {}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.param` instead. */\nexport function param<TData, TDriver>(\n\tvalue: TData,\n\tencoder?: DriverValueEncoder<TData, TDriver>,\n): Param<TData, TDriver> {\n\treturn new Param(value, encoder);\n}\n\n/**\n * Anything that can be passed to the `` sql`...` `` tagged function.\n */\nexport type SQLChunk =\n\t| StringChunk\n\t| SQLChunk[]\n\t| SQLWrapper\n\t| SQL\n\t| Table\n\t| View\n\t| Subquery\n\t| AnyColumn\n\t| Param\n\t| Name\n\t| undefined\n\t| FakePrimitiveParam\n\t| Placeholder;\n\nexport function sql<T>(strings: TemplateStringsArray, ...params: any[]): SQL<T>;\n/*\n\tThe type of `params` is specified as `SQLChunk[]`, but that's slightly incorrect -\n\tin runtime, users won't pass `FakePrimitiveParam` instances as `params` - they will pass primitive values\n\twhich will be wrapped in `Param`. That's why the overload specifies `params` as `any[]` and not as `SQLSourceParam[]`.\n\tThis type is used to make our lives easier and the type checker happy.\n*/\nexport function sql(strings: TemplateStringsArray, ...params: SQLChunk[]): SQL {\n\tconst queryChunks: SQLChunk[] = [];\n\tif (params.length > 0 || (strings.length > 0 && strings[0] !== '')) {\n\t\tqueryChunks.push(new StringChunk(strings[0]!));\n\t}\n\tfor (const [paramIndex, param] of params.entries()) {\n\t\tqueryChunks.push(param, new StringChunk(strings[paramIndex + 1]!));\n\t}\n\n\treturn new SQL(queryChunks);\n}\n\nexport namespace sql {\n\texport function empty(): SQL {\n\t\treturn new SQL([]);\n\t}\n\n\t/** @deprecated - use `sql.join()` */\n\texport function fromList(list: SQLChunk[]): SQL {\n\t\treturn new SQL(list);\n\t}\n\n\t/**\n\t * Convenience function to create an SQL query from a raw string.\n\t * @param str The raw SQL query string.\n\t */\n\texport function raw(str: string): SQL {\n\t\treturn new SQL([new StringChunk(str)]);\n\t}\n\n\t/**\n\t * Join a list of SQL chunks with a separator.\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`]);\n\t * // sql`abc`\n\t * ```\n\t * @example\n\t * ```ts\n\t * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);\n\t * // sql`a, b, c`\n\t * ```\n\t */\n\texport function join(chunks: SQLChunk[], separator?: SQLChunk): SQL {\n\t\tconst result: SQLChunk[] = [];\n\t\tfor (const [i, chunk] of chunks.entries()) {\n\t\t\tif (i > 0 && separator !== undefined) {\n\t\t\t\tresult.push(separator);\n\t\t\t}\n\t\t\tresult.push(chunk);\n\t\t}\n\t\treturn new SQL(result);\n\t}\n\n\t/**\n\t * Create a SQL chunk that represents a DB identifier (table, column, index etc.).\n\t * When used in a query, the identifier will be escaped based on the DB engine.\n\t * For example, in PostgreSQL, identifiers are escaped with double quotes.\n\t *\n\t * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**\n\t *\n\t * @example ```ts\n\t * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;\n\t * // 'SELECT * FROM \"my-table\"'\n\t * ```\n\t */\n\texport function identifier(value: string): Name {\n\t\treturn new Name(value);\n\t}\n\n\texport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\t\treturn new Placeholder(name);\n\t}\n\n\texport function param<TData, TDriver>(\n\t\tvalue: TData,\n\t\tencoder?: DriverValueEncoder<TData, TDriver>,\n\t): Param<TData, TDriver> {\n\t\treturn new Param(value, encoder);\n\t}\n}\n\nexport namespace SQL {\n\texport class Aliased<T = unknown> implements SQLWrapper {\n\t\tstatic readonly [entityKind]: string = 'SQL.Aliased';\n\n\t\tdeclare _: {\n\t\t\tbrand: 'SQL.Aliased';\n\t\t\ttype: T;\n\t\t};\n\n\t\t/** @internal */\n\t\tisSelectionField = false;\n\n\t\tconstructor(\n\t\t\treadonly sql: SQL,\n\t\t\treadonly fieldAlias: string,\n\t\t) {}\n\n\t\tgetSQL(): SQL {\n\t\t\treturn this.sql;\n\t\t}\n\n\t\t/** @internal */\n\t\tclone() {\n\t\t\treturn new Aliased(this.sql, this.fieldAlias);\n\t\t}\n\t}\n}\n\nexport class Placeholder<TName extends string = string, TValue = any> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'Placeholder';\n\n\tdeclare protected: TValue;\n\n\tconstructor(readonly name: TName) {}\n\n\tgetSQL(): SQL {\n\t\treturn new SQL([this]);\n\t}\n}\n\n/** @deprecated Use `sql.placeholder` instead. */\nexport function placeholder<TName extends string>(name: TName): Placeholder<TName> {\n\treturn new Placeholder(name);\n}\n\nexport function fillPlaceholders(params: unknown[], values: Record<string, unknown>): unknown[] {\n\treturn params.map((p) => {\n\t\tif (is(p, Placeholder)) {\n\t\t\tif (!(p.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.name}\" was provided`);\n\t\t\t}\n\n\t\t\treturn values[p.name];\n\t\t}\n\n\t\tif (is(p, Param) && is(p.value, Placeholder)) {\n\t\t\tif (!(p.value.name in values)) {\n\t\t\t\tthrow new Error(`No value for placeholder \"${p.value.name}\" was provided`);\n\t\t\t}\n\n\t\t\treturn p.encoder.mapToDriverValue(values[p.value.name]);\n\t\t}\n\n\t\treturn p;\n\t});\n}\n\nexport type ColumnsSelection = Record<string, unknown>;\n\nconst IsDrizzleView = Symbol.for('drizzle:IsDrizzleView');\n\nexport abstract class View<\n\tTName extends string = string,\n\tTExisting extends boolean = boolean,\n\tTSelection extends ColumnsSelection = ColumnsSelection,\n> implements SQLWrapper {\n\tstatic readonly [entityKind]: string = 'View';\n\n\tdeclare _: {\n\t\tbrand: 'View';\n\t\tviewBrand: string;\n\t\tname: TName;\n\t\texisting: TExisting;\n\t\tselectedFields: TSelection;\n\t};\n\n\t/** @internal */\n\t[ViewBaseConfig]: {\n\t\tname: TName;\n\t\toriginalName: TName;\n\t\tschema: string | undefined;\n\t\tselectedFields: ColumnsSelection;\n\t\tisExisting: TExisting;\n\t\tquery: TExisting extends true ? undefined : SQL;\n\t\tisAlias: boolean;\n\t};\n\n\t/** @internal */\n\t[IsDrizzleView] = true;\n\n\tdeclare readonly $inferSelect: InferSelectViewModel<View<Assume<TName, string>, TExisting, TSelection>>;\n\n\tconstructor(\n\t\t{ name, schema, selectedFields, query }: {\n\t\t\tname: TName;\n\t\t\tschema: string | undefined;\n\t\t\tselectedFields: ColumnsSelection;\n\t\t\tquery: SQL | undefined;\n\t\t},\n\t) {\n\t\tthis[ViewBaseConfig] = {\n\t\t\tname,\n\t\t\toriginalName: name,\n\t\t\tschema,\n\t\t\tselectedFields,\n\t\t\tquery: query as (TExisting extends true ? undefined : SQL),\n\t\t\tisExisting: !query as TExisting,\n\t\t\tisAlias: false,\n\t\t};\n\t}\n\n\tgetSQL(): SQL<unknown> {\n\t\treturn new SQL([this]);\n\t}\n}\n\nexport function isView(view: unknown): view is View {\n\treturn typeof view === 'object' && view !== null && IsDrizzleView in view;\n}\n\nexport function getViewName<T extends View>(view: T): T['_']['name'] {\n\treturn view[ViewBaseConfig].name;\n}\n\nexport type InferSelectViewModel<TView extends View> =\n\tEqual<TView['_']['selectedFields'], { [x: string]: unknown }> extends true ? { [x: string]: unknown }\n\t\t: SelectResult<\n\t\t\tTView['_']['selectedFields'],\n\t\t\t'single',\n\t\t\tRecord<TView['_']['name'], 'not-null'>\n\t\t>;\n\n// Defined separately from the Column class to resolve circular dependency\nColumn.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Table class to resolve circular dependency\nTable.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n\n// Defined separately from the Column class to resolve circular dependency\nSubquery.prototype.getSQL = function() {\n\treturn new SQL([this]);\n};\n","import type { AnyColumn } from './column.ts';\nimport { Column } from './column.ts';\nimport { is } from './entity.ts';\nimport type { Logger } from './logger.ts';\nimport type { SelectedFieldsOrdered } from './operations.ts';\nimport type { TableLike } from './query-builders/select.types.ts';\nimport { Param, SQL, View } from './sql/sql.ts';\nimport type { DriverValueDecoder } from './sql/sql.ts';\nimport { Subquery } from './subquery.ts';\nimport { getTableName, Table } from './table.ts';\nimport { ViewBaseConfig } from './view-common.ts';\n\n/** @internal */\nexport function mapResultRow<TResult>(\n\tcolumns: SelectedFieldsOrdered<AnyColumn>,\n\trow: unknown[],\n\tjoinsNotNullableMap: Record<string, boolean> | undefined,\n): TResult {\n\t// Key -> nested object key, value -> table name if all fields in the nested object are from the same table, false otherwise\n\tconst nullifyMap: Record<string, string | false> = {};\n\n\tconst result = columns.reduce<Record<string, any>>(\n\t\t(result, { path, field }, columnIndex) => {\n\t\t\tlet decoder: DriverValueDecoder<unknown, unknown>;\n\t\t\tif (is(field, Column)) {\n\t\t\t\tdecoder = field;\n\t\t\t} else if (is(field, SQL)) {\n\t\t\t\tdecoder = field.decoder;\n\t\t\t} else {\n\t\t\t\tdecoder = field.sql.decoder;\n\t\t\t}\n\t\t\tlet node = result;\n\t\t\tfor (const [pathChunkIndex, pathChunk] of path.entries()) {\n\t\t\t\tif (pathChunkIndex < path.length - 1) {\n\t\t\t\t\tif (!(pathChunk in node)) {\n\t\t\t\t\t\tnode[pathChunk] = {};\n\t\t\t\t\t}\n\t\t\t\t\tnode = node[pathChunk];\n\t\t\t\t} else {\n\t\t\t\t\tconst rawValue = row[columnIndex]!;\n\t\t\t\t\tconst value = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);\n\n\t\t\t\t\tif (joinsNotNullableMap && is(field, Column) && path.length === 2) {\n\t\t\t\t\t\tconst objectName = path[0]!;\n\t\t\t\t\t\tif (!(objectName in nullifyMap)) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = value === null ? getTableName(field.table) : false;\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\ttypeof nullifyMap[objectName] === 'string' && nullifyMap[objectName] !== getTableName(field.table)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tnullifyMap[objectName] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\t{},\n\t);\n\n\t// Nullify all nested objects from nullifyMap that are nullable\n\tif (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {\n\t\tfor (const [objectName, tableName] of Object.entries(nullifyMap)) {\n\t\t\tif (typeof tableName === 'string' && !joinsNotNullableMap[tableName]) {\n\t\t\t\tresult[objectName] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result as TResult;\n}\n\n/** @internal */\nexport function orderSelectedFields<TColumn extends AnyColumn>(\n\tfields: Record<string, unknown>,\n\tpathPrefix?: string[],\n): SelectedFieldsOrdered<TColumn> {\n\treturn Object.entries(fields).reduce<SelectedFieldsOrdered<AnyColumn>>((result, [name, field]) => {\n\t\tif (typeof name !== 'string') {\n\t\t\treturn result;\n\t\t}\n\n\t\tconst newPath = pathPrefix ? [...pathPrefix, name] : [name];\n\t\tif (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {\n\t\t\tresult.push({ path: newPath, field });\n\t\t} else if (is(field, Table)) {\n\t\t\tresult.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));\n\t\t} else {\n\t\t\tresult.push(...orderSelectedFields(field as Record<string, unknown>, newPath));\n\t\t}\n\t\treturn result;\n\t}, []) as SelectedFieldsOrdered<TColumn>;\n}\n\nexport function haveSameKeys(left: Record<string, unknown>, right: Record<string, unknown>) {\n\tconst leftKeys = Object.keys(left);\n\tconst rightKeys = Object.keys(right);\n\n\tif (leftKeys.length !== rightKeys.length) {\n\t\treturn false;\n\t}\n\n\tfor (const [index, key] of leftKeys.entries()) {\n\t\tif (key !== rightKeys[index]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/** @internal */\nexport function mapUpdateSet(table: Table, values: Record<string, unknown>): UpdateSet {\n\tconst entries: [string, UpdateSet[string]][] = Object.entries(values)\n\t\t.filter(([, value]) => value !== undefined)\n\t\t.map(([key, value]) => {\n\t\t\t// eslint-disable-next-line unicorn/prefer-ternary\n\t\t\tif (is(value, SQL) || is(value, Column)) {\n\t\t\t\treturn [key, value];\n\t\t\t} else {\n\t\t\t\treturn [key, new Param(value, table[Table.Symbol.Columns][key])];\n\t\t\t}\n\t\t});\n\n\tif (entries.length === 0) {\n\t\tthrow new Error('No values to set');\n\t}\n\n\treturn Object.fromEntries(entries);\n}\n\nexport type UpdateSet = Record<string, SQL | Param | AnyColumn | null | undefined>;\n\nexport type OneOrMany<T> = T | T[];\n\nexport type Update<T, TUpdate> =\n\t& {\n\t\t[K in Exclude<keyof T, keyof TUpdate>]: T[K];\n\t}\n\t& TUpdate;\n\nexport type Simplify<T> =\n\t& {\n\t\t// @ts-ignore - \"Type parameter 'K' has a circular constraint\", not sure why\n\t\t[K in keyof T]: T[K];\n\t}\n\t& {};\n\nexport type SimplifyMappedType<T> = [T] extends [unknown] ? T : never;\n\nexport type ShallowRecord<K extends keyof any, T> = SimplifyMappedType<{ [P in K]: T }>;\n\nexport type Assume<T, U> = T extends U ? T : U;\n\nexport type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;\n\nexport interface DrizzleTypeError<T extends string> {\n\t$drizzleTypeError: T;\n}\n\nexport type ValueOrArray<T> = T | T[];\n\n/** @internal */\nexport function applyMixins(baseClass: any, extendedClasses: any[]) {\n\tfor (const extendedClass of extendedClasses) {\n\t\tfor (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {\n\t\t\tif (name === 'constructor') continue;\n\n\t\t\tObject.defineProperty(\n\t\t\t\tbaseClass.prototype,\n\t\t\t\tname,\n\t\t\t\tObject.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null),\n\t\t\t);\n\t\t}\n\t}\n}\n\nexport type Or<T1, T2> = T1 extends true ? true : T2 extends true ? true : false;\n\nexport type IfThenElse<If, Then, Else> = If extends true ? Then : Else;\n\nexport type PromiseOf<T> = T extends Promise<infer U> ? U : T;\n\nexport type Writable<T> = {\n\t-readonly [P in keyof T]: T[P];\n};\n\nexport type NonArray<T> = T extends any[] ? never : T;\n\nexport function getTableColumns<T extends Table>(table: T): T['_']['columns'] {\n\treturn table[Table.Symbol.Columns];\n}\n\nexport function getViewSelectedFields<T extends View>(view: T): T['_']['selectedFields'] {\n\treturn view[ViewBaseConfig].selectedFields;\n}\n\n/** @internal */\nexport function getTableLikeName(table: TableLike): string | undefined {\n\treturn is(table, Subquery)\n\t\t? table._.alias\n\t\t: is(table, View)\n\t\t? table[ViewBaseConfig].name\n\t\t: is(table, SQL)\n\t\t? undefined\n\t\t: table[Table.Symbol.IsAlias]\n\t\t? table[Table.Symbol.Name]\n\t\t: table[Table.Symbol.BaseName];\n}\n\nexport type ColumnsWithTable<\n\tTTableName extends string,\n\tTForeignTableName extends string,\n\tTColumns extends AnyColumn<{ tableName: TTableName }>[],\n> = { [Key in keyof TColumns]: AnyColumn<{ tableName: TForeignTableName }> };\n\nexport type Casing = 'snake_case' | 'camelCase';\n\nexport interface DrizzleConfig<TSchema extends Record<string, unknown> = Record<string, never>> {\n\tlogger?: boolean | Logger;\n\tschema?: TSchema;\n\tcasing?: Casing;\n}\nexport type ValidateShape<T, ValidShape, TResult = T> = T extends ValidShape\n\t? Exclude<keyof T, keyof ValidShape> extends never ? TResult\n\t: DrizzleTypeError<\n\t\t`Invalid key(s): ${Exclude<(keyof T) & (string | number | bigint | boolean | null | undefined), keyof ValidShape>}`\n\t>\n\t: never;\n\nexport type KnownKeysOnly<T, U> = {\n\t[K in keyof T]: K extends keyof U ? T[K] : never;\n};\n\nexport type IsAny<T> = 0 extends (1 & T) ? true : false;\n\n/** @internal */\nexport function getColumnNameAndConfig<\n\tTConfig extends Record<string, any> | undefined,\n>(a: string | TConfig | undefined, b: TConfig | undefined) {\n\treturn {\n\t\tname: typeof a === 'string' && a.length > 0 ? a : '' as string,\n\t\tconfig: typeof a === 'object' ? a : b as TConfig,\n\t};\n}\n\nexport type IfNotImported<T, Y, N> = unknown extends T ? Y : N;\n\nexport type ImportTypeError<TPackageName extends string> =\n\t`Please install \\`${TPackageName}\\` to allow Drizzle ORM to connect to the database`;\n\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Keys extends any\n\t? Required<Pick<T, Keys>> & Partial<Omit<T, Keys>>\n\t: never;\n\ntype ExpectedConfigShape = {\n\tlogger?: boolean | {\n\t\tlogQuery(query: string, params: unknown[]): void;\n\t};\n\tschema?: Record<string, never>;\n\tcasing?: 'snake_case' | 'camelCase';\n};\n\n// If this errors, you must update config shape checker function with new config specs\nconst _: DrizzleConfig = {} as ExpectedConfigShape;\nconst __: ExpectedConfigShape = {} as DrizzleConfig;\n\nexport function isConfig(data: any): boolean {\n\tif (typeof data !== 'object' || data === null) return false;\n\n\tif (data.constructor.name !== 'Object') return false;\n\n\tif ('logger' in data) {\n\t\tconst type = typeof data['logger'];\n\t\tif (\n\t\t\ttype !== 'boolean' && (type !== 'object' || typeof data['logger']['logQuery'] !== 'function')\n\t\t\t&& type !== 'undefined'\n\t\t) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('schema' in data) {\n\t\tconst type = typeof data['schema'];\n\t\tif (type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('casing' in data) {\n\t\tconst type = typeof data['casing'];\n\t\tif (type !== 'string' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('mode' in data) {\n\t\tif (data['mode'] !== 'default' || data['mode'] !== 'planetscale' || data['mode'] !== undefined) return false;\n\n\t\treturn true;\n\t}\n\n\tif ('connection' in data) {\n\t\tconst type = typeof data['connection'];\n\t\tif (type !== 'string' && type !== 'object' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif ('client' in data) {\n\t\tconst type = typeof data['client'];\n\t\tif (type !== 'object' && type !== 'function' && type !== 'undefined') return false;\n\n\t\treturn true;\n\t}\n\n\tif (Object.keys(data).length === 0) return true;\n\n\treturn false;\n}\n\nexport type NeonAuthToken = string | (() => string | Promise<string>);\n","import type { ColumnBuilderBaseConfig, ColumnDataType } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport { sql } from '~/sql/sql.ts';\nimport { PgColumnBuilder } from './common.ts';\n\nexport abstract class PgDateColumnBaseBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n\tTRuntimeConfig extends object = object,\n> extends PgColumnBuilder<T, TRuntimeConfig> {\n\tstatic override readonly [entityKind]: string = 'PgDateColumnBaseBuilder';\n\n\tdefaultNow() {\n\t\treturn this.default(sql`now()`);\n\t}\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn } from './common.ts';\nimport { PgDateColumnBaseBuilder } from './date.common.ts';\n\nexport type PgDateBuilderInitial<TName extends string> = PgDateBuilder<{\n\tname: TName;\n\tdataType: 'date';\n\tcolumnType: 'PgDate';\n\tdata: Date;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgDateBuilder<T extends ColumnBuilderBaseConfig<'date', 'PgDate'>> extends PgDateColumnBaseBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgDateBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'date', 'PgDate');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgDate<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgDate<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgDate<T extends ColumnBaseConfig<'date', 'PgDate'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgDate';\n\n\tgetSQLType(): string {\n\t\treturn 'date';\n\t}\n\n\toverride mapFromDriverValue(value: string): Date {\n\t\treturn new Date(value);\n\t}\n\n\toverride mapToDriverValue(value: Date): string {\n\t\treturn value.toISOString();\n\t}\n}\n\nexport type PgDateStringBuilderInitial<TName extends string> = PgDateStringBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgDateString';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgDateStringBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgDateString'>>\n\textends PgDateColumnBaseBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgDateStringBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgDateString');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgDateString<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgDateString<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgDateString<T extends ColumnBaseConfig<'string', 'PgDateString'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgDateString';\n\n\tgetSQLType(): string {\n\t\treturn 'date';\n\t}\n}\n\nexport interface PgDateConfig<T extends 'date' | 'string' = 'date' | 'string'> {\n\tmode: T;\n}\n\nexport function date(): PgDateStringBuilderInitial<''>;\nexport function date<TMode extends PgDateConfig['mode'] & {}>(\n\tconfig?: PgDateConfig<TMode>,\n): Equal<TMode, 'date'> extends true ? PgDateBuilderInitial<''> : PgDateStringBuilderInitial<''>;\nexport function date<TName extends string, TMode extends PgDateConfig['mode'] & {}>(\n\tname: TName,\n\tconfig?: PgDateConfig<TMode>,\n): Equal<TMode, 'date'> extends true ? PgDateBuilderInitial<TName> : PgDateStringBuilderInitial<TName>;\nexport function date(a?: string | PgDateConfig, b?: PgDateConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgDateConfig>(a, b);\n\tif (config?.mode === 'date') {\n\t\treturn new PgDateBuilder(name);\n\t}\n\treturn new PgDateStringBuilder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgJsonBuilderInitial<TName extends string> = PgJsonBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'PgJson';\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: undefined;\n}>;\n\nexport class PgJsonBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgJson'>> extends PgColumnBuilder<\n\tT\n> {\n\tstatic override readonly [entityKind]: string = 'PgJsonBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'PgJson');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgJson<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgJson<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgJson<T extends ColumnBaseConfig<'json', 'PgJson'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgJson';\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgJsonBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t}\n\n\tgetSQLType(): string {\n\t\treturn 'json';\n\t}\n\n\toverride mapToDriverValue(value: T['data']): string {\n\t\treturn JSON.stringify(value);\n\t}\n\n\toverride mapFromDriverValue(value: T['data'] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value);\n\t\t\t} catch {\n\t\t\t\treturn value as T['data'];\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function json(): PgJsonBuilderInitial<''>;\nexport function json<TName extends string>(name: TName): PgJsonBuilderInitial<TName>;\nexport function json(name?: string) {\n\treturn new PgJsonBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgJsonbBuilderInitial<TName extends string> = PgJsonbBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'PgJsonb';\n\tdata: unknown;\n\tdriverParam: unknown;\n\tenumValues: undefined;\n}>;\n\nexport class PgJsonbBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgJsonb'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgJsonbBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'PgJsonb');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgJsonb<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgJsonb<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgJsonb<T extends ColumnBaseConfig<'json', 'PgJsonb'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgJsonb';\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgJsonbBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t}\n\n\tgetSQLType(): string {\n\t\treturn 'jsonb';\n\t}\n\n\toverride mapToDriverValue(value: T['data']): string {\n\t\treturn JSON.stringify(value);\n\t}\n\n\toverride mapFromDriverValue(value: T['data'] | string): T['data'] {\n\t\tif (typeof value === 'string') {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(value);\n\t\t\t} catch {\n\t\t\t\treturn value as T['data'];\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function jsonb(): PgJsonbBuilderInitial<''>;\nexport function jsonb<TName extends string>(name: TName): PgJsonbBuilderInitial<TName>;\nexport function jsonb(name?: string) {\n\treturn new PgJsonbBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgNumericBuilderInitial<TName extends string> = PgNumericBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgNumeric';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgNumericBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgNumeric'>> extends PgColumnBuilder<\n\tT,\n\t{\n\t\tprecision: number | undefined;\n\t\tscale: number | undefined;\n\t}\n> {\n\tstatic override readonly [entityKind]: string = 'PgNumericBuilder';\n\n\tconstructor(name: T['name'], precision?: number, scale?: number) {\n\t\tsuper(name, 'string', 'PgNumeric');\n\t\tthis.config.precision = precision;\n\t\tthis.config.scale = scale;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgNumeric<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgNumeric<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgNumeric<T extends ColumnBaseConfig<'string', 'PgNumeric'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgNumeric';\n\n\treadonly precision: number | undefined;\n\treadonly scale: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgNumericBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.precision = config.precision;\n\t\tthis.scale = config.scale;\n\t}\n\n\toverride mapFromDriverValue(value: unknown): string {\n\t\tif (typeof value === 'string') return value;\n\n\t\treturn String(value);\n\t}\n\n\tgetSQLType(): string {\n\t\tif (this.precision !== undefined && this.scale !== undefined) {\n\t\t\treturn `numeric(${this.precision}, ${this.scale})`;\n\t\t} else if (this.precision === undefined) {\n\t\t\treturn 'numeric';\n\t\t} else {\n\t\t\treturn `numeric(${this.precision})`;\n\t\t}\n\t}\n}\n\nexport type PgNumericNumberBuilderInitial<TName extends string> = PgNumericNumberBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'PgNumericNumber';\n\tdata: number;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgNumericNumberBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgNumericNumber'>>\n\textends PgColumnBuilder<\n\t\tT,\n\t\t{\n\t\t\tprecision: number | undefined;\n\t\t\tscale: number | undefined;\n\t\t}\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgNumericNumberBuilder';\n\n\tconstructor(name: T['name'], precision?: number, scale?: number) {\n\t\tsuper(name, 'number', 'PgNumericNumber');\n\t\tthis.config.precision = precision;\n\t\tthis.config.scale = scale;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgNumericNumber<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgNumericNumber<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgNumericNumber<T extends ColumnBaseConfig<'number', 'PgNumericNumber'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgNumericNumber';\n\n\treadonly precision: number | undefined;\n\treadonly scale: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgNumericNumberBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.precision = config.precision;\n\t\tthis.scale = config.scale;\n\t}\n\n\toverride mapFromDriverValue(value: unknown): number {\n\t\tif (typeof value === 'number') return value;\n\n\t\treturn Number(value);\n\t}\n\n\toverride mapToDriverValue = String;\n\n\tgetSQLType(): string {\n\t\tif (this.precision !== undefined && this.scale !== undefined) {\n\t\t\treturn `numeric(${this.precision}, ${this.scale})`;\n\t\t} else if (this.precision === undefined) {\n\t\t\treturn 'numeric';\n\t\t} else {\n\t\t\treturn `numeric(${this.precision})`;\n\t\t}\n\t}\n}\n\nexport type PgNumericBigIntBuilderInitial<TName extends string> = PgNumericBigIntBuilder<{\n\tname: TName;\n\tdataType: 'bigint';\n\tcolumnType: 'PgNumericBigInt';\n\tdata: bigint;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgNumericBigIntBuilder<T extends ColumnBuilderBaseConfig<'bigint', 'PgNumericBigInt'>>\n\textends PgColumnBuilder<\n\t\tT,\n\t\t{\n\t\t\tprecision: number | undefined;\n\t\t\tscale: number | undefined;\n\t\t}\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgNumericBigIntBuilder';\n\n\tconstructor(name: T['name'], precision?: number, scale?: number) {\n\t\tsuper(name, 'bigint', 'PgNumericBigInt');\n\t\tthis.config.precision = precision;\n\t\tthis.config.scale = scale;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgNumericBigInt<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgNumericBigInt<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgNumericBigInt<T extends ColumnBaseConfig<'bigint', 'PgNumericBigInt'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgNumericBigInt';\n\n\treadonly precision: number | undefined;\n\treadonly scale: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgNumericBigIntBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.precision = config.precision;\n\t\tthis.scale = config.scale;\n\t}\n\n\toverride mapFromDriverValue = BigInt;\n\n\toverride mapToDriverValue = String;\n\n\tgetSQLType(): string {\n\t\tif (this.precision !== undefined && this.scale !== undefined) {\n\t\t\treturn `numeric(${this.precision}, ${this.scale})`;\n\t\t} else if (this.precision === undefined) {\n\t\t\treturn 'numeric';\n\t\t} else {\n\t\t\treturn `numeric(${this.precision})`;\n\t\t}\n\t}\n}\n\nexport type PgNumericConfig<T extends 'string' | 'number' | 'bigint' = 'string' | 'number' | 'bigint'> =\n\t| { precision: number; scale?: number; mode?: T }\n\t| { precision?: number; scale: number; mode?: T }\n\t| { precision?: number; scale?: number; mode: T };\n\nexport function numeric<TMode extends 'string' | 'number' | 'bigint'>(\n\tconfig?: PgNumericConfig<TMode>,\n): Equal<TMode, 'number'> extends true ? PgNumericNumberBuilderInitial<''>\n\t: Equal<TMode, 'bigint'> extends true ? PgNumericBigIntBuilderInitial<''>\n\t: PgNumericBuilderInitial<''>;\nexport function numeric<TName extends string, TMode extends 'string' | 'number' | 'bigint'>(\n\tname: TName,\n\tconfig?: PgNumericConfig<TMode>,\n): Equal<TMode, 'number'> extends true ? PgNumericNumberBuilderInitial<TName>\n\t: Equal<TMode, 'bigint'> extends true ? PgNumericBigIntBuilderInitial<TName>\n\t: PgNumericBuilderInitial<TName>;\nexport function numeric(a?: string | PgNumericConfig, b?: PgNumericConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgNumericConfig>(a, b);\n\tconst mode = config?.mode;\n\treturn mode === 'number'\n\t\t? new PgNumericNumberBuilder(name, config?.precision, config?.scale)\n\t\t: mode === 'bigint'\n\t\t? new PgNumericBigIntBuilder(name, config?.precision, config?.scale)\n\t\t: new PgNumericBuilder(name, config?.precision, config?.scale);\n}\n\nexport const decimal = numeric;\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn } from './common.ts';\nimport { PgDateColumnBaseBuilder } from './date.common.ts';\nimport type { Precision } from './timestamp.ts';\n\nexport type PgTimeBuilderInitial<TName extends string> = PgTimeBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgTime';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgTimeBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgTime'>> extends PgDateColumnBaseBuilder<\n\tT,\n\t{ withTimezone: boolean; precision: number | undefined }\n> {\n\tstatic override readonly [entityKind]: string = 'PgTimeBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\treadonly withTimezone: boolean,\n\t\treadonly precision: number | undefined,\n\t) {\n\t\tsuper(name, 'string', 'PgTime');\n\t\tthis.config.withTimezone = withTimezone;\n\t\tthis.config.precision = precision;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgTime<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgTime<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgTime<T extends ColumnBaseConfig<'string', 'PgTime'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgTime';\n\n\treadonly withTimezone: boolean;\n\treadonly precision: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgTimeBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.withTimezone = config.withTimezone;\n\t\tthis.precision = config.precision;\n\t}\n\n\tgetSQLType(): string {\n\t\tconst precision = this.precision === undefined ? '' : `(${this.precision})`;\n\t\treturn `time${precision}${this.withTimezone ? ' with time zone' : ''}`;\n\t}\n}\n\nexport interface TimeConfig {\n\tprecision?: Precision;\n\twithTimezone?: boolean;\n}\n\nexport function time(): PgTimeBuilderInitial<''>;\nexport function time(config?: TimeConfig): PgTimeBuilderInitial<''>;\nexport function time<TName extends string>(name: TName, config?: TimeConfig): PgTimeBuilderInitial<TName>;\nexport function time(a?: string | TimeConfig, b: TimeConfig = {}) {\n\tconst { name, config } = getColumnNameAndConfig<TimeConfig>(a, b);\n\treturn new PgTimeBuilder(name, config.withTimezone ?? false, config.precision);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn } from './common.ts';\nimport { PgDateColumnBaseBuilder } from './date.common.ts';\n\nexport type PgTimestampBuilderInitial<TName extends string> = PgTimestampBuilder<{\n\tname: TName;\n\tdataType: 'date';\n\tcolumnType: 'PgTimestamp';\n\tdata: Date;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgTimestampBuilder<T extends ColumnBuilderBaseConfig<'date', 'PgTimestamp'>>\n\textends PgDateColumnBaseBuilder<\n\t\tT,\n\t\t{ withTimezone: boolean; precision: number | undefined }\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgTimestampBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\twithTimezone: boolean,\n\t\tprecision: number | undefined,\n\t) {\n\t\tsuper(name, 'date', 'PgTimestamp');\n\t\tthis.config.withTimezone = withTimezone;\n\t\tthis.config.precision = precision;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgTimestamp<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgTimestamp<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgTimestamp<T extends ColumnBaseConfig<'date', 'PgTimestamp'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgTimestamp';\n\n\treadonly withTimezone: boolean;\n\treadonly precision: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgTimestampBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.withTimezone = config.withTimezone;\n\t\tthis.precision = config.precision;\n\t}\n\n\tgetSQLType(): string {\n\t\tconst precision = this.precision === undefined ? '' : ` (${this.precision})`;\n\t\treturn `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;\n\t}\n\n\toverride mapFromDriverValue = (value: string): Date | null => {\n\t\treturn new Date(this.withTimezone ? value : value + '+0000');\n\t};\n\n\toverride mapToDriverValue = (value: Date): string => {\n\t\treturn value.toISOString();\n\t};\n}\n\nexport type PgTimestampStringBuilderInitial<TName extends string> = PgTimestampStringBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgTimestampString';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgTimestampStringBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgTimestampString'>>\n\textends PgDateColumnBaseBuilder<\n\t\tT,\n\t\t{ withTimezone: boolean; precision: number | undefined }\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgTimestampStringBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\twithTimezone: boolean,\n\t\tprecision: number | undefined,\n\t) {\n\t\tsuper(name, 'string', 'PgTimestampString');\n\t\tthis.config.withTimezone = withTimezone;\n\t\tthis.config.precision = precision;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgTimestampString<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgTimestampString<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgTimestampString<T extends ColumnBaseConfig<'string', 'PgTimestampString'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgTimestampString';\n\n\treadonly withTimezone: boolean;\n\treadonly precision: number | undefined;\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgTimestampStringBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t\tthis.withTimezone = config.withTimezone;\n\t\tthis.precision = config.precision;\n\t}\n\n\tgetSQLType(): string {\n\t\tconst precision = this.precision === undefined ? '' : `(${this.precision})`;\n\t\treturn `timestamp${precision}${this.withTimezone ? ' with time zone' : ''}`;\n\t}\n}\n\nexport type Precision = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\nexport interface PgTimestampConfig<TMode extends 'date' | 'string' = 'date' | 'string'> {\n\tmode?: TMode;\n\tprecision?: Precision;\n\twithTimezone?: boolean;\n}\n\nexport function timestamp(): PgTimestampBuilderInitial<''>;\nexport function timestamp<TMode extends PgTimestampConfig['mode'] & {}>(\n\tconfig?: PgTimestampConfig<TMode>,\n): Equal<TMode, 'string'> extends true ? PgTimestampStringBuilderInitial<''> : PgTimestampBuilderInitial<''>;\nexport function timestamp<TName extends string, TMode extends PgTimestampConfig['mode'] & {}>(\n\tname: TName,\n\tconfig?: PgTimestampConfig<TMode>,\n): Equal<TMode, 'string'> extends true ? PgTimestampStringBuilderInitial<TName> : PgTimestampBuilderInitial<TName>;\nexport function timestamp(a?: string | PgTimestampConfig, b: PgTimestampConfig = {}) {\n\tconst { name, config } = getColumnNameAndConfig<PgTimestampConfig | undefined>(a, b);\n\tif (config?.mode === 'string') {\n\t\treturn new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);\n\t}\n\treturn new PgTimestampBuilder(name, config?.withTimezone ?? false, config?.precision);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { sql } from '~/sql/sql.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgUUIDBuilderInitial<TName extends string> = PgUUIDBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgUUID';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgUUIDBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgUUID'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgUUIDBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgUUID');\n\t}\n\n\t/**\n\t * Adds `default gen_random_uuid()` to the column definition.\n\t */\n\tdefaultRandom(): ReturnType<this['default']> {\n\t\treturn this.default(sql`gen_random_uuid()`) as ReturnType<this['default']>;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgUUID<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgUUID<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgUUID<T extends ColumnBaseConfig<'string', 'PgUUID'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgUUID';\n\n\tgetSQLType(): string {\n\t\treturn 'uuid';\n\t}\n}\n\nexport function uuid(): PgUUIDBuilderInitial<''>;\nexport function uuid<TName extends string>(name: TName): PgUUIDBuilderInitial<TName>;\nexport function uuid(name?: string) {\n\treturn new PgUUIDBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnDataType, GeneratedIdentityConfig, IsIdentity } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { PgSequenceOptions } from '../sequence.ts';\nimport { PgColumnBuilder } from './common.ts';\n\nexport abstract class PgIntColumnBaseBuilder<\n\tT extends ColumnBuilderBaseConfig<ColumnDataType, string>,\n> extends PgColumnBuilder<\n\tT,\n\t{ generatedIdentity: GeneratedIdentityConfig }\n> {\n\tstatic override readonly [entityKind]: string = 'PgIntColumnBaseBuilder';\n\n\tgeneratedAlwaysAsIdentity(\n\t\tsequence?: PgSequenceOptions & { name?: string },\n\t): IsIdentity<this, 'always'> {\n\t\tif (sequence) {\n\t\t\tconst { name, ...options } = sequence;\n\t\t\tthis.config.generatedIdentity = {\n\t\t\t\ttype: 'always',\n\t\t\t\tsequenceName: name,\n\t\t\t\tsequenceOptions: options,\n\t\t\t};\n\t\t} else {\n\t\t\tthis.config.generatedIdentity = {\n\t\t\t\ttype: 'always',\n\t\t\t};\n\t\t}\n\n\t\tthis.config.hasDefault = true;\n\t\tthis.config.notNull = true;\n\n\t\treturn this as IsIdentity<this, 'always'>;\n\t}\n\n\tgeneratedByDefaultAsIdentity(\n\t\tsequence?: PgSequenceOptions & { name?: string },\n\t): IsIdentity<this, 'byDefault'> {\n\t\tif (sequence) {\n\t\t\tconst { name, ...options } = sequence;\n\t\t\tthis.config.generatedIdentity = {\n\t\t\t\ttype: 'byDefault',\n\t\t\t\tsequenceName: name,\n\t\t\t\tsequenceOptions: options,\n\t\t\t};\n\t\t} else {\n\t\t\tthis.config.generatedIdentity = {\n\t\t\t\ttype: 'byDefault',\n\t\t\t};\n\t\t}\n\n\t\tthis.config.hasDefault = true;\n\t\tthis.config.notNull = true;\n\n\t\treturn this as IsIdentity<this, 'byDefault'>;\n\t}\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\n\nimport { getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn } from './common.ts';\nimport { PgIntColumnBaseBuilder } from './int.common.ts';\n\nexport type PgBigInt53BuilderInitial<TName extends string> = PgBigInt53Builder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'PgBigInt53';\n\tdata: number;\n\tdriverParam: number | string;\n\tenumValues: undefined;\n}>;\n\nexport class PgBigInt53Builder<T extends ColumnBuilderBaseConfig<'number', 'PgBigInt53'>>\n\textends PgIntColumnBaseBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgBigInt53Builder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'PgBigInt53');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgBigInt53<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgBigInt53<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgBigInt53<T extends ColumnBaseConfig<'number', 'PgBigInt53'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgBigInt53';\n\n\tgetSQLType(): string {\n\t\treturn 'bigint';\n\t}\n\n\toverride mapFromDriverValue(value: number | string): number {\n\t\tif (typeof value === 'number') {\n\t\t\treturn value;\n\t\t}\n\t\treturn Number(value);\n\t}\n}\n\nexport type PgBigInt64BuilderInitial<TName extends string> = PgBigInt64Builder<{\n\tname: TName;\n\tdataType: 'bigint';\n\tcolumnType: 'PgBigInt64';\n\tdata: bigint;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgBigInt64Builder<T extends ColumnBuilderBaseConfig<'bigint', 'PgBigInt64'>>\n\textends PgIntColumnBaseBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgBigInt64Builder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'bigint', 'PgBigInt64');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgBigInt64<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgBigInt64<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgBigInt64<T extends ColumnBaseConfig<'bigint', 'PgBigInt64'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgBigInt64';\n\n\tgetSQLType(): string {\n\t\treturn 'bigint';\n\t}\n\n\t// eslint-disable-next-line unicorn/prefer-native-coercion-functions\n\toverride mapFromDriverValue(value: string): bigint {\n\t\treturn BigInt(value);\n\t}\n}\n\nexport interface PgBigIntConfig<T extends 'number' | 'bigint' = 'number' | 'bigint'> {\n\tmode: T;\n}\n\nexport function bigint<TMode extends PgBigIntConfig['mode']>(\n\tconfig: PgBigIntConfig<TMode>,\n): TMode extends 'number' ? PgBigInt53BuilderInitial<''> : PgBigInt64BuilderInitial<''>;\nexport function bigint<TName extends string, TMode extends PgBigIntConfig['mode']>(\n\tname: TName,\n\tconfig: PgBigIntConfig<TMode>,\n): TMode extends 'number' ? PgBigInt53BuilderInitial<TName> : PgBigInt64BuilderInitial<TName>;\nexport function bigint(a: string | PgBigIntConfig, b?: PgBigIntConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgBigIntConfig>(a, b);\n\tif (config.mode === 'number') {\n\t\treturn new PgBigInt53Builder(name);\n\t}\n\treturn new PgBigInt64Builder(name);\n}\n","import type {\n\tColumnBuilderBaseConfig,\n\tColumnBuilderRuntimeConfig,\n\tHasDefault,\n\tMakeColumnConfig,\n\tNotNull,\n} from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport { getColumnNameAndConfig } from '~/utils.ts';\nimport type { AnyPgTable } from '../table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgBigSerial53BuilderInitial<TName extends string> = NotNull<\n\tHasDefault<\n\t\tPgBigSerial53Builder<{\n\t\t\tname: TName;\n\t\t\tdataType: 'number';\n\t\t\tcolumnType: 'PgBigSerial53';\n\t\t\tdata: number;\n\t\t\tdriverParam: number;\n\t\t\tenumValues: undefined;\n\t\t}>\n\t>\n>;\n\nexport class PgBigSerial53Builder<T extends ColumnBuilderBaseConfig<'number', 'PgBigSerial53'>>\n\textends PgColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgBigSerial53Builder';\n\n\tconstructor(name: string) {\n\t\tsuper(name, 'number', 'PgBigSerial53');\n\t\tthis.config.hasDefault = true;\n\t\tthis.config.notNull = true;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgBigSerial53<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgBigSerial53<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgBigSerial53<T extends ColumnBaseConfig<'number', 'PgBigSerial53'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgBigSerial53';\n\n\tgetSQLType(): string {\n\t\treturn 'bigserial';\n\t}\n\n\toverride mapFromDriverValue(value: number): number {\n\t\tif (typeof value === 'number') {\n\t\t\treturn value;\n\t\t}\n\t\treturn Number(value);\n\t}\n}\n\nexport type PgBigSerial64BuilderInitial<TName extends string> = NotNull<\n\tHasDefault<\n\t\tPgBigSerial64Builder<{\n\t\t\tname: TName;\n\t\t\tdataType: 'bigint';\n\t\t\tcolumnType: 'PgBigSerial64';\n\t\t\tdata: bigint;\n\t\t\tdriverParam: string;\n\t\t\tenumValues: undefined;\n\t\t}>\n\t>\n>;\n\nexport class PgBigSerial64Builder<T extends ColumnBuilderBaseConfig<'bigint', 'PgBigSerial64'>>\n\textends PgColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgBigSerial64Builder';\n\n\tconstructor(name: string) {\n\t\tsuper(name, 'bigint', 'PgBigSerial64');\n\t\tthis.config.hasDefault = true;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgBigSerial64<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgBigSerial64<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgBigSerial64<T extends ColumnBaseConfig<'bigint', 'PgBigSerial64'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgBigSerial64';\n\n\tgetSQLType(): string {\n\t\treturn 'bigserial';\n\t}\n\n\t// eslint-disable-next-line unicorn/prefer-native-coercion-functions\n\toverride mapFromDriverValue(value: string): bigint {\n\t\treturn BigInt(value);\n\t}\n}\n\nexport interface PgBigSerialConfig<T extends 'number' | 'bigint' = 'number' | 'bigint'> {\n\tmode: T;\n}\n\nexport function bigserial<TMode extends PgBigSerialConfig['mode']>(\n\tconfig: PgBigSerialConfig<TMode>,\n): TMode extends 'number' ? PgBigSerial53BuilderInitial<''> : PgBigSerial64BuilderInitial<''>;\nexport function bigserial<TName extends string, TMode extends PgBigSerialConfig['mode']>(\n\tname: TName,\n\tconfig: PgBigSerialConfig<TMode>,\n): TMode extends 'number' ? PgBigSerial53BuilderInitial<TName> : PgBigSerial64BuilderInitial<TName>;\nexport function bigserial(a: string | PgBigSerialConfig, b?: PgBigSerialConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgBigSerialConfig>(a, b);\n\tif (config.mode === 'number') {\n\t\treturn new PgBigSerial53Builder(name);\n\t}\n\treturn new PgBigSerial64Builder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgBooleanBuilderInitial<TName extends string> = PgBooleanBuilder<{\n\tname: TName;\n\tdataType: 'boolean';\n\tcolumnType: 'PgBoolean';\n\tdata: boolean;\n\tdriverParam: boolean;\n\tenumValues: undefined;\n}>;\n\nexport class PgBooleanBuilder<T extends ColumnBuilderBaseConfig<'boolean', 'PgBoolean'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgBooleanBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'boolean', 'PgBoolean');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgBoolean<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgBoolean<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgBoolean<T extends ColumnBaseConfig<'boolean', 'PgBoolean'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgBoolean';\n\n\tgetSQLType(): string {\n\t\treturn 'boolean';\n\t}\n}\n\nexport function boolean(): PgBooleanBuilderInitial<''>;\nexport function boolean<TName extends string>(name: TName): PgBooleanBuilderInitial<TName>;\nexport function boolean(name?: string) {\n\treturn new PgBooleanBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { getColumnNameAndConfig, type Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgCharBuilderInitial<\n\tTName extends string,\n\tTEnum extends [string, ...string[]],\n\tTLength extends number | undefined,\n> = PgCharBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgChar';\n\tdata: TEnum[number];\n\tenumValues: TEnum;\n\tdriverParam: string;\n\tlength: TLength;\n}>;\n\nexport class PgCharBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgChar'> & { length?: number | undefined }>\n\textends PgColumnBuilder<\n\t\tT,\n\t\t{ length: T['length']; enumValues: T['enumValues'] },\n\t\t{ length: T['length'] }\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgCharBuilder';\n\n\tconstructor(name: T['name'], config: PgCharConfig<T['enumValues'], T['length']>) {\n\t\tsuper(name, 'string', 'PgChar');\n\t\tthis.config.length = config.length;\n\t\tthis.config.enumValues = config.enum;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgChar<MakeColumnConfig<T, TTableName> & { length: T['length'] }> {\n\t\treturn new PgChar<MakeColumnConfig<T, TTableName> & { length: T['length'] }>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgChar<T extends ColumnBaseConfig<'string', 'PgChar'> & { length?: number | undefined }>\n\textends PgColumn<T, { length: T['length']; enumValues: T['enumValues'] }, { length: T['length'] }>\n{\n\tstatic override readonly [entityKind]: string = 'PgChar';\n\n\treadonly length = this.config.length;\n\toverride readonly enumValues = this.config.enumValues;\n\n\tgetSQLType(): string {\n\t\treturn this.length === undefined ? `char` : `char(${this.length})`;\n\t}\n}\n\nexport interface PgCharConfig<\n\tTEnum extends readonly string[] | string[] | undefined = readonly string[] | string[] | undefined,\n\tTLength extends number | undefined = number | undefined,\n> {\n\tenum?: TEnum;\n\tlength?: TLength;\n}\n\nexport function char(): PgCharBuilderInitial<'', [string, ...string[]], undefined>;\nexport function char<U extends string, T extends Readonly<[U, ...U[]]>, L extends number | undefined>(\n\tconfig?: PgCharConfig<T | Writable<T>, L>,\n): PgCharBuilderInitial<'', Writable<T>, L>;\nexport function char<\n\tTName extends string,\n\tU extends string,\n\tT extends Readonly<[U, ...U[]]>,\n\tL extends number | undefined,\n>(\n\tname: TName,\n\tconfig?: PgCharConfig<T | Writable<T>, L>,\n): PgCharBuilderInitial<TName, Writable<T>, L>;\nexport function char(a?: string | PgCharConfig, b: PgCharConfig = {}): any {\n\tconst { name, config } = getColumnNameAndConfig<PgCharConfig>(a, b);\n\treturn new PgCharBuilder(name, config as any);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '../table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgCidrBuilderInitial<TName extends string> = PgCidrBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgCidr';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgCidrBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgCidr'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgCidrBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgCidr');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgCidr<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgCidr<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgCidr<T extends ColumnBaseConfig<'string', 'PgCidr'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgCidr';\n\n\tgetSQLType(): string {\n\t\treturn 'cidr';\n\t}\n}\n\nexport function cidr(): PgCidrBuilderInitial<''>;\nexport function cidr<TName extends string>(name: TName): PgCidrBuilderInitial<TName>;\nexport function cidr(name?: string) {\n\treturn new PgCidrBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport type { SQL } from '~/sql/sql.ts';\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type ConvertCustomConfig<TName extends string, T extends Partial<CustomTypeValues>> =\n\t& {\n\t\tname: TName;\n\t\tdataType: 'custom';\n\t\tcolumnType: 'PgCustomColumn';\n\t\tdata: T['data'];\n\t\tdriverParam: T['driverData'];\n\t\tenumValues: undefined;\n\t}\n\t& (T['notNull'] extends true ? { notNull: true } : {})\n\t& (T['default'] extends true ? { hasDefault: true } : {});\n\nexport interface PgCustomColumnInnerConfig {\n\tcustomTypeValues: CustomTypeValues;\n}\n\nexport class PgCustomColumnBuilder<T extends ColumnBuilderBaseConfig<'custom', 'PgCustomColumn'>>\n\textends PgColumnBuilder<\n\t\tT,\n\t\t{\n\t\t\tfieldConfig: CustomTypeValues['config'];\n\t\t\tcustomTypeParams: CustomTypeParams<any>;\n\t\t},\n\t\t{\n\t\t\tpgColumnBuilderBrand: 'PgCustomColumnBuilderBrand';\n\t\t}\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgCustomColumnBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\tfieldConfig: CustomTypeValues['config'],\n\t\tcustomTypeParams: CustomTypeParams<any>,\n\t) {\n\t\tsuper(name, 'custom', 'PgCustomColumn');\n\t\tthis.config.fieldConfig = fieldConfig;\n\t\tthis.config.customTypeParams = customTypeParams;\n\t}\n\n\t/** @internal */\n\tbuild<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgCustomColumn<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgCustomColumn<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgCustomColumn<T extends ColumnBaseConfig<'custom', 'PgCustomColumn'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgCustomColumn';\n\n\tprivate sqlName: string;\n\tprivate mapTo?: (value: T['data']) => T['driverParam'];\n\tprivate mapFrom?: (value: T['driverParam']) => T['data'];\n\n\tconstructor(\n\t\ttable: AnyPgTable<{ name: T['tableName'] }>,\n\t\tconfig: PgCustomColumnBuilder<T>['config'],\n\t) {\n\t\tsuper(table, config);\n\t\tthis.sqlName = config.customTypeParams.dataType(config.fieldConfig);\n\t\tthis.mapTo = config.customTypeParams.toDriver;\n\t\tthis.mapFrom = config.customTypeParams.fromDriver;\n\t}\n\n\tgetSQLType(): string {\n\t\treturn this.sqlName;\n\t}\n\n\toverride mapFromDriverValue(value: T['driverParam']): T['data'] {\n\t\treturn typeof this.mapFrom === 'function' ? this.mapFrom(value) : value as T['data'];\n\t}\n\n\toverride mapToDriverValue(value: T['data']): T['driverParam'] {\n\t\treturn typeof this.mapTo === 'function' ? this.mapTo(value) : value as T['data'];\n\t}\n}\n\nexport type CustomTypeValues = {\n\t/**\n\t * Required type for custom column, that will infer proper type model\n\t *\n\t * Examples:\n\t *\n\t * If you want your column to be `string` type after selecting/or on inserting - use `data: string`. Like `text`, `varchar`\n\t *\n\t * If you want your column to be `number` type after selecting/or on inserting - use `data: number`. Like `integer`\n\t */\n\tdata: unknown;\n\n\t/**\n\t * Type helper, that represents what type database driver is accepting for specific database data type\n\t */\n\tdriverData?: unknown;\n\n\t/**\n\t * What config type should be used for {@link CustomTypeParams} `dataType` generation\n\t */\n\tconfig?: Record<string, any>;\n\n\t/**\n\t * Whether the config argument should be required or not\n\t * @default false\n\t */\n\tconfigRequired?: boolean;\n\n\t/**\n\t * If your custom data type should be notNull by default you can use `notNull: true`\n\t *\n\t * @example\n\t * const customSerial = customType<{ data: number, notNull: true, default: true }>({\n\t * \t  dataType() {\n\t * \t    return 'serial';\n\t *    },\n\t * });\n\t */\n\tnotNull?: boolean;\n\n\t/**\n\t * If your custom data type has default you can use `default: true`\n\t *\n\t * @example\n\t * const customSerial = customType<{ data: number, notNull: true, default: true }>({\n\t * \t  dataType() {\n\t * \t    return 'serial';\n\t *    },\n\t * });\n\t */\n\tdefault?: boolean;\n};\n\nexport interface CustomTypeParams<T extends CustomTypeValues> {\n\t/**\n\t * Database data type string representation, that is used for migrations\n\t * @example\n\t * ```\n\t * `jsonb`, `text`\n\t * ```\n\t *\n\t * If database data type needs additional params you can use them from `config` param\n\t * @example\n\t * ```\n\t * `varchar(256)`, `numeric(2,3)`\n\t * ```\n\t *\n\t * To make `config` be of specific type please use config generic in {@link CustomTypeValues}\n\t *\n\t * @example\n\t * Usage example\n\t * ```\n\t *   dataType() {\n\t *     return 'boolean';\n\t *   },\n\t * ```\n\t * Or\n\t * ```\n\t *   dataType(config) {\n\t * \t   return typeof config.length !== 'undefined' ? `varchar(${config.length})` : `varchar`;\n\t * \t }\n\t * ```\n\t */\n\tdataType: (config: T['config'] | (Equal<T['configRequired'], true> extends true ? never : undefined)) => string;\n\n\t/**\n\t * Optional mapping function, between user input and driver\n\t * @example\n\t * For example, when using jsonb we need to map JS/TS object to string before writing to database\n\t * ```\n\t * toDriver(value: TData): string {\n\t * \t return JSON.stringify(value);\n\t * }\n\t * ```\n\t */\n\ttoDriver?: (value: T['data']) => T['driverData'] | SQL;\n\n\t/**\n\t * Optional mapping function, that is responsible for data mapping from database to JS/TS code\n\t * @example\n\t * For example, when using timestamp we need to map string Date representation to JS Date\n\t * ```\n\t * fromDriver(value: string): Date {\n\t * \treturn new Date(value);\n\t * },\n\t * ```\n\t */\n\tfromDriver?: (value: T['driverData']) => T['data'];\n}\n\n/**\n * Custom pg database data type generator\n */\nexport function customType<T extends CustomTypeValues = CustomTypeValues>(\n\tcustomTypeParams: CustomTypeParams<T>,\n): Equal<T['configRequired'], true> extends true ? {\n\t\t<TConfig extends Record<string, any> & T['config']>(\n\t\t\tfieldConfig: TConfig,\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TName extends string>(\n\t\t\tdbName: TName,\n\t\t\tfieldConfig: T['config'],\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<TName, T>>;\n\t}\n\t: {\n\t\t(): PgCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TConfig extends Record<string, any> & T['config']>(\n\t\t\tfieldConfig?: TConfig,\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<'', T>>;\n\t\t<TName extends string>(\n\t\t\tdbName: TName,\n\t\t\tfieldConfig?: T['config'],\n\t\t): PgCustomColumnBuilder<ConvertCustomConfig<TName, T>>;\n\t}\n{\n\treturn <TName extends string>(\n\t\ta?: TName | T['config'],\n\t\tb?: T['config'],\n\t): PgCustomColumnBuilder<ConvertCustomConfig<TName, T>> => {\n\t\tconst { name, config } = getColumnNameAndConfig<T['config']>(a, b);\n\t\treturn new PgCustomColumnBuilder(name as ConvertCustomConfig<TName, T>['name'], config, customTypeParams);\n\t};\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgDoublePrecisionBuilderInitial<TName extends string> = PgDoublePrecisionBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'PgDoublePrecision';\n\tdata: number;\n\tdriverParam: string | number;\n\tenumValues: undefined;\n}>;\n\nexport class PgDoublePrecisionBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgDoublePrecision'>>\n\textends PgColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgDoublePrecisionBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'PgDoublePrecision');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgDoublePrecision<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgDoublePrecision<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgDoublePrecision<T extends ColumnBaseConfig<'number', 'PgDoublePrecision'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgDoublePrecision';\n\n\tgetSQLType(): string {\n\t\treturn 'double precision';\n\t}\n\n\toverride mapFromDriverValue(value: string | number): number {\n\t\tif (typeof value === 'string') {\n\t\t\treturn Number.parseFloat(value);\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function doublePrecision(): PgDoublePrecisionBuilderInitial<''>;\nexport function doublePrecision<TName extends string>(name: TName): PgDoublePrecisionBuilderInitial<TName>;\nexport function doublePrecision(name?: string) {\n\treturn new PgDoublePrecisionBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '../table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgInetBuilderInitial<TName extends string> = PgInetBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgInet';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgInetBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgInet'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgInetBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgInet');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgInet<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgInet<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgInet<T extends ColumnBaseConfig<'string', 'PgInet'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgInet';\n\n\tgetSQLType(): string {\n\t\treturn 'inet';\n\t}\n}\n\nexport function inet(): PgInetBuilderInitial<''>;\nexport function inet<TName extends string>(name: TName): PgInetBuilderInitial<TName>;\nexport function inet(name?: string) {\n\treturn new PgInetBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '../table.ts';\nimport { PgColumn } from './common.ts';\nimport { PgIntColumnBaseBuilder } from './int.common.ts';\n\nexport type PgIntegerBuilderInitial<TName extends string> = PgIntegerBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'PgInteger';\n\tdata: number;\n\tdriverParam: number | string;\n\tenumValues: undefined;\n}>;\n\nexport class PgIntegerBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgInteger'>>\n\textends PgIntColumnBaseBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgIntegerBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'PgInteger');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgInteger<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgInteger<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgInteger<T extends ColumnBaseConfig<'number', 'PgInteger'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgInteger';\n\n\tgetSQLType(): string {\n\t\treturn 'integer';\n\t}\n\n\toverride mapFromDriverValue(value: number | string): number {\n\t\tif (typeof value === 'string') {\n\t\t\treturn Number.parseInt(value);\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport function integer(): PgIntegerBuilderInitial<''>;\nexport function integer<TName extends string>(name: TName): PgIntegerBuilderInitial<TName>;\nexport function integer(name?: string) {\n\treturn new PgIntegerBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\nimport type { Precision } from './timestamp.ts';\n\nexport type PgIntervalBuilderInitial<TName extends string> = PgIntervalBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgInterval';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgIntervalBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgInterval'>>\n\textends PgColumnBuilder<T, { intervalConfig: IntervalConfig }>\n{\n\tstatic override readonly [entityKind]: string = 'PgIntervalBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\tintervalConfig: IntervalConfig,\n\t) {\n\t\tsuper(name, 'string', 'PgInterval');\n\t\tthis.config.intervalConfig = intervalConfig;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgInterval<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgInterval<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgInterval<T extends ColumnBaseConfig<'string', 'PgInterval'>>\n\textends PgColumn<T, { intervalConfig: IntervalConfig }>\n{\n\tstatic override readonly [entityKind]: string = 'PgInterval';\n\n\treadonly fields: IntervalConfig['fields'] = this.config.intervalConfig.fields;\n\treadonly precision: IntervalConfig['precision'] = this.config.intervalConfig.precision;\n\n\tgetSQLType(): string {\n\t\tconst fields = this.fields ? ` ${this.fields}` : '';\n\t\tconst precision = this.precision ? `(${this.precision})` : '';\n\t\treturn `interval${fields}${precision}`;\n\t}\n}\n\nexport interface IntervalConfig {\n\tfields?:\n\t\t| 'year'\n\t\t| 'month'\n\t\t| 'day'\n\t\t| 'hour'\n\t\t| 'minute'\n\t\t| 'second'\n\t\t| 'year to month'\n\t\t| 'day to hour'\n\t\t| 'day to minute'\n\t\t| 'day to second'\n\t\t| 'hour to minute'\n\t\t| 'hour to second'\n\t\t| 'minute to second';\n\tprecision?: Precision;\n}\n\nexport function interval(): PgIntervalBuilderInitial<''>;\nexport function interval(\n\tconfig?: IntervalConfig,\n): PgIntervalBuilderInitial<''>;\nexport function interval<TName extends string>(\n\tname: TName,\n\tconfig?: IntervalConfig,\n): PgIntervalBuilderInitial<TName>;\nexport function interval(a?: string | IntervalConfig, b: IntervalConfig = {}) {\n\tconst { name, config } = getColumnNameAndConfig<IntervalConfig>(a, b);\n\treturn new PgIntervalBuilder(name, config);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\n\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgLineBuilderInitial<TName extends string> = PgLineBuilder<{\n\tname: TName;\n\tdataType: 'array';\n\tcolumnType: 'PgLine';\n\tdata: [number, number, number];\n\tdriverParam: number | string;\n\tenumValues: undefined;\n}>;\n\nexport class PgLineBuilder<T extends ColumnBuilderBaseConfig<'array', 'PgLine'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgLineBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'array', 'PgLine');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgLineTuple<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgLineTuple<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgLineTuple<T extends ColumnBaseConfig<'array', 'PgLine'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgLine';\n\n\tgetSQLType(): string {\n\t\treturn 'line';\n\t}\n\n\toverride mapFromDriverValue(value: string): [number, number, number] {\n\t\tconst [a, b, c] = value.slice(1, -1).split(',');\n\t\treturn [Number.parseFloat(a!), Number.parseFloat(b!), Number.parseFloat(c!)];\n\t}\n\n\toverride mapToDriverValue(value: [number, number, number]): string {\n\t\treturn `{${value[0]},${value[1]},${value[2]}}`;\n\t}\n}\n\nexport type PgLineABCBuilderInitial<TName extends string> = PgLineABCBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'PgLineABC';\n\tdata: { a: number; b: number; c: number };\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgLineABCBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgLineABC'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgLineABCBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'PgLineABC');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgLineABC<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgLineABC<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgLineABC<T extends ColumnBaseConfig<'json', 'PgLineABC'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgLineABC';\n\n\tgetSQLType(): string {\n\t\treturn 'line';\n\t}\n\n\toverride mapFromDriverValue(value: string): { a: number; b: number; c: number } {\n\t\tconst [a, b, c] = value.slice(1, -1).split(',');\n\t\treturn { a: Number.parseFloat(a!), b: Number.parseFloat(b!), c: Number.parseFloat(c!) };\n\t}\n\n\toverride mapToDriverValue(value: { a: number; b: number; c: number }): string {\n\t\treturn `{${value.a},${value.b},${value.c}}`;\n\t}\n}\n\nexport interface PgLineTypeConfig<T extends 'tuple' | 'abc' = 'tuple' | 'abc'> {\n\tmode?: T;\n}\n\nexport function line(): PgLineBuilderInitial<''>;\nexport function line<TMode extends PgLineTypeConfig['mode'] & {}>(\n\tconfig?: PgLineTypeConfig<TMode>,\n): Equal<TMode, 'abc'> extends true ? PgLineABCBuilderInitial<''>\n\t: PgLineBuilderInitial<''>;\nexport function line<TName extends string, TMode extends PgLineTypeConfig['mode'] & {}>(\n\tname: TName,\n\tconfig?: PgLineTypeConfig<TMode>,\n): Equal<TMode, 'abc'> extends true ? PgLineABCBuilderInitial<TName>\n\t: PgLineBuilderInitial<TName>;\nexport function line(a?: string | PgLineTypeConfig, b?: PgLineTypeConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgLineTypeConfig>(a, b);\n\tif (!config?.mode || config.mode === 'tuple') {\n\t\treturn new PgLineBuilder(name);\n\t}\n\treturn new PgLineABCBuilder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '../table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgMacaddrBuilderInitial<TName extends string> = PgMacaddrBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgMacaddr';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgMacaddrBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgMacaddr'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgMacaddrBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgMacaddr');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgMacaddr<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgMacaddr<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgMacaddr<T extends ColumnBaseConfig<'string', 'PgMacaddr'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgMacaddr';\n\n\tgetSQLType(): string {\n\t\treturn 'macaddr';\n\t}\n}\n\nexport function macaddr(): PgMacaddrBuilderInitial<''>;\nexport function macaddr<TName extends string>(name: TName): PgMacaddrBuilderInitial<TName>;\nexport function macaddr(name?: string) {\n\treturn new PgMacaddrBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '../table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgMacaddr8BuilderInitial<TName extends string> = PgMacaddr8Builder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgMacaddr8';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgMacaddr8Builder<T extends ColumnBuilderBaseConfig<'string', 'PgMacaddr8'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgMacaddr8Builder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'string', 'PgMacaddr8');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgMacaddr8<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgMacaddr8<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgMacaddr8<T extends ColumnBaseConfig<'string', 'PgMacaddr8'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgMacaddr8';\n\n\tgetSQLType(): string {\n\t\treturn 'macaddr8';\n\t}\n}\n\nexport function macaddr8(): PgMacaddr8BuilderInitial<''>;\nexport function macaddr8<TName extends string>(name: TName): PgMacaddr8BuilderInitial<TName>;\nexport function macaddr8(name?: string) {\n\treturn new PgMacaddr8Builder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\n\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgPointTupleBuilderInitial<TName extends string> = PgPointTupleBuilder<{\n\tname: TName;\n\tdataType: 'array';\n\tcolumnType: 'PgPointTuple';\n\tdata: [number, number];\n\tdriverParam: number | string;\n\tenumValues: undefined;\n}>;\n\nexport class PgPointTupleBuilder<T extends ColumnBuilderBaseConfig<'array', 'PgPointTuple'>>\n\textends PgColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgPointTupleBuilder';\n\n\tconstructor(name: string) {\n\t\tsuper(name, 'array', 'PgPointTuple');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgPointTuple<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgPointTuple<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgPointTuple<T extends ColumnBaseConfig<'array', 'PgPointTuple'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgPointTuple';\n\n\tgetSQLType(): string {\n\t\treturn 'point';\n\t}\n\n\toverride mapFromDriverValue(value: string | { x: number; y: number }): [number, number] {\n\t\tif (typeof value === 'string') {\n\t\t\tconst [x, y] = value.slice(1, -1).split(',');\n\t\t\treturn [Number.parseFloat(x!), Number.parseFloat(y!)];\n\t\t}\n\t\treturn [value.x, value.y];\n\t}\n\n\toverride mapToDriverValue(value: [number, number]): string {\n\t\treturn `(${value[0]},${value[1]})`;\n\t}\n}\n\nexport type PgPointObjectBuilderInitial<TName extends string> = PgPointObjectBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'PgPointObject';\n\tdata: { x: number; y: number };\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgPointObjectBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgPointObject'>>\n\textends PgColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgPointObjectBuilder';\n\n\tconstructor(name: string) {\n\t\tsuper(name, 'json', 'PgPointObject');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgPointObject<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgPointObject<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgPointObject<T extends ColumnBaseConfig<'json', 'PgPointObject'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgPointObject';\n\n\tgetSQLType(): string {\n\t\treturn 'point';\n\t}\n\n\toverride mapFromDriverValue(value: string | { x: number; y: number }): { x: number; y: number } {\n\t\tif (typeof value === 'string') {\n\t\t\tconst [x, y] = value.slice(1, -1).split(',');\n\t\t\treturn { x: Number.parseFloat(x!), y: Number.parseFloat(y!) };\n\t\t}\n\t\treturn value;\n\t}\n\n\toverride mapToDriverValue(value: { x: number; y: number }): string {\n\t\treturn `(${value.x},${value.y})`;\n\t}\n}\n\nexport interface PgPointConfig<T extends 'tuple' | 'xy' = 'tuple' | 'xy'> {\n\tmode?: T;\n}\n\nexport function point(): PgPointTupleBuilderInitial<''>;\nexport function point<TMode extends PgPointConfig['mode'] & {}>(\n\tconfig?: PgPointConfig<TMode>,\n): Equal<TMode, 'xy'> extends true ? PgPointObjectBuilderInitial<''>\n\t: PgPointTupleBuilderInitial<''>;\nexport function point<TName extends string, TMode extends PgPointConfig['mode'] & {}>(\n\tname: TName,\n\tconfig?: PgPointConfig<TMode>,\n): Equal<TMode, 'xy'> extends true ? PgPointObjectBuilderInitial<TName>\n\t: PgPointTupleBuilderInitial<TName>;\nexport function point(a?: string | PgPointConfig, b?: PgPointConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgPointConfig>(a, b);\n\tif (!config?.mode || config.mode === 'tuple') {\n\t\treturn new PgPointTupleBuilder(name);\n\t}\n\treturn new PgPointObjectBuilder(name);\n}\n","function hexToBytes(hex: string): Uint8Array {\n\tconst bytes: number[] = [];\n\tfor (let c = 0; c < hex.length; c += 2) {\n\t\tbytes.push(Number.parseInt(hex.slice(c, c + 2), 16));\n\t}\n\treturn new Uint8Array(bytes);\n}\n\nfunction bytesToFloat64(bytes: Uint8Array, offset: number): number {\n\tconst buffer = new ArrayBuffer(8);\n\tconst view = new DataView(buffer);\n\tfor (let i = 0; i < 8; i++) {\n\t\tview.setUint8(i, bytes[offset + i]!);\n\t}\n\treturn view.getFloat64(0, true);\n}\n\nexport function parseEWKB(hex: string): [number, number] {\n\tconst bytes = hexToBytes(hex);\n\n\tlet offset = 0;\n\n\t// Byte order: 1 is little-endian, 0 is big-endian\n\tconst byteOrder = bytes[offset];\n\toffset += 1;\n\n\tconst view = new DataView(bytes.buffer);\n\tconst geomType = view.getUint32(offset, byteOrder === 1);\n\toffset += 4;\n\n\tlet _srid: number | undefined;\n\tif (geomType & 0x20000000) { // SRID flag\n\t\t_srid = view.getUint32(offset, byteOrder === 1);\n\t\toffset += 4;\n\t}\n\n\tif ((geomType & 0xFFFF) === 1) {\n\t\tconst x = bytesToFloat64(bytes, offset);\n\t\toffset += 8;\n\t\tconst y = bytesToFloat64(bytes, offset);\n\t\toffset += 8;\n\n\t\treturn [x, y];\n\t}\n\n\tthrow new Error('Unsupported geometry type');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\n\nimport { type Equal, getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from '../common.ts';\nimport { parseEWKB } from './utils.ts';\n\nexport type PgGeometryBuilderInitial<TName extends string> = PgGeometryBuilder<{\n\tname: TName;\n\tdataType: 'array';\n\tcolumnType: 'PgGeometry';\n\tdata: [number, number];\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgGeometryBuilder<T extends ColumnBuilderBaseConfig<'array', 'PgGeometry'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgGeometryBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'array', 'PgGeometry');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgGeometry<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgGeometry<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgGeometry<T extends ColumnBaseConfig<'array', 'PgGeometry'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgGeometry';\n\n\tgetSQLType(): string {\n\t\treturn 'geometry(point)';\n\t}\n\n\toverride mapFromDriverValue(value: string): [number, number] {\n\t\treturn parseEWKB(value);\n\t}\n\n\toverride mapToDriverValue(value: [number, number]): string {\n\t\treturn `point(${value[0]} ${value[1]})`;\n\t}\n}\n\nexport type PgGeometryObjectBuilderInitial<TName extends string> = PgGeometryObjectBuilder<{\n\tname: TName;\n\tdataType: 'json';\n\tcolumnType: 'PgGeometryObject';\n\tdata: { x: number; y: number };\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgGeometryObjectBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgGeometryObject'>>\n\textends PgColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgGeometryObjectBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'json', 'PgGeometryObject');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgGeometryObject<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgGeometryObject<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgGeometryObject<T extends ColumnBaseConfig<'json', 'PgGeometryObject'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgGeometryObject';\n\n\tgetSQLType(): string {\n\t\treturn 'geometry(point)';\n\t}\n\n\toverride mapFromDriverValue(value: string): { x: number; y: number } {\n\t\tconst parsed = parseEWKB(value);\n\t\treturn { x: parsed[0], y: parsed[1] };\n\t}\n\n\toverride mapToDriverValue(value: { x: number; y: number }): string {\n\t\treturn `point(${value.x} ${value.y})`;\n\t}\n}\n\nexport interface PgGeometryConfig<T extends 'tuple' | 'xy' = 'tuple' | 'xy'> {\n\tmode?: T;\n\ttype?: 'point' | (string & {});\n\tsrid?: number;\n}\n\nexport function geometry(): PgGeometryBuilderInitial<''>;\nexport function geometry<TMode extends PgGeometryConfig['mode'] & {}>(\n\tconfig?: PgGeometryConfig<TMode>,\n): Equal<TMode, 'xy'> extends true ? PgGeometryObjectBuilderInitial<''> : PgGeometryBuilderInitial<''>;\nexport function geometry<TName extends string, TMode extends PgGeometryConfig['mode'] & {}>(\n\tname: TName,\n\tconfig?: PgGeometryConfig<TMode>,\n): Equal<TMode, 'xy'> extends true ? PgGeometryObjectBuilderInitial<TName> : PgGeometryBuilderInitial<TName>;\nexport function geometry(a?: string | PgGeometryConfig, b?: PgGeometryConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgGeometryConfig>(a, b);\n\tif (!config?.mode || config.mode === 'tuple') {\n\t\treturn new PgGeometryBuilder(name);\n\t}\n\treturn new PgGeometryObjectBuilder(name);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgRealBuilderInitial<TName extends string> = PgRealBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'PgReal';\n\tdata: number;\n\tdriverParam: string | number;\n\tenumValues: undefined;\n}>;\n\nexport class PgRealBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgReal'>> extends PgColumnBuilder<\n\tT,\n\t{ length: number | undefined }\n> {\n\tstatic override readonly [entityKind]: string = 'PgRealBuilder';\n\n\tconstructor(name: T['name'], length?: number) {\n\t\tsuper(name, 'number', 'PgReal');\n\t\tthis.config.length = length;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgReal<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgReal<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgReal<T extends ColumnBaseConfig<'number', 'PgReal'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgReal';\n\n\tconstructor(table: AnyPgTable<{ name: T['tableName'] }>, config: PgRealBuilder<T>['config']) {\n\t\tsuper(table, config);\n\t}\n\n\tgetSQLType(): string {\n\t\treturn 'real';\n\t}\n\n\toverride mapFromDriverValue = (value: string | number): number => {\n\t\tif (typeof value === 'string') {\n\t\t\treturn Number.parseFloat(value);\n\t\t}\n\t\treturn value;\n\t};\n}\n\nexport function real(): PgRealBuilderInitial<''>;\nexport function real<TName extends string>(name: TName): PgRealBuilderInitial<TName>;\nexport function real(name?: string) {\n\treturn new PgRealBuilder(name ?? '');\n}\n","import type {\n\tColumnBuilderBaseConfig,\n\tColumnBuilderRuntimeConfig,\n\tHasDefault,\n\tMakeColumnConfig,\n\tNotNull,\n} from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgSerialBuilderInitial<TName extends string> = NotNull<\n\tHasDefault<\n\t\tPgSerialBuilder<{\n\t\t\tname: TName;\n\t\t\tdataType: 'number';\n\t\t\tcolumnType: 'PgSerial';\n\t\t\tdata: number;\n\t\t\tdriverParam: number;\n\t\t\tenumValues: undefined;\n\t\t}>\n\t>\n>;\n\nexport class PgSerialBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgSerial'>> extends PgColumnBuilder<T> {\n\tstatic override readonly [entityKind]: string = 'PgSerialBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'PgSerial');\n\t\tthis.config.hasDefault = true;\n\t\tthis.config.notNull = true;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgSerial<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgSerial<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgSerial<T extends ColumnBaseConfig<'number', 'PgSerial'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgSerial';\n\n\tgetSQLType(): string {\n\t\treturn 'serial';\n\t}\n}\n\nexport function serial(): PgSerialBuilderInitial<''>;\nexport function serial<TName extends string>(name: TName): PgSerialBuilderInitial<TName>;\nexport function serial(name?: string) {\n\treturn new PgSerialBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn } from './common.ts';\nimport { PgIntColumnBaseBuilder } from './int.common.ts';\n\nexport type PgSmallIntBuilderInitial<TName extends string> = PgSmallIntBuilder<{\n\tname: TName;\n\tdataType: 'number';\n\tcolumnType: 'PgSmallInt';\n\tdata: number;\n\tdriverParam: number | string;\n\tenumValues: undefined;\n}>;\n\nexport class PgSmallIntBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgSmallInt'>>\n\textends PgIntColumnBaseBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgSmallIntBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'PgSmallInt');\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgSmallInt<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgSmallInt<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgSmallInt<T extends ColumnBaseConfig<'number', 'PgSmallInt'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgSmallInt';\n\n\tgetSQLType(): string {\n\t\treturn 'smallint';\n\t}\n\n\toverride mapFromDriverValue = (value: number | string): number => {\n\t\tif (typeof value === 'string') {\n\t\t\treturn Number(value);\n\t\t}\n\t\treturn value;\n\t};\n}\n\nexport function smallint(): PgSmallIntBuilderInitial<''>;\nexport function smallint<TName extends string>(name: TName): PgSmallIntBuilderInitial<TName>;\nexport function smallint(name?: string) {\n\treturn new PgSmallIntBuilder(name ?? '');\n}\n","import type {\n\tColumnBuilderBaseConfig,\n\tColumnBuilderRuntimeConfig,\n\tHasDefault,\n\tMakeColumnConfig,\n\tNotNull,\n} from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgSmallSerialBuilderInitial<TName extends string> = NotNull<\n\tHasDefault<\n\t\tPgSmallSerialBuilder<{\n\t\t\tname: TName;\n\t\t\tdataType: 'number';\n\t\t\tcolumnType: 'PgSmallSerial';\n\t\t\tdata: number;\n\t\t\tdriverParam: number;\n\t\t\tenumValues: undefined;\n\t\t}>\n\t>\n>;\n\nexport class PgSmallSerialBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgSmallSerial'>>\n\textends PgColumnBuilder<T>\n{\n\tstatic override readonly [entityKind]: string = 'PgSmallSerialBuilder';\n\n\tconstructor(name: T['name']) {\n\t\tsuper(name, 'number', 'PgSmallSerial');\n\t\tthis.config.hasDefault = true;\n\t\tthis.config.notNull = true;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgSmallSerial<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgSmallSerial<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgSmallSerial<T extends ColumnBaseConfig<'number', 'PgSmallSerial'>> extends PgColumn<T> {\n\tstatic override readonly [entityKind]: string = 'PgSmallSerial';\n\n\tgetSQLType(): string {\n\t\treturn 'smallserial';\n\t}\n}\n\nexport function smallserial(): PgSmallSerialBuilderInitial<''>;\nexport function smallserial<TName extends string>(name: TName): PgSmallSerialBuilderInitial<TName>;\nexport function smallserial(name?: string) {\n\treturn new PgSmallSerialBuilder(name ?? '');\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { getColumnNameAndConfig, type Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgTextBuilderInitial<TName extends string, TEnum extends [string, ...string[]]> = PgTextBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgText';\n\tdata: TEnum[number];\n\tenumValues: TEnum;\n\tdriverParam: string;\n}>;\n\nexport class PgTextBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgText'>,\n> extends PgColumnBuilder<T, { enumValues: T['enumValues'] }> {\n\tstatic override readonly [entityKind]: string = 'PgTextBuilder';\n\n\tconstructor(\n\t\tname: T['name'],\n\t\tconfig: PgTextConfig<T['enumValues']>,\n\t) {\n\t\tsuper(name, 'string', 'PgText');\n\t\tthis.config.enumValues = config.enum;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgText<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgText<MakeColumnConfig<T, TTableName>>(table, this.config as ColumnBuilderRuntimeConfig<any, any>);\n\t}\n}\n\nexport class PgText<T extends ColumnBaseConfig<'string', 'PgText'>>\n\textends PgColumn<T, { enumValues: T['enumValues'] }>\n{\n\tstatic override readonly [entityKind]: string = 'PgText';\n\n\toverride readonly enumValues = this.config.enumValues;\n\n\tgetSQLType(): string {\n\t\treturn 'text';\n\t}\n}\n\nexport interface PgTextConfig<\n\tTEnum extends readonly string[] | string[] | undefined = readonly string[] | string[] | undefined,\n> {\n\tenum?: TEnum;\n}\n\nexport function text(): PgTextBuilderInitial<'', [string, ...string[]]>;\nexport function text<U extends string, T extends Readonly<[U, ...U[]]>>(\n\tconfig?: PgTextConfig<T | Writable<T>>,\n): PgTextBuilderInitial<'', Writable<T>>;\nexport function text<TName extends string, U extends string, T extends Readonly<[U, ...U[]]>>(\n\tname: TName,\n\tconfig?: PgTextConfig<T | Writable<T>>,\n): PgTextBuilderInitial<TName, Writable<T>>;\nexport function text(a?: string | PgTextConfig, b: PgTextConfig = {}): any {\n\tconst { name, config } = getColumnNameAndConfig<PgTextConfig>(a, b);\n\treturn new PgTextBuilder(name, config as any);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { getColumnNameAndConfig, type Writable } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from './common.ts';\n\nexport type PgVarcharBuilderInitial<\n\tTName extends string,\n\tTEnum extends [string, ...string[]],\n\tTLength extends number | undefined,\n> = PgVarcharBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgVarchar';\n\tdata: TEnum[number];\n\tdriverParam: string;\n\tenumValues: TEnum;\n\tlength: TLength;\n}>;\n\nexport class PgVarcharBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgVarchar'> & { length?: number | undefined },\n> extends PgColumnBuilder<\n\tT,\n\t{ length: T['length']; enumValues: T['enumValues'] },\n\t{ length: T['length'] }\n> {\n\tstatic override readonly [entityKind]: string = 'PgVarcharBuilder';\n\n\tconstructor(name: T['name'], config: PgVarcharConfig<T['enumValues'], T['length']>) {\n\t\tsuper(name, 'string', 'PgVarchar');\n\t\tthis.config.length = config.length;\n\t\tthis.config.enumValues = config.enum;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgVarchar<MakeColumnConfig<T, TTableName> & { length: T['length'] }> {\n\t\treturn new PgVarchar<MakeColumnConfig<T, TTableName> & { length: T['length'] }>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgVarchar<T extends ColumnBaseConfig<'string', 'PgVarchar'> & { length?: number | undefined }>\n\textends PgColumn<T, { length: T['length']; enumValues: T['enumValues'] }, { length: T['length'] }>\n{\n\tstatic override readonly [entityKind]: string = 'PgVarchar';\n\n\treadonly length = this.config.length;\n\toverride readonly enumValues = this.config.enumValues;\n\n\tgetSQLType(): string {\n\t\treturn this.length === undefined ? `varchar` : `varchar(${this.length})`;\n\t}\n}\n\nexport interface PgVarcharConfig<\n\tTEnum extends readonly string[] | string[] | undefined = readonly string[] | string[] | undefined,\n\tTLength extends number | undefined = number | undefined,\n> {\n\tenum?: TEnum;\n\tlength?: TLength;\n}\n\nexport function varchar(): PgVarcharBuilderInitial<'', [string, ...string[]], undefined>;\nexport function varchar<\n\tU extends string,\n\tT extends Readonly<[U, ...U[]]>,\n\tL extends number | undefined,\n>(\n\tconfig?: PgVarcharConfig<T | Writable<T>, L>,\n): PgVarcharBuilderInitial<'', Writable<T>, L>;\nexport function varchar<\n\tTName extends string,\n\tU extends string,\n\tT extends Readonly<[U, ...U[]]>,\n\tL extends number | undefined,\n>(\n\tname: TName,\n\tconfig?: PgVarcharConfig<T | Writable<T>, L>,\n): PgVarcharBuilderInitial<TName, Writable<T>, L>;\nexport function varchar(a?: string | PgVarcharConfig, b: PgVarcharConfig = {}): any {\n\tconst { name, config } = getColumnNameAndConfig<PgVarcharConfig>(a, b);\n\treturn new PgVarcharBuilder(name, config as any);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from '../common.ts';\n\nexport type PgBinaryVectorBuilderInitial<TName extends string, TDimensions extends number> = PgBinaryVectorBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgBinaryVector';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n\tdimensions: TDimensions;\n}>;\n\nexport class PgBinaryVectorBuilder<\n\tT extends ColumnBuilderBaseConfig<'string', 'PgBinaryVector'> & { dimensions: number },\n> extends PgColumnBuilder<\n\tT,\n\t{ dimensions: T['dimensions'] }\n> {\n\tstatic override readonly [entityKind]: string = 'PgBinaryVectorBuilder';\n\n\tconstructor(name: string, config: PgBinaryVectorConfig<T['dimensions']>) {\n\t\tsuper(name, 'string', 'PgBinaryVector');\n\t\tthis.config.dimensions = config.dimensions;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgBinaryVector<MakeColumnConfig<T, TTableName> & { dimensions: T['dimensions'] }> {\n\t\treturn new PgBinaryVector<MakeColumnConfig<T, TTableName> & { dimensions: T['dimensions'] }>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgBinaryVector<T extends ColumnBaseConfig<'string', 'PgBinaryVector'> & { dimensions: number }>\n\textends PgColumn<T, { dimensions: T['dimensions'] }, { dimensions: T['dimensions'] }>\n{\n\tstatic override readonly [entityKind]: string = 'PgBinaryVector';\n\n\treadonly dimensions = this.config.dimensions;\n\n\tgetSQLType(): string {\n\t\treturn `bit(${this.dimensions})`;\n\t}\n}\n\nexport interface PgBinaryVectorConfig<TDimensions extends number = number> {\n\tdimensions: TDimensions;\n}\n\nexport function bit<D extends number>(\n\tconfig: PgBinaryVectorConfig<D>,\n): PgBinaryVectorBuilderInitial<'', D>;\nexport function bit<TName extends string, D extends number>(\n\tname: TName,\n\tconfig: PgBinaryVectorConfig<D>,\n): PgBinaryVectorBuilderInitial<TName, D>;\nexport function bit(a: string | PgBinaryVectorConfig, b?: PgBinaryVectorConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgBinaryVectorConfig>(a, b);\n\treturn new PgBinaryVectorBuilder(name, config);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from '../common.ts';\n\nexport type PgHalfVectorBuilderInitial<TName extends string, TDimensions extends number> = PgHalfVectorBuilder<{\n\tname: TName;\n\tdataType: 'array';\n\tcolumnType: 'PgHalfVector';\n\tdata: number[];\n\tdriverParam: string;\n\tenumValues: undefined;\n\tdimensions: TDimensions;\n}>;\n\nexport class PgHalfVectorBuilder<T extends ColumnBuilderBaseConfig<'array', 'PgHalfVector'> & { dimensions: number }>\n\textends PgColumnBuilder<\n\t\tT,\n\t\t{ dimensions: T['dimensions'] },\n\t\t{ dimensions: T['dimensions'] }\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgHalfVectorBuilder';\n\n\tconstructor(name: string, config: PgHalfVectorConfig<T['dimensions']>) {\n\t\tsuper(name, 'array', 'PgHalfVector');\n\t\tthis.config.dimensions = config.dimensions;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgHalfVector<MakeColumnConfig<T, TTableName> & { dimensions: T['dimensions'] }> {\n\t\treturn new PgHalfVector<MakeColumnConfig<T, TTableName> & { dimensions: T['dimensions'] }>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgHalfVector<T extends ColumnBaseConfig<'array', 'PgHalfVector'> & { dimensions: number }>\n\textends PgColumn<T, { dimensions: T['dimensions'] }, { dimensions: T['dimensions'] }>\n{\n\tstatic override readonly [entityKind]: string = 'PgHalfVector';\n\n\treadonly dimensions: T['dimensions'] = this.config.dimensions;\n\n\tgetSQLType(): string {\n\t\treturn `halfvec(${this.dimensions})`;\n\t}\n\n\toverride mapToDriverValue(value: unknown): unknown {\n\t\treturn JSON.stringify(value);\n\t}\n\n\toverride mapFromDriverValue(value: string): unknown {\n\t\treturn value\n\t\t\t.slice(1, -1)\n\t\t\t.split(',')\n\t\t\t.map((v) => Number.parseFloat(v));\n\t}\n}\n\nexport interface PgHalfVectorConfig<TDimensions extends number = number> {\n\tdimensions: TDimensions;\n}\n\nexport function halfvec<D extends number>(\n\tconfig: PgHalfVectorConfig<D>,\n): PgHalfVectorBuilderInitial<'', D>;\nexport function halfvec<TName extends string, D extends number>(\n\tname: TName,\n\tconfig: PgHalfVectorConfig,\n): PgHalfVectorBuilderInitial<TName, D>;\nexport function halfvec(a: string | PgHalfVectorConfig, b?: PgHalfVectorConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgHalfVectorConfig>(a, b);\n\treturn new PgHalfVectorBuilder(name, config);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from '../common.ts';\n\nexport type PgSparseVectorBuilderInitial<TName extends string> = PgSparseVectorBuilder<{\n\tname: TName;\n\tdataType: 'string';\n\tcolumnType: 'PgSparseVector';\n\tdata: string;\n\tdriverParam: string;\n\tenumValues: undefined;\n}>;\n\nexport class PgSparseVectorBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgSparseVector'>>\n\textends PgColumnBuilder<\n\t\tT,\n\t\t{ dimensions: number | undefined }\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgSparseVectorBuilder';\n\n\tconstructor(name: string, config: PgSparseVectorConfig) {\n\t\tsuper(name, 'string', 'PgSparseVector');\n\t\tthis.config.dimensions = config.dimensions;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgSparseVector<MakeColumnConfig<T, TTableName>> {\n\t\treturn new PgSparseVector<MakeColumnConfig<T, TTableName>>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgSparseVector<T extends ColumnBaseConfig<'string', 'PgSparseVector'>>\n\textends PgColumn<T, { dimensions: number | undefined }>\n{\n\tstatic override readonly [entityKind]: string = 'PgSparseVector';\n\n\treadonly dimensions = this.config.dimensions;\n\n\tgetSQLType(): string {\n\t\treturn `sparsevec(${this.dimensions})`;\n\t}\n}\n\nexport interface PgSparseVectorConfig {\n\tdimensions: number;\n}\n\nexport function sparsevec(\n\tconfig: PgSparseVectorConfig,\n): PgSparseVectorBuilderInitial<''>;\nexport function sparsevec<TName extends string>(\n\tname: TName,\n\tconfig: PgSparseVectorConfig,\n): PgSparseVectorBuilderInitial<TName>;\nexport function sparsevec(a: string | PgSparseVectorConfig, b?: PgSparseVectorConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgSparseVectorConfig>(a, b);\n\treturn new PgSparseVectorBuilder(name, config);\n}\n","import type { ColumnBuilderBaseConfig, ColumnBuilderRuntimeConfig, MakeColumnConfig } from '~/column-builder.ts';\nimport type { ColumnBaseConfig } from '~/column.ts';\nimport { entityKind } from '~/entity.ts';\nimport type { AnyPgTable } from '~/pg-core/table.ts';\nimport { getColumnNameAndConfig } from '~/utils.ts';\nimport { PgColumn, PgColumnBuilder } from '../common.ts';\n\nexport type PgVectorBuilderInitial<TName extends string, TDimensions extends number> = PgVectorBuilder<{\n\tname: TName;\n\tdataType: 'array';\n\tcolumnType: 'PgVector';\n\tdata: number[];\n\tdriverParam: string;\n\tenumValues: undefined;\n\tdimensions: TDimensions;\n}>;\n\nexport class PgVectorBuilder<T extends ColumnBuilderBaseConfig<'array', 'PgVector'> & { dimensions: number }>\n\textends PgColumnBuilder<\n\t\tT,\n\t\t{ dimensions: T['dimensions'] },\n\t\t{ dimensions: T['dimensions'] }\n\t>\n{\n\tstatic override readonly [entityKind]: string = 'PgVectorBuilder';\n\n\tconstructor(name: string, config: PgVectorConfig<T['dimensions']>) {\n\t\tsuper(name, 'array', 'PgVector');\n\t\tthis.config.dimensions = config.dimensions;\n\t}\n\n\t/** @internal */\n\toverride build<TTableName extends string>(\n\t\ttable: AnyPgTable<{ name: TTableName }>,\n\t): PgVector<MakeColumnConfig<T, TTableName> & { dimensions: T['dimensions'] }> {\n\t\treturn new PgVector<MakeColumnConfig<T, TTableName> & { dimensions: T['dimensions'] }>(\n\t\t\ttable,\n\t\t\tthis.config as ColumnBuilderRuntimeConfig<any, any>,\n\t\t);\n\t}\n}\n\nexport class PgVector<T extends ColumnBaseConfig<'array', 'PgVector'> & { dimensions: number | undefined }>\n\textends PgColumn<T, { dimensions: T['dimensions'] }, { dimensions: T['dimensions'] }>\n{\n\tstatic override readonly [entityKind]: string = 'PgVector';\n\n\treadonly dimensions: T['dimensions'] = this.config.dimensions;\n\n\tgetSQLType(): string {\n\t\treturn `vector(${this.dimensions})`;\n\t}\n\n\toverride mapToDriverValue(value: unknown): unknown {\n\t\treturn JSON.stringify(value);\n\t}\n\n\toverride mapFromDriverValue(value: string): unknown {\n\t\treturn value\n\t\t\t.slice(1, -1)\n\t\t\t.split(',')\n\t\t\t.map((v) => Number.parseFloat(v));\n\t}\n}\n\nexport interface PgVectorConfig<TDimensions extends number = number> {\n\tdimensions: TDimensions;\n}\n\nexport function vector<D extends number>(\n\tconfig: PgVectorConfig<D>,\n): PgVectorBuilderInitial<'', D>;\nexport function vector<TName extends string, D extends number>(\n\tname: TName,\n\tconfig: PgVectorConfig<D>,\n): PgVectorBuilderInitial<TName, D>;\nexport function vector(a: string | PgVectorConfig, b?: PgVectorConfig) {\n\tconst { name, config } = getColumnNameAndConfig<PgVectorConfig>(a, b);\n\treturn new PgVectorBuilder(name, config);\n}\n","import { bigint } from './bigint.ts';\nimport { bigserial } from './bigserial.ts';\nimport { boolean } from './boolean.ts';\nimport { char } from './char.ts';\nimport { cidr } from './cidr.ts';\nimport { customType } from './custom.ts';\nimport { date } from './date.ts';\nimport { doublePrecision } from './double-precision.ts';\nimport { inet } from './inet.ts';\nimport { integer } from './integer.ts';\nimport { interval } from './interval.ts';\nimport { json } from './json.ts';\nimport { jsonb } from './jsonb.ts';\nimport { line } from './line.ts';\nimport { macaddr } from './macaddr.ts';\nimport { macaddr8 } from './macaddr8.ts';\nimport { numeric } from './numeric.ts';\nimport { point } from './point.ts';\nimport { geometry } from './postgis_extension/geometry.ts';\nimport { real } from './real.ts';\nimport { serial } from './serial.ts';\nimport { smallint } from './smallint.ts';\nimport { smallserial } from './smallserial.ts';\nimport { text } from './text.ts';\nimport { time } from './time.ts';\nimport { timestamp } from './timestamp.ts';\nimport { uuid } from './uuid.ts';\nimport { varchar } from './varchar.ts';\nimport { bit } from './vector_extension/bit.ts';\nimport { halfvec } from './vector_extension/halfvec.ts';\nimport { sparsevec } from './vector_extension/sparsevec.ts';\nimport { vector } from './vector_extension/vector.ts';\n\nexport function getPgColumnBuilders() {\n\treturn {\n\t\tbigint,\n\t\tbigserial,\n\t\tboolean,\n\t\tchar,\n\t\tcidr,\n\t\tcustomType,\n\t\tdate,\n\t\tdoublePrecision,\n\t\tinet,\n\t\tinteger,\n\t\tinterval,\n\t\tjson,\n\t\tjsonb,\n\t\tline,\n\t\tmacaddr,\n\t\tmacaddr8,\n\t\tnumeric,\n\t\tpoint,\n\t\tgeometry,\n\t\treal,\n\t\tserial,\n\t\tsmallint,\n\t\tsmallserial,\n\t\ttext,\n\t\ttime,\n\t\ttimestamp,\n\t\tuuid,\n\t\tvarchar,\n\t\tbit,\n\t\thalfvec,\n\t\tsparsevec,\n\t\tvector,\n\t};\n}\n\nexport type PgColumnsBuilders = ReturnType<typeof getPgColumnBuilders>;\n","import type { BuildColumns, BuildExtraConfigColumns } from '~/column-builder.ts';\nimport { entityKind } from '~/entity.ts';\nimport { Table, type TableConfig as TableConfigBase, type UpdateTableConfig } from '~/table.ts';\nimport type { CheckBuilder } from './checks.ts';\nimport { getPgColumnBuilders, type PgColumnsBuilders } from './columns/all.ts';\nimport type { ExtraConfigColumn, PgColumn, PgColumnBuilder, PgColumnBuilderBase } from './columns/common.ts';\nimport type { ForeignKey, ForeignKeyBuilder } from './foreign-keys.ts';\nimport type { AnyIndexBuilder } from './indexes.ts';\nimport type { PgPolicy } from './policies.ts';\nimport type { PrimaryKeyBuilder } from './primary-keys.ts';\nimport type { UniqueConstraintBuilder } from './unique-constraint.ts';\n\nexport type PgTableExtraConfigValue =\n\t| AnyIndexBuilder\n\t| CheckBuilder\n\t| ForeignKeyBuilder\n\t| PrimaryKeyBuilder\n\t| UniqueConstraintBuilder\n\t| PgPolicy;\n\nexport type PgTableExtraConfig = Record<\n\tstring,\n\tPgTableExtraConfigValue\n>;\n\nexport type TableConfig = TableConfigBase<PgColumn>;\n\n/** @internal */\nexport const InlineForeignKeys = Symbol.for('drizzle:PgInlineForeignKeys');\n/** @internal */\nexport const EnableRLS = Symbol.for('drizzle:EnableRLS');\n\nexport class PgTable<T extends TableConfig = TableConfig> extends Table<T> {\n\tstatic override readonly [entityKind]: string = 'PgTable';\n\n\t/** @internal */\n\tstatic override readonly Symbol = Object.assign({}, Table.Symbol, {\n\t\tInlineForeignKeys: InlineForeignKeys as typeof InlineForeignKeys,\n\t\tEnableRLS: EnableRLS as typeof EnableRLS,\n\t});\n\n\t/**@internal */\n\t[InlineForeignKeys]: ForeignKey[] = [];\n\n\t/** @internal */\n\t[EnableRLS]: boolean = false;\n\n\t/** @internal */\n\toverride [Table.Symbol.ExtraConfigBuilder]: ((self: Record<string, PgColumn>) => PgTableExtraConfig) | undefined =\n\t\tundefined;\n\n\t/** @internal */\n\toverride [Table.Symbol.ExtraConfigColumns]: Record<string, ExtraConfigColumn> = {};\n}\n\nexport type AnyPgTable<TPartial extends Partial<TableConfig> = {}> = PgTable<UpdateTableConfig<TableConfig, TPartial>>;\n\nexport type PgTableWithColumns<T extends TableConfig> =\n\t& PgTable<T>\n\t& {\n\t\t[Key in keyof T['columns']]: T['columns'][Key];\n\t}\n\t& {\n\t\tenableRLS: () => Omit<\n\t\t\tPgTableWithColumns<T>,\n\t\t\t'enableRLS'\n\t\t>;\n\t};\n\n/** @internal */\nexport function pgTableWithSchema<\n\tTTableName extends string,\n\tTSchemaName extends string | undefined,\n\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n>(\n\tname: TTableName,\n\tcolumns: TColumnsMap | ((columnTypes: PgColumnsBuilders) => TColumnsMap),\n\textraConfig:\n\t\t| ((self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig | PgTableExtraConfigValue[])\n\t\t| undefined,\n\tschema: TSchemaName,\n\tbaseName = name,\n): PgTableWithColumns<{\n\tname: TTableName;\n\tschema: TSchemaName;\n\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\tdialect: 'pg';\n}> {\n\tconst rawTable = new PgTable<{\n\t\tname: TTableName;\n\t\tschema: TSchemaName;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>(name, schema, baseName);\n\n\tconst parsedColumns: TColumnsMap = typeof columns === 'function' ? columns(getPgColumnBuilders()) : columns;\n\n\tconst builtColumns = Object.fromEntries(\n\t\tObject.entries(parsedColumns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tcolBuilder.setName(name);\n\t\t\tconst column = colBuilder.build(rawTable);\n\t\t\trawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\n\tconst builtColumnsForExtraConfig = Object.fromEntries(\n\t\tObject.entries(parsedColumns).map(([name, colBuilderBase]) => {\n\t\t\tconst colBuilder = colBuilderBase as PgColumnBuilder;\n\t\t\tcolBuilder.setName(name);\n\t\t\tconst column = colBuilder.buildExtraConfigColumn(rawTable);\n\t\t\treturn [name, column];\n\t\t}),\n\t) as unknown as BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>;\n\n\tconst table = Object.assign(rawTable, builtColumns);\n\n\ttable[Table.Symbol.Columns] = builtColumns;\n\ttable[Table.Symbol.ExtraConfigColumns] = builtColumnsForExtraConfig;\n\n\tif (extraConfig) {\n\t\ttable[PgTable.Symbol.ExtraConfigBuilder] = extraConfig as any;\n\t}\n\n\treturn Object.assign(table, {\n\t\tenableRLS: () => {\n\t\t\ttable[PgTable.Symbol.EnableRLS] = true;\n\t\t\treturn table as PgTableWithColumns<{\n\t\t\t\tname: TTableName;\n\t\t\t\tschema: TSchemaName;\n\t\t\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\t\t\tdialect: 'pg';\n\t\t\t}>;\n\t\t},\n\t});\n}\n\nexport interface PgTableFn<TSchema extends string | undefined = undefined> {\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig?: (\n\t\t\tself: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>,\n\t\t) => PgTableExtraConfigValue[],\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: (columnTypes: PgColumnsBuilders) => TColumnsMap,\n\t\textraConfig?: (self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfigValue[],\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n\t/**\n\t * @deprecated The third parameter of pgTable is changing and will only accept an array instead of an object\n\t *\n\t * @example\n\t * Deprecated version:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => ({\n\t * \tidx: index('custom_name').on(t.id)\n\t * }));\n\t * ```\n\t *\n\t * New API:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => [\n\t * \tindex('custom_name').on(t.id)\n\t * ]);\n\t * ```\n\t */\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: TColumnsMap,\n\t\textraConfig: (\n\t\t\tself: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>,\n\t\t) => PgTableExtraConfig,\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n\n\t/**\n\t * @deprecated The third parameter of pgTable is changing and will only accept an array instead of an object\n\t *\n\t * @example\n\t * Deprecated version:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => ({\n\t * \tidx: index('custom_name').on(t.id)\n\t * }));\n\t * ```\n\t *\n\t * New API:\n\t * ```ts\n\t * export const users = pgTable(\"users\", {\n\t * \tid: integer(),\n\t * }, (t) => [\n\t * \tindex('custom_name').on(t.id)\n\t * ]);\n\t * ```\n\t */\n\t<\n\t\tTTableName extends string,\n\t\tTColumnsMap extends Record<string, PgColumnBuilderBase>,\n\t>(\n\t\tname: TTableName,\n\t\tcolumns: (columnTypes: PgColumnsBuilders) => TColumnsMap,\n\t\textraConfig: (self: BuildExtraConfigColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig,\n\t): PgTableWithColumns<{\n\t\tname: TTableName;\n\t\tschema: TSchema;\n\t\tcolumns: BuildColumns<TTableName, TColumnsMap, 'pg'>;\n\t\tdialect: 'pg';\n\t}>;\n}\n\nexport const pgTable: PgTableFn = (name, columns, extraConfig) => {\n\treturn pgTableWithSchema(name, columns, extraConfig, undefined);\n};\n\nexport function pgTableCreator(customizeTableName: (name: string) => string): PgTableFn {\n\treturn (name, columns, extraConfig) => {\n\t\treturn pgTableWithSchema(customizeTableName(name) as typeof name, columns, extraConfig, undefined, name);\n\t};\n}\n","import { pgTable, text, timestamp, boolean, integer } from \"drizzle-orm/pg-core\";\n\nexport const user = pgTable(\"user\", {\n\tid: text('id').primaryKey(),\n\tname: text('name').notNull(),\n\temail: text('email').notNull().unique(),\n\temailVerified: boolean('email_verified').$defaultFn(() => false).notNull(),\n\timage: text('image'),\n\tcreatedAt: timestamp('created_at').$defaultFn(() => /* @__PURE__ */ new Date()).notNull(),\n\tupdatedAt: timestamp('updated_at').$defaultFn(() => /* @__PURE__ */ new Date()).notNull(),\n\trole: text('role'),\n\tbanned: boolean('banned'),\n\tbanReason: text('ban_reason'),\n\tbanExpires: timestamp('ban_expires'),\n\tstripeCustomerId: text('stripe_customer_id'),\n\twebhooksToEndpointsMigrated: boolean('webhooks_to_endpoints_migrated').default(false),\n\t// Feature flags - array of enabled feature flags\n\tfeatureFlags: text('feature_flags') // JSON array of feature flag strings\n});\n\nexport const session = pgTable(\"session\", {\n\tid: text('id').primaryKey(),\n\texpiresAt: timestamp('expires_at').notNull(),\n\ttoken: text('token').notNull().unique(),\n\tcreatedAt: timestamp('created_at').notNull(),\n\tupdatedAt: timestamp('updated_at').notNull(),\n\tipAddress: text('ip_address'),\n\tuserAgent: text('user_agent'),\n\tuserId: text('user_id').notNull().references(() => user.id, { onDelete: 'cascade' }),\n\timpersonatedBy: text('impersonated_by')\n});\n\nexport const account = pgTable(\"account\", {\n\tid: text('id').primaryKey(),\n\taccountId: text('account_id').notNull(),\n\tproviderId: text('provider_id').notNull(),\n\tuserId: text('user_id').notNull().references(() => user.id, { onDelete: 'cascade' }),\n\taccessToken: text('access_token'),\n\trefreshToken: text('refresh_token'),\n\tidToken: text('id_token'),\n\taccessTokenExpiresAt: timestamp('access_token_expires_at'),\n\trefreshTokenExpiresAt: timestamp('refresh_token_expires_at'),\n\tscope: text('scope'),\n\tpassword: text('password'),\n\tcreatedAt: timestamp('created_at').notNull(),\n\tupdatedAt: timestamp('updated_at').notNull()\n});\n\nexport const verification = pgTable(\"verification\", {\n\tid: text('id').primaryKey(),\n\tidentifier: text('identifier').notNull(),\n\tvalue: text('value').notNull(),\n\texpiresAt: timestamp('expires_at').notNull(),\n\tcreatedAt: timestamp('created_at').$defaultFn(() => /* @__PURE__ */ new Date()),\n\tupdatedAt: timestamp('updated_at').$defaultFn(() => /* @__PURE__ */ new Date())\n});\n\nexport const apikey = pgTable(\"apikey\", {\n\tid: text('id').primaryKey(),\n\tname: text('name'),\n\tstart: text('start'),\n\tprefix: text('prefix'),\n\tkey: text('key').notNull(),\n\tuserId: text('user_id').notNull().references(() => user.id, { onDelete: 'cascade' }),\n\trefillInterval: integer('refill_interval'),\n\trefillAmount: integer('refill_amount'),\n\tlastRefillAt: timestamp('last_refill_at'),\n\tenabled: boolean('enabled').default(true),\n\trateLimitEnabled: boolean('rate_limit_enabled').default(true),\n\trateLimitTimeWindow: integer('rate_limit_time_window').default(86400000),\n\trateLimitMax: integer('rate_limit_max').default(10),\n\trequestCount: integer('request_count'),\n\tremaining: integer('remaining'),\n\tlastRequest: timestamp('last_request'),\n\texpiresAt: timestamp('expires_at'),\n\tcreatedAt: timestamp('created_at').notNull(),\n\tupdatedAt: timestamp('updated_at').notNull(),\n\tpermissions: text('permissions'),\n\tmetadata: text('metadata')\n});\n"],"names":["value","startFrom","ref","actions","otel","rawTracer","param","sql","placeholder","name","SQL","result"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53]}
{"version":3,"sources":["turbopack:///[project]/functions/mail/primary.ts"],"sourcesContent":["\"use server\"\n\nimport { db } from '@/lib/db'\nimport { structuredEmails, sesEvents } from '@/lib/db/schema'\nimport { eq, and, sql, desc, gte, inArray } from 'drizzle-orm'\nimport { sanitizeHtml } from '@/lib/email-management/email-parser'\n\n// ============================================================================\n// EMAIL FUNCTIONS\n// ============================================================================\n\n/**\n * Get all emails with search and pagination support\n */\nexport async function getAllEmails(userId: string, options?: {\n    limit?: number\n    offset?: number\n    searchQuery?: string\n    statusFilter?: 'all' | 'processed' | 'failed'\n    domainFilter?: string\n    timeRange?: '24h' | '7d' | '30d' | '90d'\n    includeArchived?: boolean\n}) {\n    try {\n        const {\n            limit = 50,\n            offset = 0,\n            searchQuery = '',\n            statusFilter = 'all',\n            domainFilter = 'all',\n            timeRange = '30d',\n            includeArchived = false\n        } = options || {}\n\n        // Build where conditions\n        let whereConditions = [eq(structuredEmails.userId, userId)]\n\n        // Exclude archived emails by default\n        if (!includeArchived) {\n            whereConditions.push(eq(structuredEmails.isArchived, false))\n        }\n\n        // Add status filter\n        if (statusFilter === 'failed') {\n            whereConditions.push(eq(structuredEmails.parseSuccess, false))\n        } else if (statusFilter === 'processed') {\n            whereConditions.push(eq(structuredEmails.parseSuccess, true))\n        }\n\n        // Add time range filter\n        if (timeRange !== '90d') {\n            let timeThreshold: Date\n            const now = new Date()\n            switch (timeRange) {\n                case '24h':\n                    timeThreshold = new Date(now.getTime() - 24 * 60 * 60 * 1000)\n                    break\n                case '7d':\n                    timeThreshold = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)\n                    break\n                case '30d':\n                    timeThreshold = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)\n                    break\n                default:\n                    timeThreshold = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)\n            }\n            whereConditions.push(gte(structuredEmails.createdAt, timeThreshold))\n        }\n\n        // Add domain filter\n        if (domainFilter !== 'all') {\n            whereConditions.push(\n                sql`${structuredEmails.toData}::jsonb->'addresses'->0->>'address' LIKE ${`%@${domainFilter}`}`\n            )\n        }\n\n        // Add search query (search in subject, from, to)\n        if (searchQuery.trim()) {\n            const searchPattern = `%${searchQuery.trim()}%`\n            whereConditions.push(\n                sql`(${structuredEmails.subject} ILIKE ${searchPattern} OR ${structuredEmails.fromData}::text ILIKE ${searchPattern} OR ${structuredEmails.toData}::text ILIKE ${searchPattern})`\n            )\n        }\n\n        // Get total count\n        const [{ count }] = await db\n            .select({ count: sql<number>`count(*)` })\n            .from(structuredEmails)\n            .where(and(...whereConditions))\n\n        // Get emails with pagination\n        const emails = await db\n            .select({\n                id: structuredEmails.id,\n                emailId: structuredEmails.emailId,\n                messageId: structuredEmails.messageId,\n                subject: structuredEmails.subject,\n                date: structuredEmails.date,\n                fromData: structuredEmails.fromData,\n                toData: structuredEmails.toData,\n                textBody: structuredEmails.textBody,\n                htmlBody: structuredEmails.htmlBody,\n                attachments: structuredEmails.attachments,\n                parseSuccess: structuredEmails.parseSuccess,\n                parseError: structuredEmails.parseError,\n                isRead: structuredEmails.isRead,\n                readAt: structuredEmails.readAt,\n                isArchived: structuredEmails.isArchived,\n                archivedAt: structuredEmails.archivedAt,\n                createdAt: structuredEmails.createdAt\n            })\n            .from(structuredEmails)\n            .where(and(...whereConditions))\n            .orderBy(desc(structuredEmails.createdAt))\n            .limit(limit)\n            .offset(offset)\n\n        // Transform emails for response\n        const transformedEmails = emails.map(email => {\n            // Parse JSON fields\n            let parsedFromData = null\n            if (email.fromData) {\n                try {\n                    parsedFromData = JSON.parse(email.fromData)\n                } catch (e) {\n                    console.error('Failed to parse fromData:', e)\n                }\n            }\n\n            let parsedToData = null\n            if (email.toData) {\n                try {\n                    parsedToData = JSON.parse(email.toData)\n                } catch (e) {\n                    console.error('Failed to parse toData:', e)\n                }\n            }\n\n            let parsedAttachments = []\n            if (email.attachments) {\n                try {\n                    parsedAttachments = JSON.parse(email.attachments)\n                } catch (e) {\n                    console.error('Failed to parse attachments:', e)\n                }\n            }\n\n            // Extract preview from text body or HTML body\n            let preview = ''\n            if (email.textBody) {\n                preview = email.textBody.substring(0, 200)\n            } else if (email.htmlBody) {\n                // Strip HTML tags for preview\n                preview = email.htmlBody.replace(/<[^>]*>/g, '').substring(0, 200)\n            }\n\n            return {\n                id: email.id,\n                emailId: email.emailId,\n                messageId: email.messageId,\n                subject: email.subject || 'No Subject',\n                from: parsedFromData?.addresses?.[0]?.address || 'unknown',\n                fromName: parsedFromData?.addresses?.[0]?.name || null,\n                recipient: parsedToData?.addresses?.[0]?.address || 'unknown',\n                preview,\n                receivedAt: email.date || email.createdAt,\n                isRead: email.isRead || false,\n                readAt: email.readAt,\n                isArchived: email.isArchived || false,\n                archivedAt: email.archivedAt,\n                hasAttachments: parsedAttachments.length > 0,\n                attachmentCount: parsedAttachments.length,\n                parseSuccess: email.parseSuccess,\n                parseError: email.parseError,\n                createdAt: email.createdAt\n            }\n        })\n\n        // Get unique domains for filter\n        const uniqueDomainsResult = await db\n            .select({\n                domain: sql<string>`DISTINCT SPLIT_PART((${structuredEmails.toData}::jsonb->'addresses'->0->>'address'), '@', 2)`\n            })\n            .from(structuredEmails)\n            .where(\n                and(\n                    eq(structuredEmails.userId, userId),\n                    sql`${structuredEmails.toData}::jsonb->'addresses'->0->>'address' IS NOT NULL`\n                )\n            )\n\n        const uniqueDomains = uniqueDomainsResult\n            .map(row => row.domain)\n            .filter(domain => domain && domain.trim() !== '')\n\n        return {\n            success: true,\n            data: {\n                emails: transformedEmails,\n                pagination: {\n                    total: count,\n                    limit,\n                    offset,\n                    hasMore: offset + limit < count\n                },\n                filters: {\n                    uniqueDomains\n                }\n            }\n        }\n\n    } catch (error) {\n        console.error('Error fetching emails:', error)\n        return { error: 'Failed to fetch emails' }\n    }\n}\n\n/**\n * Get a complete email object by ID\n */\nexport async function getEmail(userId: string, emailId: string) {\n    try {\n        if (!emailId) {\n            return { error: 'Email ID is required' }\n        }\n\n        // Fetch email details with SES event data\n        const emailDetails = await db\n            .select({\n                // Structured email details\n                id: structuredEmails.id,\n                emailId: structuredEmails.emailId,\n                messageId: structuredEmails.messageId,\n                subject: structuredEmails.subject,\n                date: structuredEmails.date,\n                fromData: structuredEmails.fromData,\n                toData: structuredEmails.toData,\n                ccData: structuredEmails.ccData,\n                bccData: structuredEmails.bccData,\n                replyToData: structuredEmails.replyToData,\n                inReplyTo: structuredEmails.inReplyTo,\n                references: structuredEmails.references,\n                textBody: structuredEmails.textBody,\n                htmlBody: structuredEmails.htmlBody,\n                rawContent: structuredEmails.rawContent,\n                attachments: structuredEmails.attachments,\n                headers: structuredEmails.headers,\n                priority: structuredEmails.priority,\n                parseSuccess: structuredEmails.parseSuccess,\n                parseError: structuredEmails.parseError,\n                isRead: structuredEmails.isRead,\n                readAt: structuredEmails.readAt,\n                userId: structuredEmails.userId,\n                sesEventId: structuredEmails.sesEventId,\n                createdAt: structuredEmails.createdAt,\n                updatedAt: structuredEmails.updatedAt,\n                \n                // SES event details\n                emailContent: sesEvents.emailContent,\n                spamVerdict: sesEvents.spamVerdict,\n                virusVerdict: sesEvents.virusVerdict,\n                spfVerdict: sesEvents.spfVerdict,\n                dkimVerdict: sesEvents.dkimVerdict,\n                dmarcVerdict: sesEvents.dmarcVerdict,\n                actionType: sesEvents.actionType,\n                s3BucketName: sesEvents.s3BucketName,\n                s3ObjectKey: sesEvents.s3ObjectKey,\n                s3ContentFetched: sesEvents.s3ContentFetched,\n                s3ContentSize: sesEvents.s3ContentSize,\n                s3Error: sesEvents.s3Error,\n                commonHeaders: sesEvents.commonHeaders,\n                processingTimeMillis: sesEvents.processingTimeMillis,\n                timestamp: sesEvents.timestamp,\n                receiptTimestamp: sesEvents.receiptTimestamp,\n            })\n            .from(structuredEmails)\n            .leftJoin(sesEvents, eq(structuredEmails.sesEventId, sesEvents.id))\n            .where(\n                and(\n                    eq(structuredEmails.id, emailId),\n                    eq(structuredEmails.userId, userId)\n                )\n            )\n            .limit(1)\n\n        if (emailDetails.length === 0) {\n            return { error: 'Email not found' }\n        }\n\n        const email = emailDetails[0]\n\n        // Parse JSON fields\n        const parseJsonField = (field: string | null) => {\n            if (!field) return null\n            try {\n                return JSON.parse(field)\n            } catch (e) {\n                console.error(`Failed to parse JSON field:`, e)\n                return null\n            }\n        }\n\n        const parsedFromData = parseJsonField(email.fromData)\n        const parsedToData = parseJsonField(email.toData)\n        const parsedCcData = parseJsonField(email.ccData)\n        const parsedBccData = parseJsonField(email.bccData)\n        const parsedReplyToData = parseJsonField(email.replyToData)\n        const parsedAttachments = parseJsonField(email.attachments) || []\n        const parsedHeaders = parseJsonField(email.headers) || {}\n        const parsedReferences = parseJsonField(email.references) || []\n        const parsedCommonHeaders = parseJsonField(email.commonHeaders)\n\n        // Sanitize HTML content\n        const sanitizedHtmlBody = email.htmlBody ? sanitizeHtml(email.htmlBody) : null\n\n        // Extract addresses for backward compatibility\n        const recipient = parsedToData?.addresses?.[0]?.address || 'unknown'\n        const fromAddress = parsedFromData?.addresses?.[0]?.address || 'unknown'\n\n        // Mark email as read if not already read\n        if (!email.isRead) {\n            await db\n                .update(structuredEmails)\n                .set({\n                    isRead: true,\n                    readAt: new Date(),\n                    updatedAt: new Date()\n                })\n                .where(eq(structuredEmails.id, emailId))\n        }\n\n        // Format the complete email response\n        const response = {\n            id: email.id,\n            emailId: email.emailId,\n            messageId: email.messageId,\n            subject: email.subject,\n            from: fromAddress,\n            fromName: parsedFromData?.addresses?.[0]?.name || null,\n            to: parsedToData?.text || '',\n            cc: parsedCcData?.text || null,\n            bcc: parsedBccData?.text || null,\n            replyTo: parsedReplyToData?.text || null,\n            recipient,\n            receivedAt: email.date,\n            isRead: true, // Mark as read since we're viewing it\n            readAt: email.readAt || new Date(),\n            \n            // Email content\n            content: {\n                textBody: email.textBody,\n                htmlBody: sanitizedHtmlBody,\n                rawContent: email.rawContent,\n                attachments: parsedAttachments,\n                headers: parsedHeaders\n            },\n            \n            // Parsed data\n            addresses: {\n                from: parsedFromData,\n                to: parsedToData,\n                cc: parsedCcData,\n                bcc: parsedBccData,\n                replyTo: parsedReplyToData\n            },\n            \n            // Email metadata\n            metadata: {\n                inReplyTo: email.inReplyTo,\n                references: parsedReferences,\n                priority: email.priority,\n                parseSuccess: email.parseSuccess,\n                parseError: email.parseError,\n                hasAttachments: parsedAttachments.length > 0,\n                attachmentCount: parsedAttachments.length,\n                hasTextBody: !!email.textBody,\n                hasHtmlBody: !!email.htmlBody\n            },\n            \n            // Security and delivery info\n            security: {\n                spf: email.spfVerdict || 'UNKNOWN',\n                dkim: email.dkimVerdict || 'UNKNOWN',\n                dmarc: email.dmarcVerdict || 'UNKNOWN',\n                spam: email.spamVerdict || 'UNKNOWN',\n                virus: email.virusVerdict || 'UNKNOWN'\n            },\n            \n            // Processing info\n            processing: {\n                processingTimeMs: email.processingTimeMillis,\n                timestamp: email.timestamp,\n                receiptTimestamp: email.receiptTimestamp,\n                actionType: email.actionType,\n                s3Info: {\n                    bucketName: email.s3BucketName,\n                    objectKey: email.s3ObjectKey,\n                    contentFetched: email.s3ContentFetched,\n                    contentSize: email.s3ContentSize,\n                    error: email.s3Error\n                },\n                commonHeaders: parsedCommonHeaders\n            },\n            \n            // Timestamps\n            createdAt: email.createdAt,\n            updatedAt: email.updatedAt\n        }\n\n        return { success: true, data: response }\n\n    } catch (error) {\n        console.error('Error fetching email:', error)\n        return { error: 'Failed to fetch email' }\n    }\n}\n\n/**\n * Reply to an email (planned feature - placeholder implementation)\n */\nexport async function replyToEmail(userId: string, emailId: string, replyData: {\n    to: string\n    subject: string\n    textBody?: string\n    htmlBody?: string\n    attachments?: Array<{\n        filename: string\n        contentType: string\n        content: string // base64 encoded\n    }>\n}) {\n    try {\n        if (!emailId) {\n            return { error: 'Email ID is required' }\n        }\n\n        // Verify the original email exists and belongs to the user\n        const originalEmail = await db\n            .select({\n                id: structuredEmails.id,\n                messageId: structuredEmails.messageId,\n                subject: structuredEmails.subject,\n                fromData: structuredEmails.fromData,\n                toData: structuredEmails.toData\n            })\n            .from(structuredEmails)\n            .where(\n                and(\n                    eq(structuredEmails.id, emailId),\n                    eq(structuredEmails.userId, userId)\n                )\n            )\n            .limit(1)\n\n        if (originalEmail.length === 0) {\n            return { error: 'Original email not found' }\n        }\n\n        // TODO: Implement email sending functionality\n        // This would typically involve:\n        // 1. Setting up SMTP configuration\n        // 2. Constructing the reply email with proper headers\n        // 3. Setting In-Reply-To and References headers\n        // 4. Sending the email using a service like AWS SES, SendGrid, etc.\n        // 5. Logging the sent email in a separate table\n\n        // For now, return a placeholder response\n        return {\n            success: true,\n            data: {\n                message: 'Reply functionality is not yet implemented',\n                originalEmailId: emailId,\n                replyData: {\n                    to: replyData.to,\n                    subject: replyData.subject,\n                    hasTextBody: !!replyData.textBody,\n                    hasHtmlBody: !!replyData.htmlBody,\n                    attachmentCount: replyData.attachments?.length || 0\n                },\n                status: 'pending_implementation'\n            }\n        }\n\n    } catch (error) {\n        console.error('Error replying to email:', error)\n        return { error: 'Failed to reply to email' }\n    }\n}\n\n/**\n * Update email properties (read status, archive status, etc.)\n */\nexport async function updateEmail(userId: string, emailId: string, updates: {\n    isRead?: boolean\n    isArchived?: boolean\n}) {\n    try {\n        console.log('📝 updateEmail - Updating email:', emailId, 'for user:', userId, 'with updates:', updates)\n\n        // Prepare update data\n        const updateData: any = {\n            updatedAt: new Date()\n        }\n\n        if (updates.isRead !== undefined) {\n            updateData.isRead = updates.isRead\n            updateData.readAt = updates.isRead ? new Date() : null\n        }\n\n        if (updates.isArchived !== undefined) {\n            updateData.isArchived = updates.isArchived\n            updateData.archivedAt = updates.isArchived ? new Date() : null\n        }\n\n        // Update the email\n        const [updatedEmail] = await db\n            .update(structuredEmails)\n            .set(updateData)\n            .where(\n                and(\n                    eq(structuredEmails.id, emailId),\n                    eq(structuredEmails.userId, userId)\n                )\n            )\n            .returning({\n                id: structuredEmails.id,\n                isRead: structuredEmails.isRead,\n                isArchived: structuredEmails.isArchived,\n                readAt: structuredEmails.readAt,\n                archivedAt: structuredEmails.archivedAt\n            })\n\n        if (!updatedEmail) {\n            return { error: 'Email not found or access denied' }\n        }\n\n        console.log('✅ updateEmail - Successfully updated email:', emailId)\n        return { \n            success: true, \n            data: updatedEmail\n        }\n\n    } catch (error) {\n        console.error('❌ updateEmail - Error updating email:', error)\n        return { error: 'Failed to update email' }\n    }\n}\n\n/**\n * Bulk update emails (archive, mark as read, etc.)\n */\nexport async function bulkUpdateEmails(userId: string, emailIds: string[], updates: {\n    isRead?: boolean\n    isArchived?: boolean\n}) {\n    try {\n        console.log('📝 bulkUpdateEmails - Updating', emailIds.length, 'emails for user:', userId, 'with updates:', updates)\n\n        if (emailIds.length === 0) {\n            return { error: 'No email IDs provided' }\n        }\n\n        if (emailIds.length > 100) {\n            return { error: 'Cannot update more than 100 emails at once' }\n        }\n\n        // Prepare update data\n        const updateData: any = {\n            updatedAt: new Date()\n        }\n\n        if (updates.isRead !== undefined) {\n            updateData.isRead = updates.isRead\n            updateData.readAt = updates.isRead ? new Date() : null\n        }\n\n        if (updates.isArchived !== undefined) {\n            updateData.isArchived = updates.isArchived\n            updateData.archivedAt = updates.isArchived ? new Date() : null\n        }\n\n        // Update the emails using inArray for better type safety\n        const updatedEmails = await db\n            .update(structuredEmails)\n            .set(updateData)\n            .where(\n                and(\n                    eq(structuredEmails.userId, userId),\n                    inArray(structuredEmails.id, emailIds)\n                )\n            )\n            .returning({\n                id: structuredEmails.id,\n                isRead: structuredEmails.isRead,\n                isArchived: structuredEmails.isArchived\n            })\n\n        console.log('✅ bulkUpdateEmails - Successfully updated', updatedEmails.length, 'emails')\n        return { \n            success: true, \n            data: {\n                updatedCount: updatedEmails.length,\n                emails: updatedEmails\n            }\n        }\n\n    } catch (error) {\n        console.error('❌ bulkUpdateEmails - Error updating emails:', error)\n        return { error: 'Failed to update emails' }\n    }\n}\n"],"names":[],"mappings":"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"}
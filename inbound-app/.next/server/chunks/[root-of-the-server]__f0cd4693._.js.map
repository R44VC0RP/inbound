{"version":3,"sources":["turbopack:///[project]/lib/domains-and-dns/dns.ts","turbopack:///[project]/node_modules/@aws-sdk/client-ses/dist-es/commands/GetIdentityVerificationAttributesCommand.js","turbopack:///[project]/app/api/inbound/verify-domain/route.ts","turbopack:///[project]/node_modules/next/dist/src/build/templates/app-route.ts"],"sourcesContent":["/**\n * DNS Library - Consolidated DNS functionality\n * \n * Provides comprehensive DNS functionality including:\n * - Domain availability checking (ensures no conflicting MX/CNAME records)\n * - DNS record verification (confirms required records exist and match expected values)  \n * - Domain provider detection with fallback resolvers\n * - Used throughout domain onboarding and verification workflows\n */\n\nimport { promises as dns } from 'dns';\nimport { Resolver } from 'dns'\n\n/**\n * MX Record type definition\n */\nexport interface MxRecord {\n  exchange: string;\n  priority: number;\n}\n\n/**\n * DNS record verification result (from dns-verification.ts)\n */\nexport interface DnsRecordCheck {\n  type: string\n  name: string\n  expectedValue: string\n  actualValues: string[]\n  isVerified: boolean\n  error?: string\n}\n\n/**\n * Domain provider information\n */\nexport interface DomainProvider {\n  name: string;\n  icon: string; // Icon identifier for UI\n  detected: boolean;\n  confidence: 'high' | 'medium' | 'low';\n}\n\n/**\n * DNS check result types\n */\nexport interface DnsCheckResult {\n  domain: string;\n  canReceiveEmails: boolean;\n  hasMxRecords: boolean;\n  mxRecords?: MxRecord[];\n  provider?: DomainProvider;\n  error?: string;\n  timestamp: Date;\n}\n\nexport interface DnsError {\n  code: string;\n  errno: number;\n  message: string;\n}\n\n/**\n * Domain provider patterns based on nameservers\n */\nconst PROVIDER_PATTERNS = {\n  cloudflare: {\n    name: 'Cloudflare',\n    icon: 'cloudflare',\n    patterns: ['cloudflare.com', 'ns.cloudflare.com', 'cloudflare.net']\n  },\n  namecheap: {\n    name: 'Namecheap',\n    icon: 'namecheap', \n    patterns: ['registrar-servers.com', 'namecheap.com', 'namecheaphosting.com']\n  },\n  godaddy: {\n    name: 'GoDaddy',\n    icon: 'godaddy',\n    patterns: ['domaincontrol.com', 'godaddy.com', 'secureserver.net']\n  },\n  route53: {\n    name: 'AWS Route 53',\n    icon: 'aws',\n    patterns: ['awsdns', 'amazonaws.com', 'awsdns-']\n  },\n  google: {\n    name: 'Google Domains',\n    icon: 'google',\n    patterns: ['googledomains.com', 'google.com', 'googlehosted.com']\n  },\n  vercel: {\n    name: 'Vercel',\n    icon: 'vercel',\n    patterns: ['vercel-dns.com', 'vercel.app']\n  },\n  digitalocean: {\n    name: 'DigitalOcean',\n    icon: 'digitalocean',\n    patterns: ['digitalocean.com', 'ns1.digitalocean.com', 'ns2.digitalocean.com', 'ns3.digitalocean.com']\n  },\n  netlify: {\n    name: 'Netlify',\n    icon: 'netlify',\n    patterns: ['netlify.com', 'dns1.p01.nsone.net', 'dns2.p01.nsone.net']\n  },\n  dnsimple: {\n    name: 'DNSimple',\n    icon: 'dnsimple',\n    patterns: ['dnsimple.com', 'ns1.dnsimple.com', 'ns2.dnsimple.com']\n  },\n  hover: {\n    name: 'Hover',\n    icon: 'hover',\n    patterns: ['hover.com', 'ns1.hover.com', 'ns2.hover.com']\n  },\n  porkbun: {\n    name: 'Porkbun',\n    icon: 'porkbun',\n    patterns: ['porkbun.com', 'curitiba.porkbun.com', 'fortaleza.porkbun.com']\n  },\n  squarespace: {\n    name: 'Squarespace',\n    icon: 'squarespace',\n    patterns: ['squarespace.com', 'ext-dns.squarespace.com']\n  }\n};\n\n/**\n * Get all parent domains for a given domain\n * @param domain - Domain to get parents for\n * @returns Array of parent domains from most specific to least specific\n */\nfunction getParentDomains(domain: string): string[] {\n  const parts = domain.split('.');\n  const parents: string[] = [];\n  \n  // Start from the second level (skip the subdomain)\n  for (let i = 1; i < parts.length; i++) {\n    parents.push(parts.slice(i).join('.'));\n  }\n  \n  return parents;\n}\n\n/**\n * Detect domain provider based on nameservers with fallback to parent domains\n * @param domain - Domain to check\n * @returns Promise<DomainProvider | null> - Detected provider or null\n */\nexport async function detectDomainProvider(domain: string): Promise<DomainProvider | null> {\n  // Try the original domain first\n  const result = await tryDetectProvider(domain);\n  if (result && result.detected) {\n    return result;\n  }\n\n  // If no provider found or low confidence, try parent domains\n  const parentDomains = getParentDomains(domain);\n  \n  for (const parentDomain of parentDomains) {\n    try {\n      const parentResult = await tryDetectProvider(parentDomain);\n      if (parentResult && parentResult.detected) {\n        // Found a provider on parent domain, but mark confidence as medium\n        return {\n          ...parentResult,\n          confidence: parentResult.confidence === 'high' ? 'medium' : 'low'\n        };\n      }\n    } catch (error) {\n      // Continue to next parent domain if this one fails\n      continue;\n    }\n  }\n  \n  // If no provider detected on any level, return the original result or generic\n  return result || {\n    name: 'DNS Provider',\n    icon: 'globe',\n    detected: false,\n    confidence: 'low'\n  };\n}\n\n/**\n * Try to detect provider for a specific domain\n * @param domain - Domain to check\n * @returns Promise<DomainProvider | null> - Detected provider or null\n */\nasync function tryDetectProvider(domain: string): Promise<DomainProvider | null> {\n  try {\n    const nameservers = await dns.resolveNs(domain);\n    \n    for (const [key, provider] of Object.entries(PROVIDER_PATTERNS)) {\n      for (const ns of nameservers) {\n        for (const pattern of provider.patterns) {\n          if (ns.toLowerCase().includes(pattern.toLowerCase())) {\n            return {\n              name: provider.name,\n              icon: provider.icon,\n              detected: true,\n              confidence: 'high'\n            };\n          }\n        }\n      }\n    }\n    \n    // If nameservers found but no specific provider detected\n    if (nameservers.length > 0) {\n      return {\n        name: 'Custom DNS Provider',\n        icon: 'globe',\n        detected: false,\n        confidence: 'medium'\n      };\n    }\n    \n    return null;\n  } catch (error) {\n    return null;\n  }\n}\n\n/**\n * Check if a domain can safely receive emails by verifying it does NOT have MX records\n * @param domain - The domain to check\n * @returns Promise<DnsCheckResult> - Result indicating if domain can receive emails\n */\nexport async function checkDomainCanReceiveEmails(domain: string): Promise<DnsCheckResult> {\n  const result: DnsCheckResult = {\n    domain,\n    canReceiveEmails: false,\n    hasMxRecords: false,\n    timestamp: new Date(),\n  };\n\n  // Validate domain format\n  if (!isValidDomain(domain)) {\n    result.error = 'Invalid domain format';\n    return result;\n  }\n\n  // Detect domain provider\n  try {\n    const provider = await detectDomainProvider(domain);\n    if (provider) {\n      result.provider = provider;\n    }\n  } catch (error) {\n    // Provider detection failure is not critical, continue\n  }\n\n  // Check MX records separately\n  let mxRecords: MxRecord[] = [];\n  let mxError: string | null = null;\n  \n  try {\n    mxRecords = await dns.resolveMx(domain);\n    console.log('🏁 CANDOMAINRECEIVE 🏁 \\n MX Records:', mxRecords);\n  } catch (error) {\n    const dnsError = error as DnsError;\n    if (dnsError.code !== 'ENOTFOUND' && dnsError.code !== 'ENODATA') {\n      mxError = dnsError.message;\n    }\n    // ENOTFOUND/ENODATA for MX is expected for domains without email\n  }\n\n  // Check CNAME records separately\n  let cnameRecords: string[] = [];\n  let cnameError: string | null = null;\n  \n  try {\n    cnameRecords = await dns.resolveCname(domain);\n  } catch (error) {\n    const dnsError = error as DnsError;\n    if (dnsError.code !== 'ENOTFOUND' && dnsError.code !== 'ENODATA') {\n      cnameError = dnsError.message;\n    }\n    // ENOTFOUND/ENODATA for CNAME is normal for most domains\n  }\n\n  // Determine if domain can receive emails\n  const hasMxRecords = mxRecords.length > 0;\n  const hasCnameRecords = cnameRecords.length > 0;\n\n  if (hasMxRecords || hasCnameRecords) {\n    // Domain HAS MX or CNAME records - cannot safely receive emails\n    result.hasMxRecords = hasMxRecords;\n    result.mxRecords = mxRecords;\n    result.canReceiveEmails = false;\n    \n    if (hasMxRecords) {\n      result.error = `Domain has ${mxRecords.length} MX record(s) - email already configured`;\n    } else if (hasCnameRecords) {\n      result.error = `Domain has CNAME record(s) - conflicts with MX records`;\n    }\n  } else {\n    // Domain has no MX or CNAME records - can receive emails\n    result.hasMxRecords = false;\n    result.canReceiveEmails = true;\n    \n    if (mxError || cnameError) {\n      const errors = [mxError, cnameError].filter(Boolean);\n      result.error = `Domain check: ${errors.join(', ')} (safe for email receiving)`;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Batch check multiple domains\n * @param domains - Array of domains to check\n * @returns Promise<DnsCheckResult[]> - Array of results for each domain\n */\nexport async function checkMultipleDomainsCanReceiveEmails(\n  domains: string[]\n): Promise<DnsCheckResult[]> {\n  const promises = domains.map(domain => checkDomainCanReceiveEmails(domain));\n  return Promise.all(promises);\n}\n\n/**\n * Simple domain validation\n * @param domain - Domain to validate\n * @returns boolean - True if domain format is valid\n */\nfunction isValidDomain(domain: string): boolean {\n  const domainRegex = /^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n  return domainRegex.test(domain) && domain.length <= 253;\n}\n\n/**\n * Get detailed provider information including nameservers\n * @param domain - Domain to check\n * @returns Promise with detailed provider information\n */\nexport async function getDetailedProviderInfo(domain: string): Promise<{\n  domain: string;\n  provider: DomainProvider | null;\n  nameservers: string[];\n  checkedDomains: string[];\n  error?: string;\n}> {\n  const checkedDomains: string[] = [domain];\n  \n  try {\n    // Try original domain first\n    let nameservers: string[] = [];\n    try {\n      nameservers = await dns.resolveNs(domain);\n    } catch (error) {\n      // If original domain fails, try parent domains\n      const parentDomains = getParentDomains(domain);\n      checkedDomains.push(...parentDomains);\n      \n      for (const parentDomain of parentDomains) {\n        try {\n          nameservers = await dns.resolveNs(parentDomain);\n          break; // Use first successful parent domain\n        } catch (parentError) {\n          continue;\n        }\n      }\n    }\n    \n    const provider = await detectDomainProvider(domain);\n    \n    return {\n      domain,\n      provider,\n      nameservers,\n      checkedDomains,\n    };\n  } catch (error) {\n    const dnsError = error as DnsError;\n    return {\n      domain,\n      provider: null,\n      nameservers: [],\n      checkedDomains,\n      error: dnsError.message,\n    };\n  }\n}\n\n/**\n * Get detailed MX record information for a domain (for debugging)\n * @param domain - Domain to check\n * @returns Promise with detailed MX information\n */\nexport async function getDetailedMxInfo(domain: string): Promise<{\n  domain: string;\n  mxRecords: MxRecord[];\n  hasRecords: boolean;\n  error?: string;\n}> {\n  try {\n    const mxRecords = await dns.resolveMx(domain);\n    return {\n      domain,\n      mxRecords,\n      hasRecords: mxRecords.length > 0,\n    };\n  } catch (error) {\n    const dnsError = error as DnsError;\n    return {\n      domain,\n      mxRecords: [],\n      hasRecords: false,\n      error: dnsError.message,\n    };\n  }\n}\n\n/**\n * Verify TXT record exists and matches expected value (from dns-verification.ts)\n */\nexport async function verifyTxtRecord(name: string, expectedValue: string): Promise<DnsRecordCheck> {\n  const result: DnsRecordCheck = {\n    type: 'TXT',\n    name,\n    expectedValue,\n    actualValues: [],\n    isVerified: false,\n  }\n\n  try {\n    console.log(`🔍 TXT Verification - Checking TXT records for: ${name}`)\n    console.log(`🎯 TXT Verification - Expected value: ${expectedValue}`)\n    \n    const txtRecords = await dns.resolveTxt(name)\n    console.log(`📋 TXT Verification - Found ${txtRecords.length} TXT records:`, txtRecords)\n    \n    result.actualValues = txtRecords.flat()\n    console.log(`📊 TXT Verification - Flattened values:`, result.actualValues)\n    \n    result.isVerified = result.actualValues.some(value => value === expectedValue)\n    console.log(`✅ TXT Verification - Is verified: ${result.isVerified}`)\n    \n    if (!result.isVerified && result.actualValues.length > 0) {\n      console.log(`❌ TXT Verification - Expected \"${expectedValue}\" but found:`, result.actualValues)\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown DNS error'\n    console.log(`💥 TXT Verification - DNS lookup failed for ${name}:`, errorMessage)\n    \n    // Provide more user-friendly error messages\n    if (errorMessage.includes('ENODATA') || errorMessage.includes('ENOTFOUND')) {\n      result.error = `No TXT records found for ${name}. Please add the TXT record to your DNS.`\n    } else {\n      result.error = errorMessage\n    }\n    \n    result.isVerified = false\n  }\n\n  return result\n}\n\n/**\n * Verify MX record exists and matches expected value (from dns-verification.ts)\n */\nexport async function verifyMxRecord(name: string, expectedValue: string): Promise<DnsRecordCheck> {\n  const result: DnsRecordCheck = {\n    type: 'MX',\n    name,\n    expectedValue,\n    actualValues: [],\n    isVerified: false,\n  }\n\n  try {\n    console.log(`🔍 MX Verification - Checking MX records for: ${name}`)\n    console.log(`🎯 MX Verification - Expected value: ${expectedValue}`)\n    \n    const mxRecords = await dns.resolveMx(name)\n    console.log(`📋 MX Verification - Found ${mxRecords.length} MX records:`, mxRecords)\n    \n    result.actualValues = mxRecords.map(record => `${record.priority} ${record.exchange}`)\n    console.log(`📊 MX Verification - Formatted values:`, result.actualValues)\n    \n    result.isVerified = result.actualValues.some(value => value === expectedValue)\n    console.log(`✅ MX Verification - Is verified: ${result.isVerified}`)\n    \n    if (!result.isVerified && result.actualValues.length > 0) {\n      console.log(`❌ MX Verification - Expected \"${expectedValue}\" but found:`, result.actualValues)\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown DNS error'\n    console.log(`💥 MX Verification - DNS lookup failed for ${name}:`, errorMessage)\n    \n    // Provide more user-friendly error messages\n    if (errorMessage.includes('ENODATA') || errorMessage.includes('ENOTFOUND')) {\n      result.error = `No MX records found for ${name}. Please add the MX record to your DNS.`\n    } else {\n      result.error = errorMessage\n    }\n    \n    result.isVerified = false\n  }\n\n  return result\n}\n\n/**\n * Try alternative DNS resolution for TXT records using different resolvers\n */\nasync function tryAlternativeTxtResolution(name: string): Promise<string[][]> {\n  const resolvers = [\n    ['8.8.8.8', '8.8.4.4'], // Google DNS\n    ['1.1.1.1', '1.0.0.1'], // Cloudflare DNS\n    ['208.67.222.222', '208.67.220.220'], // OpenDNS\n  ]\n\n  for (const resolverIPs of resolvers) {\n    try {\n      console.log(`🔄 TXT Alternative - Trying resolver: ${resolverIPs.join(', ')}`)\n      const resolver = new Resolver()\n      resolver.setServers(resolverIPs)\n      \n      const txtRecords = await new Promise<string[][]>((resolve, reject) => {\n        resolver.resolveTxt(name, (err, records) => {\n          if (err) reject(err)\n          else resolve(records || [])\n        })\n      })\n      \n      if (txtRecords.length > 0) {\n        console.log(`✅ TXT Alternative - Found records with ${resolverIPs[0]}:`, txtRecords)\n        return txtRecords\n      }\n    } catch (error) {\n      console.log(`❌ TXT Alternative - Failed with ${resolverIPs[0]}:`, error instanceof Error ? error.message : 'Unknown error')\n      continue\n    }\n  }\n  \n  return []\n}\n\n/**\n * Try alternative DNS resolution using different resolvers (from dns-verification.ts)\n */\nasync function tryAlternativeMxResolution(name: string): Promise<Array<{priority: number, exchange: string}>> {\n  const resolvers = [\n    ['8.8.8.8', '8.8.4.4'], // Google DNS\n    ['1.1.1.1', '1.0.0.1'], // Cloudflare DNS\n    ['208.67.222.222', '208.67.220.220'], // OpenDNS\n  ]\n\n  for (const resolverIPs of resolvers) {\n    try {\n      console.log(`🔄 MX Alternative - Trying resolver: ${resolverIPs.join(', ')}`)\n      const resolver = new Resolver()\n      resolver.setServers(resolverIPs)\n      \n      const mxRecords = await new Promise<Array<{priority: number, exchange: string}>>((resolve, reject) => {\n        resolver.resolveMx(name, (err, records) => {\n          if (err) reject(err)\n          else resolve(records || [])\n        })\n      })\n      \n      if (mxRecords.length > 0) {\n        console.log(`✅ MX Alternative - Found records with ${resolverIPs[0]}:`, mxRecords)\n        return mxRecords\n      }\n    } catch (error) {\n      console.log(`❌ MX Alternative - Failed with ${resolverIPs[0]}:`, error instanceof Error ? error.message : 'Unknown error')\n      continue\n    }\n  }\n  \n  return []\n}\n\n/**\n * Enhanced MX record verification with fallback resolvers (from dns-verification.ts)\n */\nexport async function verifyMxRecordWithFallback(name: string, expectedValue: string): Promise<DnsRecordCheck> {\n  const result: DnsRecordCheck = {\n    type: 'MX',\n    name,\n    expectedValue,\n    actualValues: [],\n    isVerified: false,\n  }\n\n  try {\n    console.log(`🔍 MX Verification - Checking MX records for: ${name}`)\n    console.log(`🎯 MX Verification - Expected value: ${expectedValue}`)\n    \n    // Try default DNS first\n    let mxRecords: Array<{priority: number, exchange: string}> = []\n    try {\n      mxRecords = await dns.resolveMx(name)\n      console.log(`📋 MX Verification - Default DNS found ${mxRecords.length} MX records:`, mxRecords)\n    } catch (error) {\n      console.log(`⚠️ MX Verification - Default DNS failed, trying alternative resolvers...`)\n      mxRecords = await tryAlternativeMxResolution(name)\n    }\n    \n    result.actualValues = mxRecords.map(record => `${record.priority} ${record.exchange}`)\n    console.log(`📊 MX Verification - Formatted values:`, result.actualValues)\n    \n    result.isVerified = result.actualValues.some(value => value === expectedValue)\n    console.log(`✅ MX Verification - Is verified: ${result.isVerified}`)\n    \n    if (!result.isVerified && result.actualValues.length > 0) {\n      console.log(`❌ MX Verification - Expected \"${expectedValue}\" but found:`, result.actualValues)\n    }\n    \n    if (result.actualValues.length === 0) {\n      result.error = `No MX records found for ${name} using multiple DNS resolvers. Please add the MX record to your DNS.`\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown DNS error'\n    console.log(`💥 MX Verification - All DNS lookups failed for ${name}:`, errorMessage)\n    result.error = `DNS resolution failed: ${errorMessage}`\n    result.isVerified = false\n  }\n\n  return result\n}\n\n/**\n * Enhanced TXT record verification with fallback resolvers\n */\nexport async function verifyTxtRecordWithFallback(name: string, expectedValue: string): Promise<DnsRecordCheck> {\n  const result: DnsRecordCheck = {\n    type: 'TXT',\n    name,\n    expectedValue,\n    actualValues: [],\n    isVerified: false,\n  }\n\n  try {\n    console.log(`🔍 TXT Verification - Checking TXT records for: ${name}`)\n    console.log(`🎯 TXT Verification - Expected value: ${expectedValue}`)\n    \n    // Try default DNS first\n    let txtRecords: string[][] = []\n    try {\n      txtRecords = await dns.resolveTxt(name)\n      console.log(`📋 TXT Verification - Default DNS found ${txtRecords.length} TXT records:`, txtRecords)\n    } catch (error) {\n      console.log(`⚠️ TXT Verification - Default DNS failed, trying alternative resolvers...`)\n      txtRecords = await tryAlternativeTxtResolution(name)\n    }\n    \n    result.actualValues = txtRecords.flat()\n    console.log(`📊 TXT Verification - Flattened values:`, result.actualValues)\n    \n    result.isVerified = result.actualValues.some(value => value === expectedValue)\n    console.log(`✅ TXT Verification - Is verified: ${result.isVerified}`)\n    \n    if (!result.isVerified && result.actualValues.length > 0) {\n      console.log(`❌ TXT Verification - Expected \"${expectedValue}\" but found:`, result.actualValues)\n    }\n    \n    if (result.actualValues.length === 0) {\n      result.error = `No TXT records found for ${name} using multiple DNS resolvers. Please add the TXT record to your DNS.`\n    }\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Unknown DNS error'\n    console.log(`💥 TXT Verification - All DNS lookups failed for ${name}:`, errorMessage)\n    result.error = `DNS resolution failed: ${errorMessage}`\n    result.isVerified = false\n  }\n\n  return result\n}\n\n/**\n * Verify multiple DNS records (from dns-verification.ts)\n */\nexport async function verifyDnsRecords(records: Array<{\n  type: string\n  name: string\n  value: string\n}>): Promise<DnsRecordCheck[]> {\n  console.log(`📋 Starting verification of ${records.length} DNS records:`)\n  records.forEach((record, index) => {\n    console.log(`  ${index + 1}. ${record.type} record for ${record.name}`)\n  })\n  \n  const checks = records.map(async (record) => {\n    switch (record.type.toUpperCase()) {\n      case 'TXT':\n        return verifyTxtRecordWithFallback(record.name, record.value)\n      case 'MX':\n        return verifyMxRecordWithFallback(record.name, record.value)\n      default:\n        return {\n          type: record.type,\n          name: record.name,\n          expectedValue: record.value,\n          actualValues: [],\n          isVerified: false,\n          error: `Unsupported record type: ${record.type}`,\n        }\n    }\n  })\n\n  return Promise.all(checks)\n} ","import { getEndpointPlugin } from \"@smithy/middleware-endpoint\";\nimport { getSerdePlugin } from \"@smithy/middleware-serde\";\nimport { Command as $Command } from \"@smithy/smithy-client\";\nimport { commonParams } from \"../endpoint/EndpointParameters\";\nimport { de_GetIdentityVerificationAttributesCommand, se_GetIdentityVerificationAttributesCommand, } from \"../protocols/Aws_query\";\nexport { $Command };\nexport class GetIdentityVerificationAttributesCommand extends $Command\n    .classBuilder()\n    .ep(commonParams)\n    .m(function (Command, cs, config, o) {\n    return [\n        getSerdePlugin(config, this.serialize, this.deserialize),\n        getEndpointPlugin(config, Command.getEndpointParameterInstructions()),\n    ];\n})\n    .s(\"SimpleEmailService\", \"GetIdentityVerificationAttributes\", {})\n    .n(\"SESClient\", \"GetIdentityVerificationAttributesCommand\")\n    .f(void 0, void 0)\n    .ser(se_GetIdentityVerificationAttributesCommand)\n    .de(de_GetIdentityVerificationAttributesCommand)\n    .build() {\n}\n","import { NextRequest, NextResponse } from 'next/server'\nimport { getDomainWithRecords, updateDomainStatus, areAllDnsRecordsVerified } from '@/lib/db/domains'\nimport { verifyDnsRecords } from '@/lib/domains-and-dns/dns'\nimport { initiateDomainVerification } from '@/lib/domains-and-dns/domain-verification'\nimport { auth } from '@/lib/auth/auth'\nimport { headers } from 'next/headers'\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Get user session\n    const session = await auth.api.getSession({\n      headers: await headers()\n    })\n\n    if (!session?.user?.id) {\n      return NextResponse.json(\n        { error: 'Unauthorized' },\n        { status: 401 }\n      )\n    }\n\n    const { domain, domainId } = await request.json()\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: 'Domain is required' },\n        { status: 400 }\n      )\n    }\n\n    // Get domain record from database\n    let domainRecord = await getDomainWithRecords(domain, session.user.id)\n    if (!domainRecord) {\n      return NextResponse.json(\n        { error: 'Domain not found. Please run DNS check first.' },\n        { status: 404 }\n      )\n    }\n\n    try {\n      // Use the shared verification function\n      const verificationResult = await initiateDomainVerification(domain, session.user.id)\n      \n      // If this is a re-verification (domain already has DNS records), check them\n      if (domainRecord.dnsRecords.length > 0) {\n        const requiredDnsRecords = verificationResult.dnsRecords.map(record => ({\n          type: record.type,\n          name: record.name,\n          value: record.value\n        }))\n\n        // Check DNS records if SES is verified\n        if (verificationResult.sesStatus === 'Success') {\n          const dnsChecks = await verifyDnsRecords(requiredDnsRecords)\n          const allDnsVerified = dnsChecks.every(check => check.isVerified)\n          \n          if (allDnsVerified) {\n            verificationResult.status = 'verified'\n            await updateDomainStatus(domainRecord.id, 'verified')\n          }\n\n          // Update DNS records status with actual verification results\n          verificationResult.dnsRecords = dnsChecks.map(check => ({\n            type: check.type,\n            name: check.name,\n            value: check.expectedValue,\n            isVerified: check.isVerified\n          }))\n        }\n      }\n\n      return NextResponse.json({\n        ...verificationResult,\n        timestamp: new Date()\n      })\n\n    } catch (error) {\n      console.error('Domain verification error:', error)\n      \n      return NextResponse.json(\n        { \n          error: error instanceof Error ? error.message : 'Failed to verify domain with AWS SES',\n          domain,\n          domainId: domainRecord.id,\n          verificationToken: '',\n          status: 'failed' as const,\n          dnsRecords: domainRecord.dnsRecords.map(r => ({\n            type: r.recordType,\n            name: r.name,\n            value: r.value,\n            isVerified: r.isVerified\n          })),\n          timestamp: new Date()\n        },\n        { status: 500 }\n      )\n    }\n\n  } catch (error) {\n    console.error('Domain verification error:', error)\n    return NextResponse.json(\n      { error: 'Failed to verify domain' },\n      { status: 500 }\n    )\n  }\n} ","import {\n  AppRouteRouteModule,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks"],"mappings":"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","ignoreList":[1,3]}
{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server-edge.ts","turbopack:///[project]/app/api/v2/mail/thread-counts/route.ts","turbopack:///[project]/node_modules/next/dist/src/build/templates/app-route.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-rsc'\n].ReactServerDOMTurbopackServerEdge\n","import { NextRequest, NextResponse } from 'next/server'\nimport { validateRequest } from '../../helper/main'\nimport { db } from '@/lib/db'\nimport { structuredEmails, sentEmails } from '@/lib/db/schema'\nimport { eq, and, or, inArray, like, sql } from 'drizzle-orm'\n\n/**\n * POST /api/v2/mail/thread-counts\n * Gets thread counts for multiple emails in batch\n * Efficiently calculates conversation thread sizes for inbox listing\n * Supports both session-based auth and API key auth\n * Has tests? ❌\n * Has logging? ✅\n * Has types? ✅\n */\n\ninterface ThreadCountsRequest {\n    emailIds: string[]\n}\n\ninterface ThreadCountResult {\n    emailId: string\n    threadCount: number\n    hasThread: boolean // true if thread count > 1\n}\n\ninterface ThreadCountsResponse {\n    success: boolean\n    data: ThreadCountResult[]\n    error?: string\n}\n\n/**\n * Helper function to parse and clean message IDs\n */\nfunction cleanMessageId(messageId: string): string {\n    return messageId.replace(/[<>]/g, '').trim()\n}\n\n/**\n * Helper function to parse References header\n */\nfunction parseReferences(referencesHeader: string): string[] {\n    if (!referencesHeader) return []\n    \n    // Split by whitespace and newlines, then clean each ID\n    return referencesHeader\n        .split(/\\s+/)\n        .map(ref => cleanMessageId(ref))\n        .filter(ref => ref.length > 0)\n}\n\n/**\n * Get all related message IDs for threading\n */\nfunction getAllThreadMessageIds(email: any): Set<string> {\n    const messageIds = new Set<string>()\n    \n    // Add this email's message ID\n    if (email.messageId) {\n        messageIds.add(cleanMessageId(email.messageId))\n    }\n    \n    // Add In-Reply-To if available\n    try {\n        const headers = email.headers ? JSON.parse(email.headers) : {}\n        if (headers['In-Reply-To']) {\n            messageIds.add(cleanMessageId(headers['In-Reply-To']))\n        }\n        \n        // Add all References\n        if (headers['References']) {\n            const refs = parseReferences(headers['References'])\n            refs.forEach(ref => messageIds.add(ref))\n        }\n    } catch (e) {\n        // Ignore parsing errors\n    }\n    \n    // Add from direct fields\n    if (email.inReplyTo) {\n        messageIds.add(cleanMessageId(email.inReplyTo))\n    }\n    \n    if (email.references) {\n        try {\n            const refs = parseReferences(email.references)\n            refs.forEach(ref => messageIds.add(ref))\n        } catch (e) {\n            // Ignore parsing errors\n        }\n    }\n    \n    return messageIds\n}\n\nexport async function POST(request: NextRequest) {\n    try {\n        const { userId, error } = await validateRequest(request)\n        \n        if (error) {\n            return NextResponse.json(\n                { success: false, error },\n                { status: 401 }\n            )\n        }\n\n        const body: ThreadCountsRequest = await request.json()\n        \n        if (!body.emailIds || !Array.isArray(body.emailIds)) {\n            return NextResponse.json(\n                { success: false, error: 'emailIds array is required' },\n                { status: 400 }\n            )\n        }\n\n        // Batch fetch all requested emails\n        const emails = await db\n            .select({\n                id: structuredEmails.id,\n                messageId: structuredEmails.messageId,\n                inReplyTo: structuredEmails.inReplyTo,\n                references: structuredEmails.references,\n                headers: structuredEmails.headers,\n                subject: structuredEmails.subject\n            })\n            .from(structuredEmails)\n            .where(\n                and(\n                    eq(structuredEmails.userId, userId!),\n                    inArray(structuredEmails.id, body.emailIds)\n                )\n            )\n\n        const results: ThreadCountResult[] = []\n\n        // Process each email to find its thread count\n        for (const email of emails) {\n            try {\n                // Get all potential message IDs for this thread\n                const threadMessageIds = getAllThreadMessageIds(email)\n                \n                if (threadMessageIds.size === 0) {\n                    // No threading info, it's a single message\n                    results.push({\n                        emailId: email.id,\n                        threadCount: 1,\n                        hasThread: false\n                    })\n                    continue\n                }\n\n                // Convert Set to Array for database query\n                const messageIdArray = Array.from(threadMessageIds)\n\n                // Count related emails in structuredEmails\n                const [inboundCountResult] = await db\n                    .select({ count: sql<number>`count(*)` })\n                    .from(structuredEmails)\n                    .where(\n                        and(\n                            eq(structuredEmails.userId, userId!),\n                            or(\n                                inArray(structuredEmails.messageId, messageIdArray),\n                                inArray(structuredEmails.inReplyTo, messageIdArray),\n                                ...messageIdArray.map(id => \n                                    like(structuredEmails.references, `%${id}%`)\n                                )\n                            )\n                        )\n                    )\n\n                // Count related emails in sentEmails  \n                const [outboundCountResult] = await db\n                    .select({ count: sql<number>`count(*)` })\n                    .from(sentEmails)\n                    .where(\n                        and(\n                            eq(sentEmails.userId, userId!),\n                            or(\n                                ...messageIdArray.map(id => \n                                    like(sentEmails.headers, `%${id}%`)\n                                )\n                            )\n                        )\n                    )\n\n                // Also try subject-based fallback for better threading\n                let subjectCountResult = { count: 0 }\n                if (email.subject) {\n                    // Clean subject (remove Re:, Fwd:, etc.)\n                    const cleanSubject = email.subject\n                        .replace(/^(re|fwd?|fw):\\s*/gi, '')\n                        .trim()\n                    \n                    if (cleanSubject.length > 3) {\n                        const [subjectResult] = await db\n                            .select({ count: sql<number>`count(*)` })\n                            .from(structuredEmails)\n                            .where(\n                                and(\n                                    eq(structuredEmails.userId, userId!),\n                                    like(structuredEmails.subject, `%${cleanSubject}%`)\n                                )\n                            )\n                        subjectCountResult = subjectResult\n                    }\n                }\n\n                // Use the highest count (header-based or subject-based)\n                const headerBasedCount = (inboundCountResult?.count || 0) + (outboundCountResult?.count || 0)\n                const finalCount = Math.max(headerBasedCount, subjectCountResult.count, 1)\n\n                results.push({\n                    emailId: email.id,\n                    threadCount: finalCount,\n                    hasThread: finalCount > 1\n                })\n\n            } catch (error) {\n                console.error(`Error calculating thread count for email ${email.id}:`, error)\n                // Default to single message on error\n                results.push({\n                    emailId: email.id,\n                    threadCount: 1,\n                    hasThread: false\n                })\n            }\n        }\n\n        // Add results for any emails that weren't found (shouldn't happen, but be safe)\n        const foundEmailIds = new Set(results.map(r => r.emailId))\n        for (const emailId of body.emailIds) {\n            if (!foundEmailIds.has(emailId)) {\n                results.push({\n                    emailId,\n                    threadCount: 1,\n                    hasThread: false\n                })\n            }\n        }\n\n        console.log(`📧 Thread counts calculated for ${results.length} emails for user ${userId}`)\n\n        return NextResponse.json(\n            { \n                success: true, \n                data: results \n            }\n        )\n\n    } catch (error) {\n        console.error('Thread counts API error:', error)\n        return NextResponse.json(\n            { \n                success: false, \n                error: 'Internal server error' \n            },\n            { status: 500 }\n        )\n    }\n} ","import {\n  AppRouteRouteModule,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackServerEdge","AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks"],"mappings":"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","ignoreList":[0,2]}
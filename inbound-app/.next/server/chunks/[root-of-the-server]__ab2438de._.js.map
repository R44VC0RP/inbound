{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server-edge.ts","turbopack:///[project]/app/api/v2/mail/[id]/thread/route.ts","turbopack:///[project]/node_modules/next/dist/src/build/templates/app-route.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-rsc'\n].ReactServerDOMTurbopackServerEdge\n","import { NextRequest, NextResponse } from 'next/server'\nimport { validateRequest } from '../../../helper/main'\nimport { db } from '@/lib/db'\nimport { structuredEmails, sentEmails } from '@/lib/db/schema'\nimport { eq, and, or, inArray, like } from 'drizzle-orm'\n\n/**\n * GET /api/v2/mail/[id]/thread\n * Gets all emails in a conversation thread for a given email ID\n * Implements advanced threading based on RFC 2822 and modern email client practices\n * Supports both session-based auth and API key auth\n * Has tests? ‚ùå\n * Has logging? ‚úÖ\n * Has types? ‚úÖ\n */\n\nexport interface ThreadMessage {\n    id: string\n    messageId: string | null\n    type: 'inbound' | 'outbound'\n    subject: string | null\n    from: string\n    fromName: string | null\n    to: string\n    receivedAt: Date | null\n    sentAt: Date | null\n    content: {\n        textBody: string | null\n        htmlBody: string | null\n        attachments: Array<{\n            filename?: string\n            contentType?: string\n            size?: number\n            contentId?: string\n            contentDisposition?: string\n        }>\n    }\n    addresses: {\n        from: {\n            text: string\n            addresses: Array<{\n                name: string | null\n                address: string | null\n            }>\n        } | null\n        to: {\n            text: string\n            addresses: Array<{\n                name: string | null\n                address: string | null\n            }>\n        } | null\n    }\n    metadata: {\n        inReplyTo: string | null\n        references: string[]\n        parseSuccess: boolean | null\n        parseError: string | null\n    }\n    isRead: boolean\n    readAt: Date | null\n}\n\nexport interface GetThreadResponse {\n    messages: ThreadMessage[]\n    totalCount: number\n    threadId: string // The root message ID of the thread\n}\n\n/**\n * Clean and normalize a message ID by removing angle brackets and whitespace\n */\nfunction cleanMessageId(messageId: string): string {\n    if (!messageId) return ''\n    return messageId.replace(/[<>]/g, '').trim()\n}\n\n/**\n * Normalize subject line for threading by removing common prefixes\n */\nfunction normalizeSubject(subject: string): string {\n    if (!subject) return ''\n    \n    // Remove common reply/forward prefixes (case insensitive)\n    let normalized = subject.trim()\n    \n    // Remove RE:, Re:, R:, FWD:, Fwd:, etc.\n    const prefixPattern = /^(re|r|fwd|fw|aw|wg|vs|sv):\\s*/i\n    while (prefixPattern.test(normalized)) {\n        normalized = normalized.replace(prefixPattern, '').trim()\n    }\n    \n    return normalized.toLowerCase()\n}\n\n/**\n * Parse references header which can be multi-line and contain multiple message IDs\n */\nfunction parseReferences(referencesStr: string): string[] {\n    if (!referencesStr) return []\n    \n    try {\n        // Handle JSON stored references\n        if (referencesStr.startsWith('[')) {\n            const parsed = JSON.parse(referencesStr)\n            if (Array.isArray(parsed)) {\n                return parsed.map(cleanMessageId).filter(id => id)\n            }\n        }\n        \n        // Handle raw RFC 2822 references (space or newline separated)\n        const messageIds = referencesStr\n            .replace(/\\s+/g, ' ') // Normalize whitespace\n            .split(' ')\n            .map(cleanMessageId)\n            .filter(id => id)\n        \n        return messageIds\n    } catch (e) {\n        console.error('Failed to parse references:', e)\n        return []\n    }\n}\n\n/**\n * Get all message IDs that should be considered part of the same thread\n */\nasync function getThreadMessageIds(userId: string, emailId: string) {\n    console.log('üîó Getting thread message IDs for email:', emailId)\n    \n    // Get the original email to understand its threading info\n    const originalEmail = await db\n        .select({\n            id: structuredEmails.id,\n            messageId: structuredEmails.messageId,\n            inReplyTo: structuredEmails.inReplyTo,\n            references: structuredEmails.references,\n            subject: structuredEmails.subject,\n            userId: structuredEmails.userId\n        })\n        .from(structuredEmails)\n        .where(\n            and(\n                eq(structuredEmails.id, emailId),\n                eq(structuredEmails.userId, userId)\n            )\n        )\n        .limit(1)\n\n    if (originalEmail.length === 0) {\n        return { messageIds: [], normalizedSubject: '' }\n    }\n\n    const original = originalEmail[0]\n    const threadMessageIds = new Set<string>()\n    \n    // Add the current message ID\n    if (original.messageId) {\n        threadMessageIds.add(cleanMessageId(original.messageId))\n    }\n    \n    // Add inReplyTo if it exists\n    if (original.inReplyTo) {\n        threadMessageIds.add(cleanMessageId(original.inReplyTo))\n    }\n    \n    // Parse and add all references\n    if (original.references) {\n        const refs = parseReferences(original.references)\n        refs.forEach(ref => threadMessageIds.add(ref))\n    }\n    \n    // Now do recursive lookup to find all related messages\n    const processedIds = new Set<string>()\n    const toProcess = Array.from(threadMessageIds)\n    \n    while (toProcess.length > 0) {\n        const currentId = toProcess.pop()!\n        if (processedIds.has(currentId)) continue\n        \n        processedIds.add(currentId)\n        \n        // Find emails that reference this message ID in their references or inReplyTo\n        const relatedEmails = await db\n            .select({\n                messageId: structuredEmails.messageId,\n                inReplyTo: structuredEmails.inReplyTo,\n                references: structuredEmails.references\n            })\n            .from(structuredEmails)\n            .where(\n                and(\n                    eq(structuredEmails.userId, userId),\n                    or(\n                        eq(structuredEmails.messageId, currentId),\n                        eq(structuredEmails.inReplyTo, `<${currentId}>`),\n                        like(structuredEmails.references, `%${currentId}%`)\n                    )\n                )\n            )\n        \n        // Find sent emails that reference this message ID\n        const relatedSentEmails = await db\n            .select({\n                messageId: sentEmails.messageId,\n                headers: sentEmails.headers\n            })\n            .from(sentEmails)\n            .where(\n                and(\n                    eq(sentEmails.userId, userId),\n                    or(\n                        eq(sentEmails.messageId, currentId),\n                        like(sentEmails.headers, `%${currentId}%`)\n                    )\n                )\n            )\n        \n        // Process related emails\n        for (const email of relatedEmails) {\n            if (email.messageId) {\n                const cleanId = cleanMessageId(email.messageId)\n                if (!processedIds.has(cleanId)) {\n                    threadMessageIds.add(cleanId)\n                    toProcess.push(cleanId)\n                }\n            }\n            \n            if (email.inReplyTo) {\n                const cleanId = cleanMessageId(email.inReplyTo)\n                if (!processedIds.has(cleanId)) {\n                    threadMessageIds.add(cleanId)\n                    toProcess.push(cleanId)\n                }\n            }\n            \n            if (email.references) {\n                const refs = parseReferences(email.references)\n                refs.forEach(ref => {\n                    if (!processedIds.has(ref)) {\n                        threadMessageIds.add(ref)\n                        toProcess.push(ref)\n                    }\n                })\n            }\n        }\n        \n        // Process related sent emails\n        for (const email of relatedSentEmails) {\n            if (email.messageId) {\n                const cleanId = cleanMessageId(email.messageId)\n                if (!processedIds.has(cleanId)) {\n                    threadMessageIds.add(cleanId)\n                    toProcess.push(cleanId)\n                }\n            }\n            \n            if (email.headers) {\n                try {\n                    const headers: Record<string, any> = JSON.parse(email.headers)\n                    if (headers['In-Reply-To']) {\n                        const cleanId = cleanMessageId(headers['In-Reply-To'])\n                        if (!processedIds.has(cleanId)) {\n                            threadMessageIds.add(cleanId)\n                            toProcess.push(cleanId)\n                        }\n                    }\n                    if (headers['References']) {\n                        const refs = parseReferences(headers['References'])\n                        refs.forEach(ref => {\n                            if (!processedIds.has(ref)) {\n                                threadMessageIds.add(ref)\n                                toProcess.push(ref)\n                            }\n                        })\n                    }\n                } catch (e) {\n                    console.error('Failed to parse sent email headers:', e)\n                }\n            }\n        }\n    }\n    \n    const normalizedSubject = normalizeSubject(original.subject || '')\n    \n    console.log(`üîó Found ${threadMessageIds.size} message IDs in thread:`, Array.from(threadMessageIds))\n    \n    return { \n        messageIds: Array.from(threadMessageIds).filter(id => id), \n        normalizedSubject \n    }\n}\n\nexport async function GET(\n    request: NextRequest,\n    { params }: { params: Promise<{ id: string }> }\n) {\n    console.log('üßµ GET /api/v2/mail/[id]/thread - Starting request')\n    \n    try {\n        console.log('üîê Validating request authentication')\n        const { userId, error } = await validateRequest(request)\n        if (!userId) {\n            console.log('‚ùå Authentication failed:', error)\n            return NextResponse.json(\n                { error: error },\n                { status: 401 }\n            )\n        }\n        console.log('‚úÖ Authentication successful for userId:', userId)\n        \n        const { id } = await params\n        console.log('üì® Requested thread for email ID:', id)\n\n        // Validate email ID\n        if (!id || typeof id !== 'string') {\n            console.log('‚ö†Ô∏è Invalid email ID provided:', id)\n            return NextResponse.json(\n                { error: 'Valid email ID is required' },\n                { status: 400 }\n            )\n        }\n\n        // Get all message IDs in the thread\n        const { messageIds: threadMessageIds, normalizedSubject } = await getThreadMessageIds(userId, id)\n        \n        if (threadMessageIds.length === 0) {\n            console.log('üì≠ No threading information found, treating as single email')\n            threadMessageIds.push(id) // Fallback to just the requested email\n        }\n\n        // Fetch all inbound emails in the thread\n        console.log('üì• Fetching inbound emails in thread')\n        let inboundEmails = await db\n            .select()\n            .from(structuredEmails)\n            .where(\n                and(\n                    eq(structuredEmails.userId, userId),\n                    or(\n                        inArray(structuredEmails.messageId, threadMessageIds),\n                        inArray(structuredEmails.inReplyTo, threadMessageIds.map(id => `<${id}>`)),\n                        eq(structuredEmails.id, id) // Always include the requested email\n                    )\n                )\n            )\n\n        // Fetch all outbound emails in the thread\n        console.log('üì§ Fetching outbound emails in thread')\n        let outboundEmails = await db\n            .select()\n            .from(sentEmails)\n            .where(\n                and(\n                    eq(sentEmails.userId, userId),\n                    or(\n                        inArray(sentEmails.messageId, threadMessageIds)\n                    )\n                )\n            )\n\n        // Subject-based fallback threading if we didn't find enough messages\n        if (inboundEmails.length + outboundEmails.length <= 1 && normalizedSubject) {\n            console.log('üîÑ Attempting subject-based threading fallback')\n            \n            // Find emails with similar subjects\n            const subjectInboundEmails = await db\n                .select()\n                .from(structuredEmails)\n                .where(\n                    and(\n                        eq(structuredEmails.userId, userId),\n                        like(structuredEmails.subject, `%${normalizedSubject}%`)\n                    )\n                )\n            \n            const subjectOutboundEmails = await db\n                .select()\n                .from(sentEmails)\n                .where(\n                    and(\n                        eq(sentEmails.userId, userId),\n                        like(sentEmails.subject, `%${normalizedSubject}%`)\n                    )\n                )\n            \n            // Filter to only include emails with matching normalized subjects\n            const filteredInbound = subjectInboundEmails.filter(email => \n                normalizeSubject(email.subject || '') === normalizedSubject\n            )\n            \n            const filteredOutbound = subjectOutboundEmails.filter(email => \n                normalizeSubject(email.subject || '') === normalizedSubject\n            )\n            \n            if (filteredInbound.length > inboundEmails.length) {\n                console.log(`üìß Subject threading found ${filteredInbound.length} additional inbound emails`)\n                inboundEmails = filteredInbound\n            }\n            \n            if (filteredOutbound.length > outboundEmails.length) {\n                console.log(`üì§ Subject threading found ${filteredOutbound.length} additional outbound emails`)\n                outboundEmails = filteredOutbound\n            }\n        }\n\n        console.log(`üìä Found ${inboundEmails.length} inbound and ${outboundEmails.length} outbound emails`)\n\n        // Convert to thread messages format\n        const messages: ThreadMessage[] = []\n\n        // Process inbound emails\n        for (const email of inboundEmails) {\n            let fromData = null\n            let toData = null\n            let attachments = []\n\n            try {\n                fromData = email.fromData ? JSON.parse(email.fromData) : null\n                toData = email.toData ? JSON.parse(email.toData) : null\n                attachments = email.attachments ? JSON.parse(email.attachments) : []\n            } catch (e) {\n                console.error('Failed to parse email data:', e)\n            }\n\n            let references: string[] = []\n            try {\n                references = email.references ? parseReferences(email.references) : []\n            } catch (e) {\n                console.error('Failed to parse references:', e)\n            }\n\n            messages.push({\n                id: email.id,\n                messageId: email.messageId,\n                type: 'inbound',\n                subject: email.subject,\n                from: fromData?.text || 'Unknown Sender',\n                fromName: fromData?.addresses?.[0]?.name || null,\n                to: toData?.text || toData?.addresses?.[0]?.address || 'Unknown Recipient',\n                receivedAt: email.date,\n                sentAt: null,\n                content: {\n                    textBody: email.textBody,\n                    htmlBody: email.htmlBody,\n                    attachments: attachments\n                },\n                addresses: {\n                    from: fromData,\n                    to: toData\n                },\n                metadata: {\n                    inReplyTo: email.inReplyTo,\n                    references: references,\n                    parseSuccess: email.parseSuccess,\n                    parseError: email.parseError\n                },\n                isRead: email.isRead || false,\n                readAt: email.readAt\n            })\n        }\n\n        // Process outbound emails\n        for (const email of outboundEmails) {\n            let toAddresses: string[] = []\n            let headers: Record<string, any> = {}\n            let attachments: any[] = []\n\n            try {\n                toAddresses = email.to ? JSON.parse(email.to) : []\n                headers = email.headers ? JSON.parse(email.headers) : {}\n                attachments = email.attachments ? JSON.parse(email.attachments) : []\n            } catch (e) {\n                console.error('Failed to parse sent email data:', e)\n            }\n\n            const references: string[] = headers['References'] ? parseReferences(headers['References']) : []\n\n            messages.push({\n                id: email.id,\n                messageId: email.messageId,\n                type: 'outbound',\n                subject: email.subject,\n                from: email.from,\n                fromName: null,\n                to: toAddresses.join(', '),\n                receivedAt: null,\n                sentAt: email.sentAt,\n                content: {\n                    textBody: email.textBody,\n                    htmlBody: email.htmlBody,\n                    attachments: attachments\n                },\n                addresses: {\n                    from: {\n                        text: email.from,\n                        addresses: [{\n                            name: null,\n                            address: email.fromAddress\n                        }]\n                    },\n                    to: {\n                        text: toAddresses.join(', '),\n                        addresses: toAddresses.map((addr: string) => ({\n                            name: null,\n                            address: addr\n                        }))\n                    }\n                },\n                metadata: {\n                    inReplyTo: headers['In-Reply-To'] || null,\n                    references: references,\n                    parseSuccess: true,\n                    parseError: null\n                },\n                isRead: true, // Sent emails are always \"read\"\n                readAt: email.sentAt\n            })\n        }\n\n        // Sort messages by date (oldest first)\n        messages.sort((a, b) => {\n            const dateA = a.receivedAt || a.sentAt || new Date(0)\n            const dateB = b.receivedAt || b.sentAt || new Date(0)\n            return new Date(dateA).getTime() - new Date(dateB).getTime()\n        })\n\n        // Determine thread ID (usually the first message's ID or the normalized subject)\n        const threadId = messages.length > 0 \n            ? (messages[0].messageId || messages[0].id) \n            : (normalizedSubject || id)\n\n        console.log(`‚úÖ Successfully retrieved thread with ${messages.length} messages`)\n        return NextResponse.json({\n            messages,\n            totalCount: messages.length,\n            threadId\n        })\n\n    } catch (error) {\n        console.error('üí• Unexpected error in GET /api/v2/mail/[id]/thread:', error)\n        return NextResponse.json(\n            { error: 'Internal server error' },\n            { status: 500 }\n        )\n    }\n} ","import {\n  AppRouteRouteModule,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackServerEdge","AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks"],"mappings":"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","ignoreList":[0,2]}
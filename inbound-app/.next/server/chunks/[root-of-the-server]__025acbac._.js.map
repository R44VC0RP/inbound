{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server-edge.ts","turbopack:///[project]/node_modules/deepmerge/dist/cjs.js","turbopack:///[project]/lib/email-management/email-parser.ts","turbopack:///[project]/app/api/v2/mail/route.ts","turbopack:///[project]/node_modules/next/dist/src/build/templates/app-route.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-rsc'\n].ReactServerDOMTurbopackServerEdge\n","'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","/**\n * Core email parsing utilities using mailparser for processing raw email content.\n * Provides the main parseEmail function for converting raw email strings into structured ParsedEmailData objects.\n * Used extensively throughout the application for webhook processing, email routing, and data storage.\n * Includes HTML sanitization and type definitions for consistent email data handling.\n */\nimport { simpleParser, ParsedMail, Attachment } from 'mailparser'\n\n// Types for the parsed email data structure\ninterface ParsedEmailAddress {\n  text: string\n  addresses: Array<{\n    name: string | null\n    address: string | null\n  }>\n}\n\n// Header value types for complex header structures\ninterface ParsedEmailHeaderValue {\n  value?: Array<{\n    address: string\n    name: string\n  }> | string\n  html?: string\n  text?: string\n  params?: Record<string, string>\n}\n\ninterface ParsedEmailListHeader {\n  unsubscribe?: {\n    url: string\n  }\n  'unsubscribe-post'?: {\n    name: string\n  }\n}\n\ninterface ParsedEmailData {\n  messageId: string | undefined\n  date: Date | undefined\n  subject: string | undefined\n  from: ParsedEmailAddress | null\n  to: ParsedEmailAddress | null\n  cc: ParsedEmailAddress | null\n  bcc: ParsedEmailAddress | null\n  replyTo: ParsedEmailAddress | null\n  inReplyTo: string | undefined\n  references: string[] | undefined\n  textBody: string | undefined\n  htmlBody: string | undefined\n  raw?: string\n  attachments: Array<{\n    filename: string | undefined\n    contentType: string | undefined\n    size: number | undefined\n    contentId: string | undefined\n    contentDisposition: string | undefined\n  }>\n  headers: Record<string, any> & {\n    'return-path'?: ParsedEmailHeaderValue\n    'received'?: string | string[]\n    'received-spf'?: string\n    'authentication-results'?: string\n    'x-ses-receipt'?: string\n    'x-ses-dkim-signature'?: string\n    'dkim-signature'?: Array<{\n      value: string\n      params: Record<string, string>\n    }> | ParsedEmailHeaderValue\n    'list'?: ParsedEmailListHeader\n    'x-entity-ref-id'?: string\n    'from'?: ParsedEmailHeaderValue\n    'to'?: ParsedEmailHeaderValue\n    'subject'?: string\n    'message-id'?: string\n    'date'?: string\n    'mime-version'?: string\n    'content-type'?: {\n      value: string\n      params: Record<string, string>\n    }\n    'feedback-id'?: string\n    'x-ses-outgoing'?: string\n  }\n  priority: string | false | undefined\n}\n\nexport async function parseEmail(emailContent: string): Promise<ParsedEmailData> {\n  try {\n    // Parse the email\n    const parsed = await simpleParser(emailContent);\n    \n    // Helper function to extract address info\n    const extractAddressInfo = (addressObj: any): ParsedEmailAddress | null => {\n      if (!addressObj) return null;\n      \n      if (Array.isArray(addressObj)) {\n        return {\n          text: addressObj.map(addr => addr.text || `${addr.name || ''} <${addr.address || ''}>`).join(', '),\n          addresses: addressObj.map(addr => ({\n            name: addr.name || null,\n            address: addr.address || null\n          }))\n        };\n      } else if (addressObj.value && Array.isArray(addressObj.value)) {\n        // Handle AddressObject with value array\n        return {\n          text: addressObj.text,\n          addresses: addressObj.value.map((addr: any) => ({\n            name: addr.name || null,\n            address: addr.address || null\n          }))\n        };\n      } else if (addressObj.value) {\n        // Handle AddressObject with single value\n        return {\n          text: addressObj.text,\n          addresses: [{\n            name: addressObj.value.name || null,\n            address: addressObj.value.address || null\n          }]\n        };\n      } else {\n        // Handle direct address object\n        return {\n          text: addressObj.text || `${addressObj.name || ''} <${addressObj.address || ''}>`,\n          addresses: [{\n            name: addressObj.name || null,\n            address: addressObj.address || null\n          }]\n        };\n      }\n    };\n    \n    // Extract key information\n    const emailData: ParsedEmailData = {\n      messageId: parsed.messageId,\n      date: parsed.date,\n      subject: parsed.subject,\n      from: extractAddressInfo(parsed.from),\n      to: extractAddressInfo(parsed.to),\n      cc: extractAddressInfo(parsed.cc),\n      bcc: extractAddressInfo(parsed.bcc),\n      replyTo: extractAddressInfo(parsed.replyTo),\n      inReplyTo: parsed.inReplyTo,\n      references: Array.isArray(parsed.references) ? parsed.references : parsed.references ? [parsed.references] : undefined,\n      textBody: parsed.text,\n      htmlBody: parsed.html || undefined,\n      raw: emailContent,\n      attachments: parsed.attachments?.map(att => ({\n        filename: att.filename,\n        contentType: att.contentType,\n        size: att.size,\n        contentId: att.contentId,\n        contentDisposition: att.contentDisposition\n      })) || [],\n      headers: Object.fromEntries(parsed.headers),\n      priority: parsed.priority\n    };\n    \n    // Return the full parsed data for programmatic use\n    return emailData;\n    \n  } catch (error) {\n    console.error('Error parsing email:', error);\n    throw error;\n  }\n}\n\n// Legacy interface for backward compatibility\ninterface ParsedEmail {\n  headers: Record<string, string>\n  htmlBody: string | null\n  textBody: string | null\n  attachments: Array<{\n    filename: string\n    contentType: string\n    size: number\n    contentId?: string\n    isInline?: boolean\n  }>\n}\n\n// Process inline images by converting Content-ID references to data URLs\nfunction processInlineImages(html: string, attachments: Attachment[]): string {\n  if (!html || !attachments) return html\n\n  let processedHtml = html\n\n  // Create a map of Content-ID to attachment data\n  const cidMap = new Map<string, string>()\n  \n  for (const attachment of attachments) {\n    if (attachment.contentId && attachment.content) {\n      // Remove angle brackets from Content-ID if present\n      const cleanCid = attachment.contentId.replace(/^<|>$/g, '')\n      \n      // Convert attachment content to base64 data URL\n      const base64Data = attachment.content.toString('base64')\n      const dataUrl = `data:${attachment.contentType || 'application/octet-stream'};base64,${base64Data}`\n      \n      cidMap.set(cleanCid, dataUrl)\n    }\n  }\n\n  // Replace Content-ID references in HTML\n  for (const [cid, dataUrl] of cidMap) {\n    // Replace various formats of Content-ID references\n    const patterns = [\n      new RegExp(`src-cid=[\"']${cid}[\"']`, 'gi'),\n      new RegExp(`src=[\"']cid:${cid}[\"']`, 'gi'),\n      new RegExp(`src=[\"']${cid}[\"']`, 'gi'),\n    ]\n\n    for (const pattern of patterns) {\n      processedHtml = processedHtml.replace(pattern, `src=\"${dataUrl}\"`)\n    }\n  }\n\n  return processedHtml\n}\n\nexport function sanitizeHtml(html: string): string {\n  if (!html) return ''\n  \n  // Basic HTML sanitization - remove script tags and dangerous attributes\n  // Allow data: URLs for images but be restrictive about other uses\n  return html\n    .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n    .replace(/on\\w+=\"[^\"]*\"/gi, '')\n    .replace(/on\\w+='[^']*'/gi, '')\n    .replace(/javascript:/gi, '')\n    .replace(/vbscript:/gi, '')\n    // Only remove data: URLs that are NOT for images\n    .replace(/(?<!src=[\"'])data:(?!image\\/)/gi, '')\n}\n\nexport function extractEmailDomain(email: string): string {\n  const match = email.match(/@([^>]+)/)\n  return match ? match[1] : ''\n}\n\nexport function formatEmailAddress(email: string): { name: string; address: string } {\n  // Handle formats like \"Name <email@domain.com>\" or just \"email@domain.com\"\n  const match = email.match(/^(.+?)\\s*<(.+?)>$/)\n  if (match) {\n    return {\n      name: match[1].replace(/['\"]/g, '').trim(),\n      address: match[2].trim()\n    }\n  }\n  \n  return {\n    name: '',\n    address: email.trim()\n  }\n}\n\n/**\n * Extract a single email address from various address object formats (mailparser AddressObject)\n * Handles string, AddressObject, and array formats commonly returned by mailparser\n */\nexport function extractEmailAddress(addressObj: any): string {\n  if (!addressObj) return 'unknown'\n  if (typeof addressObj === 'string') return addressObj\n  if (addressObj.text) return addressObj.text\n  if (Array.isArray(addressObj) && addressObj.length > 0) {\n    return addressObj[0].text || addressObj[0].address || 'unknown'\n  }\n  if (addressObj.address) return addressObj.address\n  if (addressObj.name) return addressObj.name\n  return 'unknown'\n}\n\n/**\n * Extract multiple email addresses from various address object formats (mailparser AddressObject)\n * Returns an array of email address strings\n */\nexport function extractEmailAddresses(addressObj: any): string[] {\n  if (!addressObj) return []\n  if (typeof addressObj === 'string') return [addressObj]\n  if (Array.isArray(addressObj)) {\n    return addressObj.map(addr => addr.text || addr.address || 'unknown')\n  }\n  if (addressObj.text) return [addressObj.text]\n  if (addressObj.address) return [addressObj.address]\n  return []\n}\n\n// Export the ParsedEmailData type for use in other files\nexport type { ParsedEmailData, ParsedEmailAddress, ParsedEmailHeaderValue, ParsedEmailListHeader } ","import { NextRequest, NextResponse } from 'next/server'\nimport { getAllEmails, replyToEmail } from '@/functions/mail/primary'\nimport { validateRequest } from '../helper/main'\n\n/**\n * GET /api/v2/mail\n * Gets all emails for the user (can filter by status, date, domain)\n * Supports both session-based auth and API key auth\n * Has tests? ✅\n * Has logging? ✅\n * Has types? ✅\n */\n\n// GET /api/v2/mail types\nexport interface GetMailRequest {\n    limit?: number\n    offset?: number\n    search?: string\n    status?: 'all' | 'processed' | 'failed'\n    domain?: string\n    timeRange?: '24h' | '7d' | '30d' | '90d'\n    includeArchived?: boolean\n}\n\nexport interface EmailItem {\n    id: string\n    emailId: string\n    messageId: string | null\n    subject: string\n    from: string\n    fromName: string | null\n    recipient: string\n    preview: string\n    receivedAt: Date\n    isRead: boolean\n    readAt: Date | null\n    isArchived: boolean\n    archivedAt: Date | null\n    hasAttachments: boolean\n    attachmentCount: number\n    parseSuccess: boolean | null\n    parseError: string | null\n    createdAt: Date\n}\n\nexport interface GetMailResponse {\n    emails: EmailItem[]\n    pagination: {\n        total: number\n        limit: number\n        offset: number\n        hasMore: boolean\n    }\n    filters: {\n        uniqueDomains: string[]\n    }\n}\n\nexport async function GET(request: NextRequest) {\n    console.log('📧 GET /api/v2/mail - Starting request')\n    \n    try {\n        console.log('🔐 Validating request authentication')\n        const { userId, error } = await validateRequest(request)\n        if (!userId) {\n            console.log('❌ Authentication failed:', error)\n            return NextResponse.json(\n                { error: error },\n                { status: 401 }\n            )\n        }\n        console.log('✅ Authentication successful for userId:', userId)\n\n        const { searchParams } = new URL(request.url)\n\n        // Extract query parameters\n        const limit = parseInt(searchParams.get('limit') || '50')\n        const offset = parseInt(searchParams.get('offset') || '0')\n        const searchQuery = searchParams.get('search') || ''\n        const statusFilter = searchParams.get('status') as 'all' | 'processed' | 'failed' || 'all'\n        const domainFilter = searchParams.get('domain') || 'all'\n        const timeRange = searchParams.get('timeRange') as '24h' | '7d' | '30d' | '90d' || '30d'\n        const includeArchived = searchParams.get('includeArchived') === 'true'\n\n        console.log('📊 Query parameters:', {\n            limit,\n            offset,\n            searchQuery,\n            statusFilter,\n            domainFilter,\n            timeRange,\n            includeArchived\n        })\n\n        // Validate parameters\n        if (limit < 1 || limit > 100) {\n            console.log('⚠️ Invalid limit parameter:', limit)\n            return NextResponse.json(\n                { error: 'Limit must be between 1 and 100' },\n                { status: 400 }\n            )\n        }\n\n        if (offset < 0) {\n            console.log('⚠️ Invalid offset parameter:', offset)\n            return NextResponse.json(\n                { error: 'Offset must be non-negative' },\n                { status: 400 }\n            )\n        }\n\n        console.log('🔍 Calling getAllEmails function')\n        // Call the function with userId\n        const result = await getAllEmails(userId, {\n            limit,\n            offset,\n            searchQuery,\n            statusFilter,\n            domainFilter,\n            timeRange,\n            includeArchived\n        })\n\n        if (result.error) {\n            console.log('💥 getAllEmails returned error:', result.error)\n            return NextResponse.json(\n                { error: result.error },\n                { status: 500 }\n            )\n        }\n\n        console.log('✅ Successfully retrieved emails, count:', result.data?.emails?.length || 0)\n        return NextResponse.json(result.data)\n\n    } catch (error) {\n        console.error('💥 Unexpected error in GET /api/v2/mail:', error)\n        return NextResponse.json(\n            { error: 'Internal server error' },\n            { status: 500 }\n        )\n    }\n}\n\n/**\n * POST /api/v2/mail\n * Creates a reply to an email\n * Supports both session-based auth and API key auth\n * Has logging? ✅\n * Has types? ✅\n * Has tests? ✅\n */\n\n// POST /api/v2/mail types\nexport interface PostMailRequest {\n    emailId: string\n    to: string\n    subject: string\n    textBody?: string\n    htmlBody?: string\n    attachments?: Array<{\n        filename: string\n        contentType: string\n        content: string // base64 encoded\n    }>\n}\n\nexport interface PostMailResponse {\n    message: string\n    originalEmailId: string\n    replyData: {\n        to: string\n        subject: string\n        hasTextBody: boolean\n        hasHtmlBody: boolean\n        attachmentCount: number\n    }\n    status: string\n}\n\nexport async function POST(request: NextRequest) {\n    console.log('📤 POST /api/v2/mail - Starting reply request')\n    \n    try {\n        console.log('🔐 Validating request authentication')\n        const { userId, error } = await validateRequest(request)\n        if (!userId) {\n            console.log('❌ Authentication failed:', error)\n            return NextResponse.json(\n                { error: error },\n                { status: 401 }\n            )\n        }\n        console.log('✅ Authentication successful for userId:', userId)\n\n        console.log('📝 Parsing request body')\n        const body = await request.json()\n        console.log('📋 Request body received:', {\n            emailId: body.emailId,\n            to: body.to,\n            subject: body.subject,\n            hasTextBody: !!body.textBody,\n            hasHtmlBody: !!body.htmlBody,\n            attachmentCount: body.attachments?.length || 0\n        })\n\n        // Validate required fields\n        if (!body.emailId) {\n            console.log('⚠️ Missing required field: emailId')\n            return NextResponse.json(\n                { error: 'emailId is required' },\n                { status: 400 }\n            )\n        }\n\n        if (!body.to || !body.subject) {\n            console.log('⚠️ Missing required fields - to:', !!body.to, 'subject:', !!body.subject)\n            return NextResponse.json(\n                { error: 'to and subject are required' },\n                { status: 400 }\n            )\n        }\n\n        // Validate email format\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n        if (!emailRegex.test(body.to)) {\n            console.log('⚠️ Invalid email format for to field:', body.to)\n            return NextResponse.json(\n                { error: 'Invalid email format for to field' },\n                { status: 400 }\n            )\n        }\n\n        // Validate at least one body content\n        if (!body.textBody && !body.htmlBody) {\n            console.log('⚠️ No body content provided')\n            return NextResponse.json(\n                { error: 'Either textBody or htmlBody must be provided' },\n                { status: 400 }\n            )\n        }\n\n        console.log('📧 Calling replyToEmail function')\n        // Call the reply function with userId\n        const result = await replyToEmail(userId, body.emailId, {\n            to: body.to,\n            subject: body.subject,\n            textBody: body.textBody,\n            htmlBody: body.htmlBody,\n            attachments: body.attachments\n        })\n\n        if (result.error) {\n            console.log('💥 replyToEmail returned error:', result.error)\n            if (result.error === 'Original email not found') {\n                return NextResponse.json(\n                    { error: 'Original email not found' },\n                    { status: 404 }\n                )\n            }\n            return NextResponse.json(\n                { error: result.error },\n                { status: 500 }\n            )\n        }\n\n        console.log('✅ Successfully sent reply email')\n        return NextResponse.json(result.data, { status: 201 })\n\n    } catch (error) {\n        console.error('💥 Unexpected error in POST /api/v2/mail:', error)\n        return NextResponse.json(\n            { error: 'Internal server error' },\n            { status: 500 }\n        )\n    }\n}","import {\n  AppRouteRouteModule,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackServerEdge","AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks"],"mappings":"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","ignoreList":[0,1,4]}
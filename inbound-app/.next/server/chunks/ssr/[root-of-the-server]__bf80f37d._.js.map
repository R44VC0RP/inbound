{"version":3,"sources":["turbopack:///[project]/node_modules/@aws-sdk/client-ses/dist-es/commands/SendBounceCommand.js","turbopack:///[project]/lib/aws-ses/aws-ses.ts"],"sourcesContent":["import { getEndpointPlugin } from \"@smithy/middleware-endpoint\";\nimport { getSerdePlugin } from \"@smithy/middleware-serde\";\nimport { Command as $Command } from \"@smithy/smithy-client\";\nimport { commonParams } from \"../endpoint/EndpointParameters\";\nimport { de_SendBounceCommand, se_SendBounceCommand } from \"../protocols/Aws_query\";\nexport { $Command };\nexport class SendBounceCommand extends $Command\n    .classBuilder()\n    .ep(commonParams)\n    .m(function (Command, cs, config, o) {\n    return [\n        getSerdePlugin(config, this.serialize, this.deserialize),\n        getEndpointPlugin(config, Command.getEndpointParameterInstructions()),\n    ];\n})\n    .s(\"SimpleEmailService\", \"SendBounce\", {})\n    .n(\"SESClient\", \"SendBounceCommand\")\n    .f(void 0, void 0)\n    .ser(se_SendBounceCommand)\n    .de(de_SendBounceCommand)\n    .build() {\n}\n","import { S3Client, GetObjectCommand } from '@aws-sdk/client-s3';\nimport { SESClient, SendBounceCommand, SendBounceCommandInput } from '@aws-sdk/client-ses';\nimport { simpleParser, ParsedMail, Attachment } from 'mailparser';\nimport { extractEmailAddress, extractEmailAddresses } from '@/lib/email-management/email-parser';\n\n// Types for SES email receiving\nexport interface SESEvent {\n  Records: SESRecord[];\n}\n\nexport interface SESRecord {\n  eventSource: string;\n  eventVersion: string;\n  ses: {\n    receipt: SESReceipt;\n    mail: SESMail;\n  };\n}\n\nexport interface SESReceipt {\n  timestamp: string;\n  processingTimeMillis: number;\n  recipients: string[];\n  spamVerdict: { status: string };\n  virusVerdict: { status: string };\n  spfVerdict: { status: string };\n  dkimVerdict: { status: string };\n  dmarcVerdict: { status: string };\n  action: {\n    type: string;\n    bucketName: string;\n    objectKey: string;\n  };\n}\n\nexport interface SESMail {\n  timestamp: string;\n  messageId: string;\n  source: string;\n  destination: string[];\n  commonHeaders: {\n    from: string[];\n    to: string[];\n    subject: string;\n    date?: string;\n    messageId?: string;\n  };\n}\n\nexport interface ProcessedEmail {\n  messageId: string;\n  from: string;\n  to: string[];\n  subject: string;\n  body: {\n    text?: string;\n    html?: string;\n  };\n  attachments: EmailAttachment[];\n  headers: Record<string, string>;\n  timestamp: Date;\n  recipient: string; // The specific recipient that triggered this processing\n  authResults: {\n    spf: string;\n    dkim: string;\n    dmarc: string;\n    spam: string;\n    virus: string;\n  };\n  s3Location: {\n    bucket: string;\n    key: string;\n  };\n}\n\nexport interface EmailAttachment {\n  filename: string;\n  contentType: string;\n  size: number;\n  content: Buffer;\n}\n\nexport interface EmailProcessingConfig {\n  s3Region?: string;\n  sesRegion?: string;\n  allowedDomains?: string[];\n  blockedSenders?: string[];\n  maxAttachmentSize?: number; // in bytes\n  enableSpamFilter?: boolean;\n  enableVirusFilter?: boolean;\n  serviceApiUrl?: string;\n  serviceApiKey?: string;\n}\n\n// New interface for API email retrieval\nexport interface EmailMetadata {\n  messageId: string;\n  from: string;\n  to: string[];\n  subject: string;\n  timestamp: Date;\n  recipient: string;\n  hasAttachments: boolean;\n  attachmentCount: number;\n  bodyPreview: string;\n  authResults: {\n    spf: string;\n    dkim: string;\n    dmarc: string;\n    spam: string;\n    virus: string;\n  };\n  s3Location: {\n    bucket: string;\n    key: string;\n  };\n  headers: Record<string, string>;\n}\n\n// Interface for webhook payload to your API\nexport interface EmailWebhookPayload {\n  type: 'email_received';\n  timestamp: string;\n  data: {\n    messageId: string;\n    from: string;\n    to: string[];\n    recipient: string;\n    subject: string;\n    bodyPreview: string;\n    hasAttachments: boolean;\n    attachmentCount: number;\n    authResults: {\n      spf: string;\n      dkim: string;\n      dmarc: string;\n      spam: string;\n      virus: string;\n    };\n    s3Location: {\n      bucket: string;\n      key: string;\n    };\n    headers: {\n      messageId?: string;\n      date?: string;\n      replyTo?: string;\n      inReplyTo?: string;\n      references?: string;\n    };\n  };\n}\n\nexport class AWSSESEmailProcessor {\n  private s3Client: S3Client;\n  private sesClient: SESClient;\n  private config: EmailProcessingConfig;\n\n  constructor(config: EmailProcessingConfig = {}) {\n    this.config = {\n      s3Region: process.env.AWS_REGION || 'us-east-2',\n      sesRegion: process.env.AWS_REGION || 'us-east-2',\n      allowedDomains: [],\n      blockedSenders: [],\n      maxAttachmentSize: 10 * 1024 * 1024, // 10MB default\n      enableSpamFilter: true,\n      enableVirusFilter: true,\n      serviceApiUrl: process.env.SERVICE_API_URL,\n      serviceApiKey: process.env.SERVICE_API_KEY,\n      ...config,\n    };\n\n    this.s3Client = new S3Client({ region: this.config.s3Region });\n    this.sesClient = new SESClient({ region: this.config.sesRegion });\n  }\n\n  /**\n   * Main entry point for processing SES email events\n   * This is called by Lambda when emails are received\n   */\n  async processEmailEvent(event: SESEvent): Promise<ProcessedEmail[]> {\n    const processedEmails: ProcessedEmail[] = [];\n\n    for (const record of event.Records) {\n      try {\n        // Validate the email first\n        if (!this.isEmailValid(record)) {\n          console.log(`Skipping invalid email: ${record.ses.mail.messageId}`);\n          continue;\n        }\n\n        // Check spam/virus filters\n        if (!this.passesSecurityChecks(record.ses.receipt)) {\n          console.log(`Email failed security checks: ${record.ses.mail.messageId}`);\n          await this.bounceEmail(record.ses.mail, 'Email failed security validation');\n          continue;\n        }\n\n        // Process each recipient\n        for (const recipient of record.ses.receipt.recipients) {\n          const processedEmail = await this.processEmailForRecipient(record, recipient);\n          if (processedEmail) {\n            processedEmails.push(processedEmail);\n            \n            // Send webhook to your API for each recipient\n            await this.sendWebhookToAPI(processedEmail);\n          }\n        }\n      } catch (error) {\n        console.error(`Error processing email ${record.ses.mail.messageId}:`, error);\n        // Continue processing other emails even if one fails\n      }\n    }\n\n    return processedEmails;\n  }\n\n  /**\n   * Retrieve and parse email from S3 for API consumption\n   * This is called by your API when it needs to fetch email content\n   */\n  async getEmailFromS3ForAPI(bucketName: string, objectKey: string): Promise<ProcessedEmail> {\n    try {\n      // Get the email content from S3\n      const emailContent = await this.getEmailFromS3(bucketName, objectKey);\n      \n      // Parse the email\n      const parsedEmail = await this.parseEmail(emailContent);\n      \n      // Extract metadata from the object key or use defaults\n      const messageId = objectKey.split('/').pop() || 'unknown';\n      \n      // Use shared email address extraction utilities\n\n      // Create processed email object\n      const processedEmail: ProcessedEmail = {\n        messageId,\n        from: extractEmailAddress(parsedEmail.from),\n        to: extractEmailAddresses(parsedEmail.to),\n        subject: parsedEmail.subject || 'No Subject',\n        body: {\n          text: parsedEmail.text,\n          html: parsedEmail.html || undefined,\n        },\n        attachments: this.processAttachments(parsedEmail.attachments || []),\n        headers: this.extractHeaders(parsedEmail),\n        timestamp: parsedEmail.date || new Date(),\n        recipient: extractEmailAddress(parsedEmail.to),\n        authResults: {\n          spf: 'UNKNOWN',\n          dkim: 'UNKNOWN',\n          dmarc: 'UNKNOWN',\n          spam: 'UNKNOWN',\n          virus: 'UNKNOWN',\n        },\n        s3Location: {\n          bucket: bucketName,\n          key: objectKey,\n        },\n      };\n\n      return processedEmail;\n    } catch (error) {\n      console.error(`Error retrieving email from S3: ${bucketName}/${objectKey}`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get email metadata without downloading full content\n   * Useful for listing emails or quick previews\n   */\n  async getEmailMetadata(bucketName: string, objectKey: string): Promise<EmailMetadata> {\n    try {\n      const processedEmail = await this.getEmailFromS3ForAPI(bucketName, objectKey);\n      \n      return {\n        messageId: processedEmail.messageId,\n        from: processedEmail.from,\n        to: processedEmail.to,\n        subject: processedEmail.subject,\n        timestamp: processedEmail.timestamp,\n        recipient: processedEmail.recipient,\n        hasAttachments: processedEmail.attachments.length > 0,\n        attachmentCount: processedEmail.attachments.length,\n        bodyPreview: (processedEmail.body.text || processedEmail.body.html || '').substring(0, 200),\n        authResults: processedEmail.authResults,\n        s3Location: processedEmail.s3Location,\n        headers: processedEmail.headers,\n      };\n    } catch (error) {\n      console.error(`Error getting email metadata: ${bucketName}/${objectKey}`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Send webhook notification to your API when email is received\n   */\n  private async sendWebhookToAPI(email: ProcessedEmail): Promise<void> {\n    if (!this.config.serviceApiUrl || !this.config.serviceApiKey) {\n      console.log('Service API URL or key not configured, skipping webhook');\n      return;\n    }\n\n    try {\n      const webhookPayload: EmailWebhookPayload = {\n        type: 'email_received',\n        timestamp: email.timestamp.toISOString(),\n        data: {\n          messageId: email.messageId,\n          from: email.from,\n          to: email.to,\n          recipient: email.recipient,\n          subject: email.subject,\n          bodyPreview: (email.body.text || email.body.html || '').substring(0, 200),\n          hasAttachments: email.attachments.length > 0,\n          attachmentCount: email.attachments.length,\n          authResults: email.authResults,\n          s3Location: email.s3Location,\n          headers: {\n            messageId: email.headers['message-id'],\n            date: email.headers.date,\n            replyTo: email.headers['reply-to'],\n            inReplyTo: email.headers['in-reply-to'],\n            references: email.headers.references,\n          },\n        },\n      };\n\n      const response = await fetch(`${this.config.serviceApiUrl}/api/webhooks/email-received`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.config.serviceApiKey}`,\n          'User-Agent': 'AWS-Lambda-Email-Processor/1.0',\n        },\n        body: JSON.stringify(webhookPayload),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Webhook failed: ${response.status} ${response.statusText}`);\n      }\n\n      console.log(`Webhook sent successfully for email: ${email.messageId}`);\n    } catch (error) {\n      console.error(`Failed to send webhook for email ${email.messageId}:`, error);\n      // Don't throw error here - webhook failure shouldn't stop email processing\n    }\n  }\n\n  /**\n   * Validate if recipient email is managed by your system\n   * This should check against your database of managed email addresses\n   */\n  private async isRecipientManaged(recipient: string): Promise<boolean> {\n    if (!this.config.serviceApiUrl || !this.config.serviceApiKey) {\n      // If no API configured, allow all recipients in allowed domains\n      if (this.config.allowedDomains && this.config.allowedDomains.length > 0) {\n        const domain = recipient.split('@')[1];\n        return this.config.allowedDomains.includes(domain);\n      }\n      return true;\n    }\n\n    try {\n      const response = await fetch(`${this.config.serviceApiUrl}/api/emails/check-recipient`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${this.config.serviceApiKey}`,\n        },\n        body: JSON.stringify({ recipient }),\n      });\n\n      if (response.ok) {\n        const result = await response.json() as { isManaged?: boolean };\n        return result.isManaged === true;\n      }\n\n      return false;\n    } catch (error) {\n      console.error(`Error checking if recipient is managed: ${recipient}`, error);\n      // On error, fall back to domain checking\n      if (this.config.allowedDomains && this.config.allowedDomains.length > 0) {\n        const domain = recipient.split('@')[1];\n        return this.config.allowedDomains.includes(domain);\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Process email for a specific recipient\n   */\n  private async processEmailForRecipient(\n    record: SESRecord,\n    recipient: string\n  ): Promise<ProcessedEmail | null> {\n    try {\n      // Check if this recipient is managed by your system\n      const isManaged = await this.isRecipientManaged(recipient);\n      if (!isManaged) {\n        console.log(`Recipient ${recipient} is not managed by the system, skipping`);\n        return null;\n      }\n\n      // Get the email content from S3\n      const emailContent = await this.getEmailFromS3(\n        record.ses.receipt.action.bucketName,\n        record.ses.receipt.action.objectKey\n      );\n\n      // Parse the email\n      const parsedEmail = await this.parseEmail(emailContent);\n\n      // Create processed email object\n      const processedEmail: ProcessedEmail = {\n        messageId: record.ses.mail.messageId,\n        from: record.ses.mail.source,\n        to: record.ses.mail.destination,\n        subject: record.ses.mail.commonHeaders.subject,\n        body: {\n          text: parsedEmail.text,\n          html: parsedEmail.html || undefined,\n        },\n        attachments: this.processAttachments(parsedEmail.attachments || []),\n        headers: this.extractHeaders(parsedEmail),\n        timestamp: new Date(record.ses.mail.timestamp),\n        recipient,\n        authResults: {\n          spf: record.ses.receipt.spfVerdict.status,\n          dkim: record.ses.receipt.dkimVerdict.status,\n          dmarc: record.ses.receipt.dmarcVerdict.status,\n          spam: record.ses.receipt.spamVerdict.status,\n          virus: record.ses.receipt.virusVerdict.status,\n        },\n        s3Location: {\n          bucket: record.ses.receipt.action.bucketName,\n          key: record.ses.receipt.action.objectKey,\n        },\n      };\n\n      return processedEmail;\n    } catch (error) {\n      console.error(`Error processing email for recipient ${recipient}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Retrieve email content from S3\n   */\n  private async getEmailFromS3(bucketName: string, objectKey: string): Promise<Buffer> {\n    try {\n      const command = new GetObjectCommand({\n        Bucket: bucketName,\n        Key: objectKey,\n      });\n\n      const response = await this.s3Client.send(command);\n      \n      if (!response.Body) {\n        throw new Error('No email content found in S3 object');\n      }\n\n      // Convert stream to buffer\n      const chunks: Uint8Array[] = [];\n      const reader = response.Body.transformToWebStream().getReader();\n      \n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        chunks.push(value);\n      }\n\n      return Buffer.concat(chunks);\n    } catch (error) {\n      console.error(`Error retrieving email from S3: ${bucketName}/${objectKey}`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Parse email content using mailparser\n   */\n  private async parseEmail(emailBuffer: Buffer): Promise<ParsedMail> {\n    try {\n      return await simpleParser(emailBuffer);\n    } catch (error) {\n      console.error('Error parsing email:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Process email attachments\n   */\n  private processAttachments(attachments: Attachment[]): EmailAttachment[] {\n    return attachments\n      .filter(attachment => {\n        // Filter out inline images and oversized attachments\n        return (\n          attachment.filename &&\n          attachment.size <= this.config.maxAttachmentSize! &&\n          !attachment.cid // Exclude inline images\n        );\n      })\n      .map(attachment => ({\n        filename: attachment.filename!,\n        contentType: attachment.contentType,\n        size: attachment.size,\n        content: attachment.content,\n      }));\n  }\n\n  /**\n   * Extract relevant headers from parsed email\n   */\n  private extractHeaders(parsedEmail: ParsedMail): Record<string, string> {\n    const headers: Record<string, string> = {};\n    \n    if (parsedEmail.headers) {\n      // Extract common headers\n      const commonHeaders = [\n        'message-id',\n        'date',\n        'from',\n        'to',\n        'cc',\n        'bcc',\n        'subject',\n        'reply-to',\n        'in-reply-to',\n        'references',\n        'x-mailer',\n        'x-originating-ip',\n      ];\n\n      for (const header of commonHeaders) {\n        const value = parsedEmail.headers.get(header);\n        if (value) {\n          headers[header] = Array.isArray(value) ? value.join(', ') : value.toString();\n        }\n      }\n    }\n\n    return headers;\n  }\n\n  /**\n   * Validate email against basic criteria\n   */\n  private isEmailValid(record: SESRecord): boolean {\n    const { mail, receipt } = record.ses;\n\n    // Check if sender is blocked\n    if (this.config.blockedSenders?.includes(mail.source)) {\n      console.log(`Blocked sender: ${mail.source}`);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Check if email passes spam and virus filters\n   */\n  private passesSecurityChecks(receipt: SESReceipt): boolean {\n    if (this.config.enableSpamFilter && receipt.spamVerdict.status === 'FAIL') {\n      console.log('Email failed spam check');\n      return false;\n    }\n\n    if (this.config.enableVirusFilter && receipt.virusVerdict.status === 'FAIL') {\n      console.log('Email failed virus check');\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Send bounce response for rejected emails\n   */\n  private async bounceEmail(mail: SESMail, reason: string): Promise<void> {\n    try {\n      const bounceParams = {\n        OriginalMessageId: mail.messageId,\n        BounceSender: `mailer-daemon@${mail.destination[0].split('@')[1]}`,\n        MessageDsn: {\n          ReportingMta: `dns; ${mail.destination[0].split('@')[1]}`,\n          ArrivalDate: new Date(mail.timestamp),\n          ExtensionFields: [],\n        },\n        BouncedRecipientInfoList: mail.destination.map(recipient => ({\n          Recipient: recipient,\n          BounceType: 'Permanent',\n          RecipientArn: undefined,\n          RecipientDsnFields: {\n            FinalRecipient: recipient,\n            Action: 'failed',\n            Status: '5.1.1',\n            DiagnosticCode: reason,\n          },\n        })),\n      };\n\n      const command = new SendBounceCommand(bounceParams as SendBounceCommandInput);\n      await this.sesClient.send(command);\n      \n      console.log(`Bounce sent for message: ${mail.messageId}`);\n    } catch (error) {\n      console.error(`Error sending bounce for message ${mail.messageId}:`, error);\n    }\n  }\n\n  /**\n   * Extract email domain from address\n   */\n  static extractDomain(email: string): string {\n    return email.split('@')[1]?.toLowerCase() || '';\n  }\n\n  /**\n   * Check if email is from a trusted domain\n   */\n  static isTrustedDomain(email: string, trustedDomains: string[]): boolean {\n    const domain = this.extractDomain(email);\n    return trustedDomains.includes(domain);\n  }\n}\n\n// Utility functions for Lambda handlers\nexport const createEmailProcessor = (config?: EmailProcessingConfig) => {\n  return new AWSSESEmailProcessor(config);\n};\n\nexport const handleSESEvent = async (\n  event: SESEvent,\n  config?: EmailProcessingConfig\n): Promise<ProcessedEmail[]> => {\n  const processor = createEmailProcessor(config);\n  return await processor.processEmailEvent(event);\n};\n\n// Utility function for API to retrieve emails from S3\nexport const getEmailFromS3 = async (\n  bucketName: string,\n  objectKey: string,\n  config?: EmailProcessingConfig\n): Promise<ProcessedEmail> => {\n  const processor = createEmailProcessor(config);\n  return await processor.getEmailFromS3ForAPI(bucketName, objectKey);\n};\n\n// Utility function for API to get email metadata\nexport const getEmailMetadata = async (\n  bucketName: string,\n  objectKey: string,\n  config?: EmailProcessingConfig\n): Promise<EmailMetadata> => {\n  const processor = createEmailProcessor(config);\n  return await processor.getEmailMetadata(bucketName, objectKey);\n}; "],"names":[],"mappings":"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","ignoreList":[0]}
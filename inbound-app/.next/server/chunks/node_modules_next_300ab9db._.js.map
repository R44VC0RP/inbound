{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/server/web/spec-extension/adapters/request-cookies.ts","turbopack:///[project]/node_modules/next/src/server/create-deduped-by-callsite-server-error-logger.ts","turbopack:///[project]/node_modules/next/src/server/request/cookies.ts","turbopack:///[project]/node_modules/next/src/server/web/spec-extension/adapters/headers.ts","turbopack:///[project]/node_modules/next/src/server/request/headers.ts","turbopack:///[project]/node_modules/next/src/server/request/draft-mode.ts","turbopack:///[project]/node_modules/next/headers.js"],"sourcesContent":["import { RequestCookies } from '../cookies'\n\nimport { ResponseCookies } from '../cookies'\nimport { ReflectAdapter } from './reflect'\nimport { workAsyncStorage } from '../../../app-render/work-async-storage.external'\nimport {\n  getExpectedRequestStore,\n  type RequestStore,\n} from '../../../app-render/work-unit-async-storage.external'\n\n/**\n * @internal\n */\nexport class ReadonlyRequestCookiesError extends Error {\n  constructor() {\n    super(\n      'Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#options'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\n// We use this to type some APIs but we don't construct instances directly\nexport type { ResponseCookies }\n\n// The `cookies()` API is a mix of request and response cookies. For `.get()` methods,\n// we want to return the request cookie if it exists. For mutative methods like `.set()`,\n// we want to return the response cookie.\nexport type ReadonlyRequestCookies = Omit<\n  RequestCookies,\n  'set' | 'clear' | 'delete'\n> &\n  Pick<ResponseCookies, 'set' | 'delete'>\n\nexport class RequestCookiesAdapter {\n  public static seal(cookies: RequestCookies): ReadonlyRequestCookies {\n    return new Proxy(cookies as any, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'clear':\n          case 'delete':\n          case 'set':\n            return ReadonlyRequestCookiesError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n}\n\nconst SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for('next.mutated.cookies')\n\nexport function getModifiedCookieValues(\n  cookies: ResponseCookies\n): ResponseCookie[] {\n  const modified: ResponseCookie[] | undefined = (cookies as unknown as any)[\n    SYMBOL_MODIFY_COOKIE_VALUES\n  ]\n  if (!modified || !Array.isArray(modified) || modified.length === 0) {\n    return []\n  }\n\n  return modified\n}\n\ntype SetCookieArgs =\n  | [key: string, value: string, cookie?: Partial<ResponseCookie>]\n  | [options: ResponseCookie]\n\nexport function appendMutableCookies(\n  headers: Headers,\n  mutableCookies: ResponseCookies\n): boolean {\n  const modifiedCookieValues = getModifiedCookieValues(mutableCookies)\n  if (modifiedCookieValues.length === 0) {\n    return false\n  }\n\n  // Return a new response that extends the response with\n  // the modified cookies as fallbacks. `res` cookies\n  // will still take precedence.\n  const resCookies = new ResponseCookies(headers)\n  const returnedCookies = resCookies.getAll()\n\n  // Set the modified cookies as fallbacks.\n  for (const cookie of modifiedCookieValues) {\n    resCookies.set(cookie)\n  }\n\n  // Set the original cookies as the final values.\n  for (const cookie of returnedCookies) {\n    resCookies.set(cookie)\n  }\n\n  return true\n}\n\ntype ResponseCookie = NonNullable<\n  ReturnType<InstanceType<typeof ResponseCookies>['get']>\n>\n\nexport class MutableRequestCookiesAdapter {\n  public static wrap(\n    cookies: RequestCookies,\n    onUpdateCookies?: (cookies: string[]) => void\n  ): ResponseCookies {\n    const responseCookies = new ResponseCookies(new Headers())\n    for (const cookie of cookies.getAll()) {\n      responseCookies.set(cookie)\n    }\n\n    let modifiedValues: ResponseCookie[] = []\n    const modifiedCookies = new Set<string>()\n    const updateResponseCookies = () => {\n      // TODO-APP: change method of getting workStore\n      const workStore = workAsyncStorage.getStore()\n      if (workStore) {\n        workStore.pathWasRevalidated = true\n      }\n\n      const allCookies = responseCookies.getAll()\n      modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name))\n      if (onUpdateCookies) {\n        const serializedCookies: string[] = []\n        for (const cookie of modifiedValues) {\n          const tempCookies = new ResponseCookies(new Headers())\n          tempCookies.set(cookie)\n          serializedCookies.push(tempCookies.toString())\n        }\n\n        onUpdateCookies(serializedCookies)\n      }\n    }\n\n    const wrappedCookies = new Proxy(responseCookies, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          // A special symbol to get the modified cookie values\n          case SYMBOL_MODIFY_COOKIE_VALUES:\n            return modifiedValues\n\n          // TODO: Throw error if trying to set a cookie after the response\n          // headers have been set.\n          case 'delete':\n            return function (...args: [string] | [ResponseCookie]) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.delete(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n          case 'set':\n            return function (...args: SetCookieArgs) {\n              modifiedCookies.add(\n                typeof args[0] === 'string' ? args[0] : args[0].name\n              )\n              try {\n                target.set(...args)\n                return wrappedCookies\n              } finally {\n                updateResponseCookies()\n              }\n            }\n\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n\n    return wrappedCookies\n  }\n}\n\nexport function wrapWithMutableAccessCheck(\n  responseCookies: ResponseCookies\n): ResponseCookies {\n  const wrappedCookies = new Proxy(responseCookies, {\n    get(target, prop, receiver) {\n      switch (prop) {\n        case 'delete':\n          return function (...args: [string] | [ResponseCookie]) {\n            ensureCookiesAreStillMutable('cookies().delete')\n            target.delete(...args)\n            return wrappedCookies\n          }\n        case 'set':\n          return function (...args: SetCookieArgs) {\n            ensureCookiesAreStillMutable('cookies().set')\n            target.set(...args)\n            return wrappedCookies\n          }\n\n        default:\n          return ReflectAdapter.get(target, prop, receiver)\n      }\n    },\n  })\n  return wrappedCookies\n}\n\nexport function areCookiesMutableInCurrentPhase(requestStore: RequestStore) {\n  return requestStore.phase === 'action'\n}\n\n/** Ensure that cookies() starts throwing on mutation\n * if we changed phases and can no longer mutate.\n *\n * This can happen when going:\n *   'render' -> 'after'\n *   'action' -> 'render'\n * */\nfunction ensureCookiesAreStillMutable(callingExpression: string) {\n  const requestStore = getExpectedRequestStore(callingExpression)\n  if (!areCookiesMutableInCurrentPhase(requestStore)) {\n    // TODO: maybe we can give a more precise error message based on callingExpression?\n    throw new ReadonlyRequestCookiesError()\n  }\n}\n\nexport function responseCookiesToRequestCookies(\n  responseCookies: ResponseCookies\n): RequestCookies {\n  const requestCookies = new RequestCookies(new Headers())\n  for (const cookie of responseCookies.getAll()) {\n    requestCookies.set(cookie)\n  }\n  return requestCookies\n}\n","import * as React from 'react'\n\nconst errorRef: { current: null | Error } = { current: null }\n\n// React.cache is currently only available in canary/experimental React channels.\nconst cache =\n  typeof React.cache === 'function'\n    ? React.cache\n    : (fn: (key: unknown) => void) => fn\n\n// When Dynamic IO is enabled, we record these as errors so that they\n// are captured by the dev overlay as it's more critical to fix these\n// when enabled.\nconst logErrorOrWarn = process.env.__NEXT_DYNAMIC_IO\n  ? console.error\n  : console.warn\n\n// We don't want to dedupe across requests.\n// The developer might've just attempted to fix the warning so we should warn again if it still happens.\nconst flushCurrentErrorIfNew = cache(\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- cache key\n  (key: unknown) => {\n    try {\n      logErrorOrWarn(errorRef.current)\n    } finally {\n      errorRef.current = null\n    }\n  }\n)\n\n/**\n * Creates a function that logs an error message that is deduped by the userland\n * callsite.\n * This requires no indirection between the call of this function and the userland\n * callsite i.e. there's only a single library frame above this.\n * Do not use on the Client where sourcemaps and ignore listing might be enabled.\n * Only use that for warnings need a fix independent of the callstack.\n *\n * @param getMessage\n * @returns\n */\nexport function createDedupedByCallsiteServerErrorLoggerDev<Args extends any[]>(\n  getMessage: (...args: Args) => Error\n) {\n  return function logDedupedError(...args: Args) {\n    const message = getMessage(...args)\n\n    if (process.env.NODE_ENV !== 'production') {\n      const callStackFrames = new Error().stack?.split('\\n')\n      if (callStackFrames === undefined || callStackFrames.length < 4) {\n        logErrorOrWarn(message)\n      } else {\n        // Error:\n        //   logDedupedError\n        //   asyncApiBeingAccessedSynchronously\n        //   <userland callsite>\n        // TODO: This breaks if sourcemaps with ignore lists are enabled.\n        const key = callStackFrames[4]\n        errorRef.current = message\n        flushCurrentErrorIfNew(key)\n      }\n    } else {\n      logErrorOrWarn(message)\n    }\n  }\n}\n","import {\n  type ReadonlyRequestCookies,\n  type ResponseCookies,\n  areCookiesMutableInCurrentPhase,\n  RequestCookiesAdapter,\n} from '../web/spec-extension/adapters/request-cookies'\nimport { RequestCookies } from '../web/spec-extension/cookies'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { isRequestAPICallableInsideAfter } from './utils'\n\n/**\n * In this version of Next.js `cookies()` returns a Promise however you can still reference the properties of the underlying cookies object\n * synchronously to facilitate migration. The `UnsafeUnwrappedCookies` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `cookies()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedCookies` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `cookies()` value can be awaited or you should call `cookies()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedCookies` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `cookies()` will only return a Promise and you will not be able to access the underlying cookies object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedCookies` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedCookies = ReadonlyRequestCookies\n\nexport function cookies(): Promise<ReadonlyRequestCookies> {\n  const callingExpression = 'cookies'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        // TODO(after): clarify that this only applies to pages?\n        `Route ${workStore.route} used \"cookies\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"cookies\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // cookies object without tracking\n      const underlyingCookies = createEmptyCookies()\n      return makeUntrackedExoticCookies(underlyingCookies)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We don't track dynamic access here because access will be tracked when you access\n        // one of the properties of the cookies object.\n        return makeDynamicallyTrackedExoticCookies(\n          workStore.route,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We are prerendering with PPR. We need track dynamic access here eagerly\n        // to keep continuity with how cookies has worked in PPR without dynamicIO.\n        postponeWithTracking(\n          workStore.route,\n          callingExpression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We track dynamic access here so we don't need to wrap the cookies in\n        // individual property access tracking.\n        throwToInterruptStaticGeneration(\n          callingExpression,\n          workStore,\n          workUnitStore\n        )\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using cookies inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  // cookies is being called in a dynamic context\n\n  const requestStore = getExpectedRequestStore(callingExpression)\n\n  let underlyingCookies: ReadonlyRequestCookies\n\n  if (areCookiesMutableInCurrentPhase(requestStore)) {\n    // We can't conditionally return different types here based on the context.\n    // To avoid confusion, we always return the readonly type here.\n    underlyingCookies =\n      requestStore.userspaceMutableCookies as unknown as ReadonlyRequestCookies\n  } else {\n    underlyingCookies = requestStore.cookies\n  }\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    return makeUntrackedExoticCookiesWithDevWarnings(\n      underlyingCookies,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticCookies(underlyingCookies)\n  }\n}\n\nfunction createEmptyCookies(): ReadonlyRequestCookies {\n  return RequestCookiesAdapter.seal(new RequestCookies(new Headers({})))\n}\n\ninterface CacheLifetime {}\nconst CachedCookies = new WeakMap<\n  CacheLifetime,\n  Promise<ReadonlyRequestCookies>\n>()\n\nfunction makeDynamicallyTrackedExoticCookies(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyRequestCookies> {\n  const cachedPromise = CachedCookies.get(prerenderStore)\n  if (cachedPromise) {\n    return cachedPromise\n  }\n\n  const promise = makeHangingPromise<ReadonlyRequestCookies>(\n    prerenderStore.renderSignal,\n    '`cookies()`'\n  )\n  CachedCookies.set(prerenderStore, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`cookies()[Symbol.iterator]()`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    size: {\n      get() {\n        const expression = '`cookies().size`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().get()`'\n        } else {\n          expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().getAll()`'\n        } else {\n          expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    has: {\n      value: function has() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().has()`'\n        } else {\n          expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().set()`'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``\n          } else {\n            expression = '`cookies().set(...)`'\n          }\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().delete()`'\n        } else if (arguments.length === 1) {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``\n        } else {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``\n        }\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    clear: {\n      value: function clear() {\n        const expression = '`cookies().clear()`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    toString: {\n      value: function toString() {\n        const expression = '`cookies().toString()`'\n        const error = createCookiesAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookies(\n  underlyingCookies: ReadonlyRequestCookies\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = Promise.resolve(underlyingCookies)\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: underlyingCookies[Symbol.iterator]\n        ? underlyingCookies[Symbol.iterator].bind(underlyingCookies)\n        : // TODO this is a polyfill for when the underlying type is ResponseCookies\n          // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n          // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n          // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n          // has extra properties not available on RequestCookie instances.\n          polyfilledResponseCookiesIterator.bind(underlyingCookies),\n    },\n    size: {\n      get(): number {\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: underlyingCookies.get.bind(underlyingCookies),\n    },\n    getAll: {\n      value: underlyingCookies.getAll.bind(underlyingCookies),\n    },\n    has: {\n      value: underlyingCookies.has.bind(underlyingCookies),\n    },\n    set: {\n      value: underlyingCookies.set.bind(underlyingCookies),\n    },\n    delete: {\n      value: underlyingCookies.delete.bind(underlyingCookies),\n    },\n    clear: {\n      value:\n        // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n        typeof underlyingCookies.clear === 'function'\n          ? // @ts-expect-error clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.bind(underlyingCookies)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.bind(underlyingCookies, promise),\n    },\n    toString: {\n      value: underlyingCookies.toString.bind(underlyingCookies),\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticCookiesWithDevWarnings(\n  underlyingCookies: ReadonlyRequestCookies,\n  route?: string\n): Promise<ReadonlyRequestCookies> {\n  const cachedCookies = CachedCookies.get(underlyingCookies)\n  if (cachedCookies) {\n    return cachedCookies\n  }\n\n  const promise = new Promise<ReadonlyRequestCookies>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingCookies))\n  )\n  CachedCookies.set(underlyingCookies, promise)\n\n  Object.defineProperties(promise, {\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...cookies()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingCookies[Symbol.iterator]\n          ? underlyingCookies[Symbol.iterator].apply(\n              underlyingCookies,\n              arguments as any\n            )\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesIterator.call(underlyingCookies)\n      },\n      writable: false,\n    },\n    size: {\n      get(): number {\n        const expression = '`cookies().size`'\n        syncIODev(route, expression)\n        return underlyingCookies.size\n      },\n    },\n    get: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().get()`'\n        } else {\n          expression = `\\`cookies().get(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.get.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    getAll: {\n      value: function getAll() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().getAll()`'\n        } else {\n          expression = `\\`cookies().getAll(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.getAll.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    has: {\n      value: function get() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().has()`'\n        } else {\n          expression = `\\`cookies().has(${describeNameArg(arguments[0])})\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.has.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    set: {\n      value: function set() {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().set()`'\n        } else {\n          const arg = arguments[0]\n          if (arg) {\n            expression = `\\`cookies().set(${describeNameArg(arg)}, ...)\\``\n          } else {\n            expression = '`cookies().set(...)`'\n          }\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.set.apply(underlyingCookies, arguments as any)\n      },\n      writable: false,\n    },\n    delete: {\n      value: function () {\n        let expression: string\n        if (arguments.length === 0) {\n          expression = '`cookies().delete()`'\n        } else if (arguments.length === 1) {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])})\\``\n        } else {\n          expression = `\\`cookies().delete(${describeNameArg(arguments[0])}, ...)\\``\n        }\n        syncIODev(route, expression)\n        return underlyingCookies.delete.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n    clear: {\n      value: function clear() {\n        const expression = '`cookies().clear()`'\n        syncIODev(route, expression)\n        // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n        return typeof underlyingCookies.clear === 'function'\n          ? // @ts-ignore clear is defined in RequestCookies implementation but not in the type\n            underlyingCookies.clear.apply(underlyingCookies, arguments)\n          : // TODO this is a polyfill for when the underlying type is ResponseCookies\n            // We should remove this and unify our cookies types. We could just let this continue to throw lazily\n            // but that's already a hard thing to debug so we may as well implement it consistently. The biggest problem with\n            // implementing this in this way is the underlying cookie type is a ResponseCookie and not a RequestCookie and so it\n            // has extra properties not available on RequestCookie instances.\n            polyfilledResponseCookiesClear.call(underlyingCookies, promise)\n      },\n      writable: false,\n    },\n    toString: {\n      value: function toString() {\n        const expression = '`cookies().toString()` or implicit casting'\n        syncIODev(route, expression)\n        return underlyingCookies.toString.apply(\n          underlyingCookies,\n          arguments as any\n        )\n      },\n      writable: false,\n    },\n  } satisfies CookieExtensions)\n\n  return promise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'object' &&\n    arg !== null &&\n    typeof (arg as any).name === 'string'\n    ? `'${(arg as any).name}'`\n    : typeof arg === 'string'\n      ? `'${arg}'`\n      : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createCookiesAccessError\n)\n\nfunction createCookiesAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`cookies()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction polyfilledResponseCookiesIterator(\n  this: ResponseCookies\n): ReturnType<ReadonlyRequestCookies[typeof Symbol.iterator]> {\n  return this.getAll()\n    .map((c) => [c.name, c] as [string, any])\n    .values()\n}\n\nfunction polyfilledResponseCookiesClear(\n  this: ResponseCookies,\n  returnable: Promise<ReadonlyRequestCookies>\n): typeof returnable {\n  for (const cookie of this.getAll()) {\n    this.delete(cookie.name)\n  }\n  return returnable\n}\n\ntype CookieExtensions = {\n  [K in keyof ReadonlyRequestCookies | 'clear']: unknown\n}\n","import type { IncomingHttpHeaders } from 'http'\n\nimport { ReflectAdapter } from './reflect'\n\n/**\n * @internal\n */\nexport class ReadonlyHeadersError extends Error {\n  constructor() {\n    super(\n      'Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers'\n    )\n  }\n\n  public static callable() {\n    throw new ReadonlyHeadersError()\n  }\n}\n\nexport type ReadonlyHeaders = Headers & {\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  append(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  set(...args: any[]): void\n  /** @deprecated Method unavailable on `ReadonlyHeaders`. Read more: https://nextjs.org/docs/app/api-reference/functions/headers */\n  delete(...args: any[]): void\n}\nexport class HeadersAdapter extends Headers {\n  private readonly headers: IncomingHttpHeaders\n\n  constructor(headers: IncomingHttpHeaders) {\n    // We've already overridden the methods that would be called, so we're just\n    // calling the super constructor to ensure that the instanceof check works.\n    super()\n\n    this.headers = new Proxy(headers, {\n      get(target, prop, receiver) {\n        // Because this is just an object, we expect that all \"get\" operations\n        // are for properties. If it's a \"get\" for a symbol, we'll just return\n        // the symbol.\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return undefined.\n        if (typeof original === 'undefined') return\n\n        // If the original casing exists, return the value.\n        return ReflectAdapter.get(target, original, receiver)\n      },\n      set(target, prop, value, receiver) {\n        if (typeof prop === 'symbol') {\n          return ReflectAdapter.set(target, prop, value, receiver)\n        }\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, use the prop as the key.\n        return ReflectAdapter.set(target, original ?? prop, value, receiver)\n      },\n      has(target, prop) {\n        if (typeof prop === 'symbol') return ReflectAdapter.has(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return false.\n        if (typeof original === 'undefined') return false\n\n        // If the original casing exists, return true.\n        return ReflectAdapter.has(target, original)\n      },\n      deleteProperty(target, prop) {\n        if (typeof prop === 'symbol')\n          return ReflectAdapter.deleteProperty(target, prop)\n\n        const lowercased = prop.toLowerCase()\n\n        // Let's find the original casing of the key. This assumes that there is\n        // no mixed case keys (e.g. \"Content-Type\" and \"content-type\") in the\n        // headers object.\n        const original = Object.keys(headers).find(\n          (o) => o.toLowerCase() === lowercased\n        )\n\n        // If the original casing doesn't exist, return true.\n        if (typeof original === 'undefined') return true\n\n        // If the original casing exists, delete the property.\n        return ReflectAdapter.deleteProperty(target, original)\n      },\n    })\n  }\n\n  /**\n   * Seals a Headers instance to prevent modification by throwing an error when\n   * any mutating method is called.\n   */\n  public static seal(headers: Headers): ReadonlyHeaders {\n    return new Proxy<ReadonlyHeaders>(headers, {\n      get(target, prop, receiver) {\n        switch (prop) {\n          case 'append':\n          case 'delete':\n          case 'set':\n            return ReadonlyHeadersError.callable\n          default:\n            return ReflectAdapter.get(target, prop, receiver)\n        }\n      },\n    })\n  }\n\n  /**\n   * Merges a header value into a string. This stores multiple values as an\n   * array, so we need to merge them into a string.\n   *\n   * @param value a header value\n   * @returns a merged header value (a string)\n   */\n  private merge(value: string | string[]): string {\n    if (Array.isArray(value)) return value.join(', ')\n\n    return value\n  }\n\n  /**\n   * Creates a Headers instance from a plain object or a Headers instance.\n   *\n   * @param headers a plain object or a Headers instance\n   * @returns a headers instance\n   */\n  public static from(headers: IncomingHttpHeaders | Headers): Headers {\n    if (headers instanceof Headers) return headers\n\n    return new HeadersAdapter(headers)\n  }\n\n  public append(name: string, value: string): void {\n    const existing = this.headers[name]\n    if (typeof existing === 'string') {\n      this.headers[name] = [existing, value]\n    } else if (Array.isArray(existing)) {\n      existing.push(value)\n    } else {\n      this.headers[name] = value\n    }\n  }\n\n  public delete(name: string): void {\n    delete this.headers[name]\n  }\n\n  public get(name: string): string | null {\n    const value = this.headers[name]\n    if (typeof value !== 'undefined') return this.merge(value)\n\n    return null\n  }\n\n  public has(name: string): boolean {\n    return typeof this.headers[name] !== 'undefined'\n  }\n\n  public set(name: string, value: string): void {\n    this.headers[name] = value\n  }\n\n  public forEach(\n    callbackfn: (value: string, name: string, parent: Headers) => void,\n    thisArg?: any\n  ): void {\n    for (const [name, value] of this.entries()) {\n      callbackfn.call(thisArg, value, name, this)\n    }\n  }\n\n  public *entries(): HeadersIterator<[string, string]> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(name) as string\n\n      yield [name, value] as [string, string]\n    }\n  }\n\n  public *keys(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      const name = key.toLowerCase()\n      yield name\n    }\n  }\n\n  public *values(): HeadersIterator<string> {\n    for (const key of Object.keys(this.headers)) {\n      // We assert here that this is a string because we got it from the\n      // Object.keys() call above.\n      const value = this.get(key) as string\n\n      yield value\n    }\n  }\n\n  public [Symbol.iterator](): HeadersIterator<[string, string]> {\n    return this.entries()\n  }\n}\n","import {\n  HeadersAdapter,\n  type ReadonlyHeaders,\n} from '../web/spec-extension/adapters/headers'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { getExpectedRequestStore } from '../app-render/work-unit-async-storage.external'\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreModern,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  postponeWithTracking,\n  abortAndThrowOnSynchronousRequestDataAccess,\n  throwToInterruptStaticGeneration,\n  trackDynamicDataInDynamicRender,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { scheduleImmediate } from '../../lib/scheduler'\nimport { isRequestAPICallableInsideAfter } from './utils'\n\n/**\n * In this version of Next.js `headers()` returns a Promise however you can still reference the properties of the underlying Headers instance\n * synchronously to facilitate migration. The `UnsafeUnwrappedHeaders` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `headers()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedHeaders` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `headers()` value can be awaited or you should call `headers()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedHeaders` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `headers()` will only return a Promise and you will not be able to access the underlying Headers instance\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedHeaders` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedHeaders = ReadonlyHeaders\n\n/**\n * This function allows you to read the HTTP incoming request headers in\n * [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components),\n * [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations),\n * [Route Handlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers) and\n * [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).\n *\n * Read more: [Next.js Docs: `headers`](https://nextjs.org/docs/app/api-reference/functions/headers)\n */\nexport function headers(): Promise<ReadonlyHeaders> {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (workStore) {\n    if (\n      workUnitStore &&\n      workUnitStore.phase === 'after' &&\n      !isRequestAPICallableInsideAfter()\n    ) {\n      throw new Error(\n        `Route ${workStore.route} used \"headers\" inside \"after(...)\". This is not supported. If you need this data inside an \"after\" callback, use \"headers\" outside of the callback. See more info here: https://nextjs.org/docs/canary/app/api-reference/functions/after`\n      )\n    }\n\n    if (workStore.forceStatic) {\n      // When using forceStatic we override all other logic and always just return an empty\n      // headers object without tracking\n      const underlyingHeaders = HeadersAdapter.seal(new Headers({}))\n      return makeUntrackedExoticHeaders(underlyingHeaders)\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      }\n    }\n    if (workStore.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        // We don't track dynamic access here because access will be tracked when you access\n        // one of the properties of the headers object.\n        return makeDynamicallyTrackedExoticHeaders(\n          workStore.route,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender (no dynamicIO)\n        // We are prerendering with PPR. We need track dynamic access here eagerly\n        // to keep continuity with how headers has worked in PPR without dynamicIO.\n        // TODO consider switching the semantic to throw on property access instead\n        postponeWithTracking(\n          workStore.route,\n          'headers',\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // Legacy Prerender\n        // We are in a legacy static generation mode while prerendering\n        // We track dynamic access here so we don't need to wrap the headers in\n        // individual property access tracking.\n        throwToInterruptStaticGeneration('headers', workStore, workUnitStore)\n      }\n    }\n    // We fall through to the dynamic context below but we still track dynamic access\n    // because in dev we can still error for things like using headers inside a cache context\n    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n  }\n\n  const requestStore = getExpectedRequestStore('headers')\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    return makeUntrackedExoticHeadersWithDevWarnings(\n      requestStore.headers,\n      workStore?.route\n    )\n  } else {\n    return makeUntrackedExoticHeaders(requestStore.headers)\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedHeaders = new WeakMap<CacheLifetime, Promise<ReadonlyHeaders>>()\n\nfunction makeDynamicallyTrackedExoticHeaders(\n  route: string,\n  prerenderStore: PrerenderStoreModern\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(prerenderStore)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = makeHangingPromise<ReadonlyHeaders>(\n    prerenderStore.renderSignal,\n    '`headers()`'\n  )\n  CachedHeaders.set(prerenderStore, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: function append() {\n        const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    delete: {\n      value: function _delete() {\n        const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    has: {\n      value: function has() {\n        const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    set: {\n      value: function set() {\n        const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    getSetCookie: {\n      value: function getSetCookie() {\n        const expression = '`headers().getSetCookie()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    forEach: {\n      value: function forEach() {\n        const expression = '`headers().forEach(...)`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    keys: {\n      value: function keys() {\n        const expression = '`headers().keys()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    values: {\n      value: function values() {\n        const expression = '`headers().values()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    entries: {\n      value: function entries() {\n        const expression = '`headers().entries()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`headers()[Symbol.iterator]()`'\n        const error = createHeadersAccessError(route, expression)\n        abortAndThrowOnSynchronousRequestDataAccess(\n          route,\n          expression,\n          error,\n          prerenderStore\n        )\n      },\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeaders(\n  underlyingHeaders: ReadonlyHeaders\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = Promise.resolve(underlyingHeaders)\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: underlyingHeaders.append.bind(underlyingHeaders),\n    },\n    delete: {\n      value: underlyingHeaders.delete.bind(underlyingHeaders),\n    },\n    get: {\n      value: underlyingHeaders.get.bind(underlyingHeaders),\n    },\n    has: {\n      value: underlyingHeaders.has.bind(underlyingHeaders),\n    },\n    set: {\n      value: underlyingHeaders.set.bind(underlyingHeaders),\n    },\n    getSetCookie: {\n      value: underlyingHeaders.getSetCookie.bind(underlyingHeaders),\n    },\n    forEach: {\n      value: underlyingHeaders.forEach.bind(underlyingHeaders),\n    },\n    keys: {\n      value: underlyingHeaders.keys.bind(underlyingHeaders),\n    },\n    values: {\n      value: underlyingHeaders.values.bind(underlyingHeaders),\n    },\n    entries: {\n      value: underlyingHeaders.entries.bind(underlyingHeaders),\n    },\n    [Symbol.iterator]: {\n      value: underlyingHeaders[Symbol.iterator].bind(underlyingHeaders),\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction makeUntrackedExoticHeadersWithDevWarnings(\n  underlyingHeaders: ReadonlyHeaders,\n  route?: string\n): Promise<ReadonlyHeaders> {\n  const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n  if (cachedHeaders) {\n    return cachedHeaders\n  }\n\n  const promise = new Promise<ReadonlyHeaders>((resolve) =>\n    scheduleImmediate(() => resolve(underlyingHeaders))\n  )\n\n  CachedHeaders.set(underlyingHeaders, promise)\n\n  Object.defineProperties(promise, {\n    append: {\n      value: function append() {\n        const expression = `\\`headers().append(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.append.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    delete: {\n      value: function _delete() {\n        const expression = `\\`headers().delete(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.delete.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    get: {\n      value: function get() {\n        const expression = `\\`headers().get(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.get.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    has: {\n      value: function has() {\n        const expression = `\\`headers().has(${describeNameArg(arguments[0])})\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.has.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    set: {\n      value: function set() {\n        const expression = `\\`headers().set(${describeNameArg(arguments[0])}, ...)\\``\n        syncIODev(route, expression)\n        return underlyingHeaders.set.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    getSetCookie: {\n      value: function getSetCookie() {\n        const expression = '`headers().getSetCookie()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.getSetCookie.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    forEach: {\n      value: function forEach() {\n        const expression = '`headers().forEach(...)`'\n        syncIODev(route, expression)\n        return underlyingHeaders.forEach.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    keys: {\n      value: function keys() {\n        const expression = '`headers().keys()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.keys.apply(underlyingHeaders, arguments as any)\n      },\n    },\n    values: {\n      value: function values() {\n        const expression = '`headers().values()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.values.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    entries: {\n      value: function entries() {\n        const expression = '`headers().entries()`'\n        syncIODev(route, expression)\n        return underlyingHeaders.entries.apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n    [Symbol.iterator]: {\n      value: function () {\n        const expression = '`...headers()` or similar iteration'\n        syncIODev(route, expression)\n        return underlyingHeaders[Symbol.iterator].apply(\n          underlyingHeaders,\n          arguments as any\n        )\n      },\n    },\n  } satisfies HeadersExtensions)\n\n  return promise\n}\n\nfunction describeNameArg(arg: unknown) {\n  return typeof arg === 'string' ? `'${arg}'` : '...'\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createHeadersAccessError\n)\n\nfunction createHeadersAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`headers()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\ntype HeadersExtensions = {\n  [K in keyof ReadonlyHeaders]: unknown\n}\n","import {\n  getDraftModeProviderForCacheScope,\n  throwForMissingRequestStore,\n} from '../app-render/work-unit-async-storage.external'\n\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\n\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  postponeWithTracking,\n  trackSynchronousRequestDataAccessInDev,\n} from '../app-render/dynamic-rendering'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\nimport { DynamicServerError } from '../../client/components/hooks-server-context'\n\n/**\n * In this version of Next.js `draftMode()` returns a Promise however you can still reference the properties of the underlying draftMode object\n * synchronously to facilitate migration. The `UnsafeUnwrappedDraftMode` type is added to your code by a codemod that attempts to automatically\n * updates callsites to reflect the new Promise return type. There are some cases where `draftMode()` cannot be automatically converted, namely\n * when it is used inside a synchronous function and we can't be sure the function can be made async automatically. In these cases we add an\n * explicit type case to `UnsafeUnwrappedDraftMode` to enable typescript to allow for the synchronous usage only where it is actually necessary.\n *\n * You should should update these callsites to either be async functions where the `draftMode()` value can be awaited or you should call `draftMode()`\n * from outside and await the return value before passing it into this function.\n *\n * You can find instances that require manual migration by searching for `UnsafeUnwrappedDraftMode` in your codebase or by search for a comment that\n * starts with `@next-codemod-error`.\n *\n * In a future version of Next.js `draftMode()` will only return a Promise and you will not be able to access the underlying draftMode object directly\n * without awaiting the return value first. When this change happens the type `UnsafeUnwrappedDraftMode` will be updated to reflect that is it no longer\n * usable.\n *\n * This type is marked deprecated to help identify it as target for refactoring away.\n *\n * @deprecated\n */\nexport type UnsafeUnwrappedDraftMode = DraftMode\n\nexport function draftMode(): Promise<DraftMode> {\n  const callingExpression = 'draftMode'\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (!workStore || !workUnitStore) {\n    throwForMissingRequestStore(callingExpression)\n  }\n\n  switch (workUnitStore.type) {\n    case 'request':\n      return createOrGetCachedExoticDraftMode(\n        workUnitStore.draftMode,\n        workStore\n      )\n\n    case 'cache':\n    case 'unstable-cache':\n      // Inside of `\"use cache\"` or `unstable_cache`, draft mode is available if\n      // the outmost work unit store is a request store, and if draft mode is\n      // enabled.\n      const draftModeProvider = getDraftModeProviderForCacheScope(\n        workStore,\n        workUnitStore\n      )\n\n      if (draftModeProvider) {\n        return createOrGetCachedExoticDraftMode(draftModeProvider, workStore)\n      }\n\n    // Otherwise, we fall through to providing an empty draft mode.\n    // eslint-disable-next-line no-fallthrough\n    case 'prerender':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // Return empty draft mode\n      if (\n        process.env.NODE_ENV === 'development' &&\n        !workStore?.isPrefetchRequest\n      ) {\n        const route = workStore?.route\n        return createExoticDraftModeWithDevWarnings(null, route)\n      } else {\n        return createExoticDraftMode(null)\n      }\n\n    default:\n      const _exhaustiveCheck: never = workUnitStore\n      return _exhaustiveCheck\n  }\n}\n\nfunction createOrGetCachedExoticDraftMode(\n  draftModeProvider: DraftModeProvider,\n  workStore: WorkStore | undefined\n): Promise<DraftMode> {\n  const cachedDraftMode = CachedDraftModes.get(draftMode)\n\n  if (cachedDraftMode) {\n    return cachedDraftMode\n  }\n\n  let promise: Promise<DraftMode>\n\n  if (process.env.NODE_ENV === 'development' && !workStore?.isPrefetchRequest) {\n    const route = workStore?.route\n    promise = createExoticDraftModeWithDevWarnings(draftModeProvider, route)\n  } else {\n    promise = createExoticDraftMode(draftModeProvider)\n  }\n\n  CachedDraftModes.set(draftModeProvider, promise)\n\n  return promise\n}\n\ninterface CacheLifetime {}\nconst CachedDraftModes = new WeakMap<CacheLifetime, Promise<DraftMode>>()\n\nfunction createExoticDraftMode(\n  underlyingProvider: null | DraftModeProvider\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      return instance.isEnabled\n    },\n    set(newValue) {\n      Object.defineProperty(promise, 'isEnabled', {\n        value: newValue,\n        writable: true,\n        enumerable: true,\n      })\n    },\n    enumerable: true,\n    configurable: true,\n  })\n  ;(promise as any).enable = instance.enable.bind(instance)\n  ;(promise as any).disable = instance.disable.bind(instance)\n\n  return promise\n}\n\nfunction createExoticDraftModeWithDevWarnings(\n  underlyingProvider: null | DraftModeProvider,\n  route: undefined | string\n): Promise<DraftMode> {\n  const instance = new DraftMode(underlyingProvider)\n  const promise = Promise.resolve(instance)\n\n  Object.defineProperty(promise, 'isEnabled', {\n    get() {\n      const expression = '`draftMode().isEnabled`'\n      syncIODev(route, expression)\n      return instance.isEnabled\n    },\n    set(newValue) {\n      Object.defineProperty(promise, 'isEnabled', {\n        value: newValue,\n        writable: true,\n        enumerable: true,\n      })\n    },\n    enumerable: true,\n    configurable: true,\n  })\n\n  Object.defineProperty(promise, 'enable', {\n    value: function get() {\n      const expression = '`draftMode().enable()`'\n      syncIODev(route, expression)\n      return instance.enable.apply(instance, arguments as any)\n    },\n  })\n\n  Object.defineProperty(promise, 'disable', {\n    value: function get() {\n      const expression = '`draftMode().disable()`'\n      syncIODev(route, expression)\n      return instance.disable.apply(instance, arguments as any)\n    },\n  })\n\n  return promise\n}\n\nclass DraftMode {\n  /**\n   * @internal - this declaration is stripped via `tsc --stripInternal`\n   */\n  private readonly _provider: null | DraftModeProvider\n\n  constructor(provider: null | DraftModeProvider) {\n    this._provider = provider\n  }\n  get isEnabled() {\n    if (this._provider !== null) {\n      return this._provider.isEnabled\n    }\n    return false\n  }\n  public enable() {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    trackDynamicDraftMode('draftMode().enable()')\n    if (this._provider !== null) {\n      this._provider.enable()\n    }\n  }\n  public disable() {\n    trackDynamicDraftMode('draftMode().disable()')\n    if (this._provider !== null) {\n      this._provider.disable()\n    }\n  }\n}\n\nfunction syncIODev(route: string | undefined, expression: string) {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (\n    workUnitStore &&\n    workUnitStore.type === 'request' &&\n    workUnitStore.prerenderPhase === true\n  ) {\n    // When we're rendering dynamically in dev we need to advance out of the\n    // Prerender environment when we read Request data synchronously\n    const requestStore = workUnitStore\n    trackSynchronousRequestDataAccessInDev(requestStore)\n  }\n  // In all cases we warn normally\n  warnForSyncAccess(route, expression)\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createDraftModeAccessError\n)\n\nfunction createDraftModeAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`draftMode()\\` should be awaited before using its value. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n\nfunction trackDynamicDraftMode(expression: string) {\n  const store = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (store) {\n    // We have a store we want to track dynamic data access to ensure we\n    // don't statically generate routes that manipulate draft mode.\n    if (workUnitStore) {\n      if (workUnitStore.type === 'cache') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n        )\n      } else if (workUnitStore.type === 'unstable-cache') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n        )\n      } else if (workUnitStore.phase === 'after') {\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n        )\n      }\n    }\n\n    if (store.dynamicShouldError) {\n      throw new StaticGenBailoutError(\n        `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    if (workUnitStore) {\n      if (workUnitStore.type === 'prerender') {\n        // dynamicIO Prerender\n        const error = new Error(\n          `Route ${store.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n        )\n        abortAndThrowOnSynchronousRequestDataAccess(\n          store.route,\n          expression,\n          error,\n          workUnitStore\n        )\n      } else if (workUnitStore.type === 'prerender-ppr') {\n        // PPR Prerender\n        postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      } else if (workUnitStore.type === 'prerender-legacy') {\n        // legacy Prerender\n        workUnitStore.revalidate = 0\n\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      } else if (\n        process.env.NODE_ENV === 'development' &&\n        workUnitStore &&\n        workUnitStore.type === 'request'\n      ) {\n        workUnitStore.usedDynamic = true\n      }\n    }\n  }\n}\n","module.exports.cookies = require('./dist/server/request/cookies').cookies\nmodule.exports.headers = require('./dist/server/request/headers').headers\nmodule.exports.draftMode = require('./dist/server/request/draft-mode').draftMode\n"],"names":["MutableRequestCookiesAdapter","ReadonlyRequestCookiesError","RequestCookiesAdapter","appendMutableCookies","areCookiesMutableInCurrentPhase","getModifiedCookieValues","responseCookiesToRequestCookies","wrapWithMutableAccessCheck","Error","constructor","callable","seal","cookies","Proxy","get","target","prop","receiver","ReflectAdapter","SYMBOL_MODIFY_COOKIE_VALUES","Symbol","for","modified","Array","isArray","length","headers","mutableCookies","modifiedCookieValues","resCookies","ResponseCookies","returnedCookies","getAll","cookie","set","wrap","onUpdateCookies","responseCookies","Headers","modifiedValues","modifiedCookies","Set","updateResponseCookies","workStore","workAsyncStorage","getStore","pathWasRevalidated","allCookies","filter","c","has","name","serializedCookies","tempCookies","push","toString","wrappedCookies","args","add","delete","ensureCookiesAreStillMutable","requestStore","phase","callingExpression","getExpectedRequestStore","requestCookies","RequestCookies","createDedupedByCallsiteServerErrorLoggerDev","errorRef","current","cache","React","fn","logErrorOrWarn","process","env","__NEXT_DYNAMIC_IO","console","error","warn","flushCurrentErrorIfNew","key","getMessage","logDedupedError","message","NODE_ENV","workUnitStore","workUnitAsyncStorage","isRequestAPICallableInsideAfter","route","forceStatic","underlyingCookies","createEmptyCookies","makeUntrackedExoticCookies","type","dynamicShouldError","StaticGenBailoutError","makeDynamicallyTrackedExoticCookies","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","trackDynamicDataInDynamicRender","userspaceMutableCookies","isPrefetchRequest","CachedCookies","WeakMap","prerenderStore","cachedPromise","promise","makeHangingPromise","renderSignal","Object","defineProperties","iterator","value","expression","createCookiesAccessError","abortAndThrowOnSynchronousRequestDataAccess","size","arguments","describeNameArg","arg","clear","cachedCookies","Promise","resolve","bind","polyfilledResponseCookiesIterator","polyfilledResponseCookiesClear","makeUntrackedExoticCookiesWithDevWarnings","scheduleImmediate","syncIODev","apply","call","writable","prerenderPhase","trackSynchronousRequestDataAccessInDev","warnForSyncAccess","prefix","map","values","returnable","HeadersAdapter","ReadonlyHeadersError","lowercased","toLowerCase","original","keys","find","o","deleteProperty","merge","join","from","append","existing","forEach","callbackfn","thisArg","entries","underlyingHeaders","makeUntrackedExoticHeaders","makeDynamicallyTrackedExoticHeaders","CachedHeaders","cachedHeaders","createHeadersAccessError","_delete","getSetCookie","makeUntrackedExoticHeadersWithDevWarnings","draftMode","throwForMissingRequestStore","createOrGetCachedExoticDraftMode","draftModeProvider","getDraftModeProviderForCacheScope","createExoticDraftMode","_exhaustiveCheck","cachedDraftMode","CachedDraftModes","underlyingProvider","instance","DraftMode","defineProperty","isEnabled","newValue","enumerable","configurable","enable","disable","createExoticDraftModeWithDevWarnings","provider","_provider","trackDynamicDraftMode","createDraftModeAccessError","store","revalidate","err","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","stack"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6]}
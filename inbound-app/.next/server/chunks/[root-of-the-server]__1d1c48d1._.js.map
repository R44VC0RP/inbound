{"version":3,"sources":["turbopack:///[project]/app/api/v1/lib/auth.ts","turbopack:///[project]/app/api/v1.1/domains/route.ts","turbopack:///[project]/node_modules/next/dist/src/build/templates/app-route.ts"],"sourcesContent":["import { NextRequest } from 'next/server'\nimport { auth } from '@/lib/auth/auth'\n\nexport interface ApiKeyValidationResult {\n  valid: boolean\n  user?: {\n    id: string\n    email: string\n    name: string | null\n  }\n  error?: string\n}\n\n/**\n * Validates an API key from the Authorization header\n * Expected format: \"Bearer <api_key>\" or just \"<api_key>\"\n */\nexport async function validateApiKey(request: NextRequest): Promise<ApiKeyValidationResult> {\n  try {\n    // Get the Authorization header\n    const authHeader = request.headers.get('Authorization')\n    \n    if (!authHeader) {\n      return {\n        valid: false,\n        error: 'Missing Authorization header'\n      }\n    }\n\n    // Extract the API key (support both \"Bearer <key>\" and just \"<key>\")\n    let apiKey: string\n    if (authHeader.startsWith('Bearer ')) {\n      apiKey = authHeader.substring(7)\n    } else {\n      apiKey = authHeader\n    }\n\n    console.log(\"API KEY: \" + apiKey)\n\n    if (!apiKey) {\n      return {\n        valid: false,\n        error: 'Invalid Authorization header format'\n      }\n    }\n\n    // Verify the API key using Better Auth\n    const { valid, error, key } = await auth.api.verifyApiKey({\n      body: {\n        key: apiKey\n      }\n    })\n\n    console.log(\"VALID: \" + valid)\n    console.log(\"ERROR: \" + error)\n    console.log(\"KEY: \" + key?.userId)\n\n    if (!valid || error || !key) {\n      return {\n        valid: false,\n        error: error?.message || 'Invalid API key'\n      }\n    }\n\n    // Check if the API key is enabled\n    if (!key.enabled) {\n      return {\n        valid: false,\n        error: 'API key is disabled'\n      }\n    }\n\n    // Check if the API key has expired\n    if (key.expiresAt && new Date(key.expiresAt) < new Date()) {\n      return {\n        valid: false,\n        error: 'API key has expired'\n      }\n    }\n\n    // Use the userId from the API key directly\n    return {\n      valid: true,\n      user: {\n        id: key.userId,\n        email: key.userId, // We don't have email from API key, use userId as fallback\n        name: null // We don't have name from API key\n      }\n    }\n  } catch (error) {\n    console.error('API key validation error:', error)\n    return {\n      valid: false,\n      error: 'Internal server error during API key validation'\n    }\n  }\n}\n\n/**\n * Middleware function to validate API key and return standardized error responses\n */\nexport function createApiKeyMiddleware() {\n  return async (request: NextRequest) => {\n    const validation = await validateApiKey(request)\n    \n    if (!validation.valid) {\n      return {\n        error: validation.error,\n        status: 401\n      }\n    }\n\n    return {\n      user: validation.user!\n    }\n  }\n} ","import { NextRequest, NextResponse } from 'next/server'\nimport { validateApiKey } from '@/app/api/v1/lib/auth'\nimport { db } from '@/lib/db'\nimport { emailDomains, emailAddresses, endpoints } from '@/lib/db/schema'\nimport { eq, and, count, desc } from 'drizzle-orm'\n\nexport async function GET(request: NextRequest) {\n  try {\n    console.log('üìã GET /api/v1.1/domains - Fetching user domains')\n    \n    const validation = await validateApiKey(request)\n    if ('error' in validation) {\n      return NextResponse.json({ error: validation.error }, { status: 401 })\n    }\n\n    const userId = validation.user?.id\n    if (!userId) {\n      return NextResponse.json({ error: 'User not found' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(request.url)\n    const status = searchParams.get('status')\n    const canReceive = searchParams.get('canReceive')\n    const limit = Math.min(parseInt(searchParams.get('limit') || '50'), 100)\n    const offset = parseInt(searchParams.get('offset') || '0')\n\n    // Build where conditions\n    const conditions = [eq(emailDomains.userId, userId)]\n\n    if (status && ['verified', 'pending', 'failed'].includes(status)) {\n      conditions.push(eq(emailDomains.status, status))\n    }\n\n    if (canReceive !== null) {\n      const canReceiveEmails = canReceive === 'true'\n      conditions.push(eq(emailDomains.canReceiveEmails, canReceiveEmails))\n    }\n\n    const whereConditions = conditions.length > 1 ? and(...conditions) : conditions[0]\n\n    // Get domains with enhanced data\n    const domainsQuery = db\n      .select({\n        id: emailDomains.id,\n        domain: emailDomains.domain,\n        status: emailDomains.status,\n        canReceiveEmails: emailDomains.canReceiveEmails,\n        hasMxRecords: emailDomains.hasMxRecords,\n        catchAllEndpointId: emailDomains.catchAllEndpointId,\n        verificationToken: emailDomains.verificationToken,\n        domainProvider: emailDomains.domainProvider,\n        createdAt: emailDomains.createdAt,\n        updatedAt: emailDomains.updatedAt\n      })\n      .from(emailDomains)\n      .where(whereConditions)\n\n    const domains = await domainsQuery\n      .orderBy(desc(emailDomains.createdAt))\n      .limit(limit)\n      .offset(offset)\n\n    // Get total count for pagination (using same filters as main query)\n    const totalCountResult = await db\n      .select({ count: count() })\n      .from(emailDomains)\n      .where(whereConditions)\n    \n    const totalCount = totalCountResult[0]?.count || 0\n\n    // Enhance domains with additional data\n    const enhancedDomains = await Promise.all(\n      domains.map(async (domain: any) => {\n        // Get email address count\n        const emailCountResult = await db\n          .select({ count: count() })\n          .from(emailAddresses)\n          .where(eq(emailAddresses.domainId, domain.id))\n        \n        const emailCount = emailCountResult[0]?.count || 0\n\n        // Get active email address count\n        const activeEmailCountResult = await db\n          .select({ count: count() })\n          .from(emailAddresses)\n          .where(and(\n            eq(emailAddresses.domainId, domain.id),\n            eq(emailAddresses.isActive, true)\n          ))\n        \n        const activeEmailCount = activeEmailCountResult[0]?.count || 0\n\n        // Get catch-all endpoint info if configured\n        let catchAllEndpoint = null\n        if (domain.catchAllEndpointId) {\n          const endpointResult = await db\n            .select({\n              id: endpoints.id,\n              name: endpoints.name,\n              type: endpoints.type,\n              isActive: endpoints.isActive\n            })\n            .from(endpoints)\n            .where(eq(endpoints.id, domain.catchAllEndpointId))\n            .limit(1)\n          \n          catchAllEndpoint = endpointResult[0] || null\n        }\n\n        return {\n          ...domain,\n          stats: {\n            totalEmailAddresses: emailCount,\n            activeEmailAddresses: activeEmailCount,\n            hasCatchAll: !!domain.catchAllEndpointId\n          },\n          catchAllEndpoint,\n          isVerified: domain.status === 'verified'\n        }\n      })\n    )\n\n    console.log(`‚úÖ GET /api/v1.1/domains - Retrieved ${domains.length} domains for user ${userId}`)\n\n    return NextResponse.json({\n      success: true,\n      data: enhancedDomains,\n      pagination: {\n        limit,\n        offset,\n        total: totalCount,\n        hasMore: offset + limit < totalCount\n      },\n      meta: {\n        totalCount,\n        verifiedCount: enhancedDomains.filter((d: any) => d.isVerified).length,\n        withCatchAllCount: enhancedDomains.filter((d: any) => d.stats.hasCatchAll).length,\n        statusBreakdown: {\n          verified: enhancedDomains.filter((d: any) => d.status === 'verified').length,\n          pending: enhancedDomains.filter((d: any) => d.status === 'pending').length,\n          failed: enhancedDomains.filter((d: any) => d.status === 'failed').length\n        }\n      }\n    })\n\n  } catch (error) {\n    console.error('‚ùå GET /api/v1.1/domains - Error:', error)\n    return NextResponse.json(\n      { \n        success: false,\n        error: 'Failed to fetch domains',\n        details: error instanceof Error ? error.message : 'Unknown error'\n      },\n      { status: 500 }\n    )\n  }\n} ","import {\n  AppRouteRouteModule,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks"],"mappings":"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","ignoreList":[2]}